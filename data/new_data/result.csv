,shixun_id,shixun_name,challenge_id,challenge_name,answer_id,answer_contents
0,6934,软件工程之单元测试,3imyf4av9whg,计算两个数组的并集,20855,"```C
#include <string.h>
#include <stdlib.h>
#include ""student.h""

void intersection(int* A, int* B, int lenA, int lenB, int** C, int* lenC)
{
	/*
	
A表示数组A，B表示数组B，lenA表示数组A的长度，lenB表示数组
	B的长度，C表示结果，lenC表示结果的长度
	需要将交集存放在数组C中。
	*/

	/*********Begin********/

	int* hash_A = (int*)malloc(100*sizeof(int));
	int* hash_B = (int*)malloc(100*sizeof(int));
	memset(hash_A, 0, 100);
	memset(hash_B, 0, 100);

	for(int i = 0; i < lenA; ++i)
	{
		hash_A[A[i]]++;
	}
	for(int i = 0; i < lenB; ++i)
	{
		hash_B[B[i]]++;
	}
	int total = 0;
	for(int i = 0; i < 100; ++i)
	{
		if(hash_A[i]>0 && hash_B[i]>0)
			total++;
	}
	int* result = (int*)malloc(total*sizeof(int));
	int cur_index = 0;
	for(int i = 0; i < 100; ++i)
	{
		if(hash_A[i]>0 && hash_B[i]>0)
			result[cur_index++] = i;
	}
	*C = result;
	*lenC = total;
	/*********End*********/
}
```"
1,6934,软件工程之单元测试,9uctfyoz3a8x,自己动手实现单元测试,20857,"```C
#include""func.h""
#include<stdio.h>

void intersection(int* A, int* B, int lenA, int lenB, int** C, int* lenC);

void UnitTest()
{
	/*请按照测试用例来测试交集功能*/
	int pass_count = 0;
	int err_count = 0;
	int total_count = 4;
	/*********Begin*********/
	int A[] = {0, 99, 1, 5, 4, 8, 1, 4};
	int B[] = {12, 44, 4, 8, 0, 99, 1};
	int *C = NULL;
	int lenC = 0;
	intersection(A, B, 8, 7, &C, &lenC);
	int result[] = {99, 8, 4, 1, 0};
	if(lenC == 5)
	{
		int pass = 1;
		for(int i = 0; i < lenC; ++i)
		{
			if(C[i] != result[i])
			{
				pass =0;
				break;
			}
		}
		if(pass)
			pass_count++;
		else
			err_count++;
	}
	else
		err_count++;

	int A1[] = {0};
	int B1[] = {0};
	C = NULL;
	lenC = 0;
	intersection(A1, B1, 1, 1, &C, &lenC);
	int result1[] = {0};
	if(lenC == 1)
	{
		int pass = 1;
		for(int i = 0; i < lenC; ++i)
		{
			if(C[i] != result1[i])
			{
				pass =0;
				break;
			}
		}
		if(pass)
			pass_count++;
		else
			err_count++;
	}
	else
		err_count++;

	int A2[] = {1, 2, 3, 4, 5};
	int B2[] = {5, 3, 2, 1, 4};
	C = NULL;
	lenC = 0;
	intersection(A2, B2, 5, 5, &C, &lenC);
	int result2[] = {5, 4, 3, 2, 1};
	if(lenC == 5)
	{
		int pass = 1;
		for(int i = 0; i < lenC; ++i)
		{
			if(C[i] != result2[i])
			{
				pass =0;
				break;
			}
		}
		if(pass)
			pass_count++;
		else
			err_count++;
	}
	else
		err_count++;

	int A3[] = {6, 6, 6, 6, 6, 6, 6};
	int B3[] = {6};
	C = NULL;
	lenC = 0;
	intersection(A3, B3, 7, 1, &C, &lenC);
	int result3[] = {6};
	if(lenC == 1)
	{
		int pass = 1;
		for(int i = 0; i < lenC; ++i)
		{
			if(C[i] != result3[i])
			{
				pass =0;
				break;
			}
		}
		if(pass)
			pass_count++;
		else
			err_count++;
	}
	else
		err_count++;
	/*********End*********/
	printf(""pass_count=%d, err_count=%d, total_count=%d\n"", pass_count, err_count, total_count);
}
```"
2,6934,软件工程之单元测试,a6rlgt89ouch,CuTest实现单元测试,20860,"```C
#include ""CuTest.h""
#include""func.h""
#include<stdio.h>

//计算两个数组的交集，并将结果转换成字符串返回
char* intersection(int* A, int* B, int lenA, int lenB);


void TestCase1(CuTest *tc) 
{
	//测试用例1
	/*********Begin*********/
	int A[] = {0, 99, 1, 5, 4, 8, 1, 4};
	int B[] = {12, 44, 4, 8, 0, 99, 1};
	char* actual = intersection(A, B, 8, 7);
	char* expected = ""99, 8, 4, 1, 0"";
    CuAssertStrEquals(tc, expected, actual);
	/*********End*********/
}

void TestCase2(CuTest *tc) 
{
	//测试用例2
	/*********Begin*********/
	int A[] = {0};
	int B[] = {0};
	char* actual = intersection(A, B, 1, 1);
	char* expected = ""0"";
    CuAssertStrEquals(tc, expected, actual);
	/*********End*********/
}

void TestCase3(CuTest *tc) 
{
	//测试用例3
	/*********Begin*********/
	int A[] = {1, 2, 3, 4, 5};
	int B[] = {5, 3, 2, 1, 4};
	char* actual = intersection(A, B, 5, 5);
	char* expected = ""5, 4, 3, 2, 1"";
    CuAssertStrEquals(tc, expected, actual);
	/*********End*********/
}

void TestCase4(CuTest *tc) 
{
	//测试用例4
	/*********Begin*********/
	int A[] = {6, 6, 6, 6, 6, 6, 6};
	int B[] = {6};
	char* actual = intersection(A, B, 7, 1);
	char* expected = ""6"";
    CuAssertStrEquals(tc, expected, actual);
	/*********End*********/
}

CuSuite* GetSuite() {
    CuSuite* suite = CuSuiteNew();
    SUITE_ADD_TEST(suite, TestCase1);
    SUITE_ADD_TEST(suite, TestCase2);
    SUITE_ADD_TEST(suite, TestCase3);
	SUITE_ADD_TEST(suite, TestCase4);
    return suite;
}


void RunAllTests() 
{
	/*
	运行所有的测试用例
	*/
    CuString *output = CuStringNew();
    CuSuite* suite = CuSuiteNew();

	/*********Begin*********/

    CuSuiteAddSuite(suite, GetSuite());

	/*********End*********/
	CuSuiteRun(suite);
    CuSuiteSummary(suite, output);
    CuSuiteDetails(suite, output);
    printf(""%s\n"", output->buffer);
}
```"
3,7003,航母拦阻索“拉钩”次数统计,qatk8ye2fjhl,航母拦阻索的“拉钩”次数统计,21976,"#include <stdio.h>
// 定义main函数
int main()
{
    // 请在此添加代码
    /********** Begin *********/
	int m,n,i=1,count,sum=0,left;
	scanf(""%d%d"",&n,&m);
	
	while(i<=n)
	{
		scanf(""%d"",&count);
		sum=sum+count;
		i=i+1;
	}
	left=m-sum;
	printf(""航母阻拦索的拉钩总次数：%d\n阻拦索剩余使用次数：%d\n"",sum,left);

    /********** End **********/
    return 0;
}"
4,6853,Paxos算法,p5m4fef9atgl,使用Paxos算法完成程序设计,20911,"`Acceptor.cpp`
```cpp
#include ""Acceptor.h""


namespace paxos
{


Acceptor::Acceptor(void)
{
	m_maxSerialNum = 0;
	m_lastAcceptValue.serialNum = 0;
	m_lastAcceptValue.value = 0;
}

Acceptor::~Acceptor(void)
{
}

bool Acceptor::Propose(unsigned int serialNum, PROPOSAL &lastAcceptValue)
{
	if ( 0 == serialNum ) return false;
	//提议不通过
	if ( m_maxSerialNum > serialNum ) return false;
	//接受提议
    //请完善下面逻辑

	/**********Begin**********/
    m_maxSerialNum = serialNum;
    lastAcceptValue = m_lastAcceptValue;
	/**********End**********/

	return true;
}

bool Acceptor::Accept(PROPOSAL &value)
{
	if ( 0 == value.serialNum ) return false;
	//Acceptor又重新答应了其他提议
   //请完善下面逻辑
	/**********Begin**********/
    if ( m_maxSerialNum > value.serialNum ) return false;

	/**********End**********/

    
	//批准提议通过
    //请完善下面逻辑
    /**********Begin**********/
    m_lastAcceptValue = value;

	/**********End**********/

	return true;
}

}

```


`Proposer.cpp`
```cpp
#include ""Proposer.h""

namespace paxos
{

Proposer::Proposer()
{
	SetPlayerCount(0, 0);
}

Proposer::Proposer(short proposerCount, short acceptorCount)
{
	SetPlayerCount(proposerCount, acceptorCount);
}

Proposer::~Proposer()
{
}

void Proposer::SetPlayerCount(short proposerCount, short acceptorCount)
{
	m_proposerCount = proposerCount;
	m_acceptorCount = acceptorCount;

	return;
}

void Proposer::StartPropose(PROPOSAL &value)
{
	m_value = value;
	m_proposeFinished = false;
	m_isAgree = false;
	m_maxAcceptedSerialNum = 0;
	m_okCount = 0;
	m_refuseCount = 0;
	m_start = time(NULL);

	return;
}

PROPOSAL& Proposer::GetProposal()
{
	return m_value;
}

bool Proposer::Proposed(bool ok, PROPOSAL &lastAcceptValue)
{
	if ( m_proposeFinished ) return true;//可能是一阶段迟到的回应，直接忽略消息

	if ( !ok ) 
	{
		m_refuseCount++;
		//已有半数拒绝，不需要等待其它acceptor投票了，重新开始Propose阶段
		//使用StartPropose(m_value)重置状态
	
        //请完善下面逻辑
 		/**********Begin**********/
    if ( m_refuseCount > m_acceptorCount / 2 ) 
        {
            m_value.serialNum += m_proposerCount;
            StartPropose(m_value);
            return false;
        }
	    /**********End**********/

		//拒绝数不到一半
		return true;
	}

	m_okCount++;
	/*
		没有必要检查分支：serialNum为null
		因为serialNum>m_maxAcceptedSerialNum，与serialNum非0互为必要条件
	*/
	//如果已经有提议被接受，修改成已被接受的提议
	//请完善下面逻辑
 	/**********Begin**********/
if ( lastAcceptValue.serialNum > m_maxAcceptedSerialNum ) 
    {
        m_maxAcceptedSerialNum = lastAcceptValue.serialNum;
        m_value.value = lastAcceptValue.value;
    }
	/**********End**********/	

	//如果自己的提议被接受
	if ( m_okCount > m_acceptorCount / 2 ) 
	{
		m_okCount = 0;
		m_proposeFinished = true;
	}
	return true;
}

bool Proposer::StartAccept()
{
	return m_proposeFinished;
}

bool Proposer::Accepted(bool ok)
{
	if ( !m_proposeFinished ) return true;//可能是上次第二阶段迟到的回应，直接忽略消息

	if ( !ok ) 
	{
		m_refuseCount++;
		//已有半数拒绝，不需要等待其它acceptor投票了，重新开始Propose阶段
		//使用StartPropose(m_value)重置状态
	    //请完善下面逻辑
        /**********Begin**********/
    if ( m_refuseCount > m_acceptorCount / 2 ) 
        {
            m_value.serialNum += m_proposerCount;
            StartPropose(m_value);
            return false;
        }
	    
        
        /**********End**********/
 		
		return true;
	}

	m_okCount++;
	if ( m_okCount > m_acceptorCount / 2 ) m_isAgree = true;

	return true;
}

bool Proposer::IsAgree()
{
	return m_isAgree;
}

}


```"
5,6976,计算机算法设计与分析：线性规划问题和单纯形算法,ch5nzlyik4ag,单纯性算法解一般线性方程组,20960,"```
#pragma once

#include <cmath>
#include <iostream>
#include<fstream>
#include <string>
#include <iomanip>
#include <cfloat>

using namespace std;

class LinearProgram
{
public:
		LinearProgram();
		~LinearProgram();
		void solve();
	private:
		int enter(int objrow);
		int leave(int col);
		int simplex(int objrow);
		int phase1();
		int phase2();
		int compute();
		void swapbasic(int row,int col);
		void pivot(int row,int col);
	//	void stats();//这个方法是干什么的？
		void setbasic(int * basicp);
		void output();
		void Make2DArray(double ** & a, int m,int n);
		void Delet2DArray(double ** & a, int m,int n);
		int m,				//约束总数
			n,				//变量数
			m1,				//不等式约束数<=
			m2,				//等式约束
			m3,				//不等式约束数>=
			n1,n2,			//n1 = n + m3,n2 = n1 + m1
			error,			//记录错误类型
			*basic,			//基本变量下标
			*nonbasic;		//非基本变量下标
		double **a,minmax;
};


LinearProgram::LinearProgram()
{
	
	double value;
	cout<<""Enter data in the following format:""<<endl;
	cout<<""1:+1(max)or-1(min);m;n""<<endl;
	cout<<""2:m1;m2;m3""<<endl;
	cout<<""The constraint coefficient and the right term""<<endl;
	cout<<""Objective function coefficient""<<endl;
	error = 0;
 
	cin>>minmax;
	cin>>m;
	cin>>n;
 
	//输入各类约束数
	cin>>m1;
	cin>>m2;
	cin>>m3;
 
	if(m!=m1+m2+m3)
	{
		error = 1;
	}
 
	n1 = n + m3;
	n2 = n + m1 + m3;
	Make2DArray(a,m+2,n1+1);//构造二维数组
	basic = new int[m+2];
	nonbasic = new int[n1+1];
	
	//初始化基本变量和非基本变量
	/*********begin*************/
	    for(int i=0; i<=m+1; i++)
    {
        for(int j=0; j<=n1; j++)
        {
            a[i][j] = 0.0;
        }
    }
    for(int j=0; j<=n1; j++)
    {
        nonbasic[j] = j;
    }
	/*********end***************/
 
	//引入松弛变量和人工变量
	/*********begin*************/
	    for(int i=1,j=n1+1; i<=m; i++,j++)
    {
        basic[i] = j;
    }
    for(int i=m-m3+1,j=n+1; i<=m; i++,j++)
    {
        a[i][j] = -1.0;
        a[m+1][j] = -1.0;
    }
	/*********end***************/
	//输入约束系数和右端项
	for(int i=1; i<=m; i++)
	{
		for(int j=1; j<=n; j++)
		{
			cin>>value;
			a[i][j] = value;
		}
		cin>>value;
		if(value<0) 
		{
			error = 1;
		}
		a[i][0] = value;
	}
 
	//输入目标函数系数
	for(int j=1; j<=n; j++)
	{
		cin>>value;
		a[0][j] =  value * minmax;
	}
 
	//引入人工变量，构造第1阶段的辅助目标函数
	/*********begin*************/
	    for(int j=1; j<=n;  j++)
    {
        value=0.0;
        for(int i=m1+1; i<=m; i++)
        {
            value += a[i][j];
        }
        a[m+1][j] = value;
    } 
	/*********end***************/

}


LinearProgram::~LinearProgram()
{
	delete basic;
	delete nonbasic;
	Delet2DArray(a,m+2,n1+1);

}

void LinearProgram::Make2DArray(double ** & a, int m,int n)
{
	a = new double*[m];
	for (int i=0; i<m; i++)
	{
		a[i] = new double[n];
	}
}

void LinearProgram::Delet2DArray(double ** & a, int m,int n)
{
	for (int i = 0; i <= m;i++)
	{
		delete[]a[i];
		
	}
	delete[]a;
}


//根据目标函数系数所在的行objrow，执行约束标准型线性规划问题的单纯形算法
int LinearProgram::simplex(int objrow)
{
	/*********begin*************/
	    for(int row = 0;;)
    {
        int col = enter(objrow);
        if(col>0)
        {
            row = leave(col);
        }
        else
        {
            return 0;
        }
        if(row>0)
        {
            pivot(row,col);
        }
        else
        {
            return 2;
        }
    }
	/*********end***************/
}
 
//根据目标函数系数所在行objrow，选取入基变量
int LinearProgram::enter(int objrow)
{
	double temp = DBL_EPSILON;	
	int j,col;
	/*********begin*************/
    for(j=1,col=0; j<=n1; j++)
    {
        if(nonbasic[j]<=n2 && a[objrow][j]>temp)
        {
            col = j;
            temp = a[objrow][j];
            break;            //Bland避免循环法则
        }
    }
	/*********end***************/
	return col;
}
 
//根据入基变量所在列col,选取离基变量
int LinearProgram::leave(int col)
{
	double temp = DBL_MAX;
	int row, i;
	/*********begin*************/
	    for(i=1,row=0; i<=m; i++)
    {
        double val = a[i][col];
        if(val>DBL_EPSILON)
        {
            val = a[i][0]/val;
            if(val<temp)
            {
                row = i;
                temp = val;
            }
        }
    }
	/*********end***************/
	return row;
}
 
//以入基变量所在列col和离基变量所在行row交叉处元素a[row][col]为轴心，做转轴变换
void LinearProgram::pivot(int row,int col)
{
	/*********begin*************/
	for(int j=0; j<=n1; j++)
    {
        if(j!=col)
        {
            a[row][j] = a[row][j]/a[row][col];
        }
    }
    a[row][col] = 1.0/a[row][col];
    for(int i=0; i<=m+1; i++)
    {
        if(i!=row)
        {
            for(int j=0; j<=n1; j++)
            {
                if(j!=col)
                {
                    a[i][j] = a[i][j] - a[i][col]*a[row][j];
                    if(fabs(a[i][j])<DBL_EPSILON)
                    {
                        a[i][j] = 0.0;
                    }
                }
            }
            a[i][col] = - a[i][col]*a[row][col];
        }
    }
	/*********end***************/
	swapbasic(row,col);
	
}
 
//交换基本变量row和非基本变量col的位置
void LinearProgram::swapbasic(int row,int col)
{
	int temp = basic[row];
	basic[row] = nonbasic[col];
	nonbasic[col] = temp;
}
 
//对一般的线性规划问题执行两阶段单纯形算法
int LinearProgram::compute()
{
	if(error>0)
	{
		return error;
	}
	if(m!=m1)
	{
		error = phase1();
		if(error>0)
		{
			return error;
		}
		
	}

	return phase2();
}
 
//构造初始基本可行解的第一阶段单纯形算法由phase1()实现
//辅助目标函数存储在数组a的第trows行
int LinearProgram::phase1()
{

	error = simplex(m+1);

	if(error>0)
	{
		return error;
	}
	for(int i=1; i<=m; i++)
	{
		if(basic[i]>n2)
		{
			if(a[i][0]>DBL_EPSILON)
			{
				return 3;
			}
			for(int j=1; j<=n1; j++)
			{
				if(fabs(double(a[i][j]))>=DBL_EPSILON)
				{
					pivot(i,j);
					break;
				}	
			}
		}
	}
	
	return 0;
}
 
//第二阶段根据第一阶段找到的基本可行解，对原来的目标函数用单纯形算法求解
//原目标函数存储在数组a的第0行
int LinearProgram::phase2()
{
	return simplex(0);
}
 
//执行两阶段单纯形算法
void LinearProgram::solve()
{
	cout<<endl<<""* * * 线性规划---单纯形算法 * * *""<<endl<<endl;
	error = compute();
	switch(error)
	{
		case 0:output();break;
		case 1:cout<<""输入数据错误--""<<endl;break;
		case 2:cout<<""无界解--""<<endl;break;
		case 3:cout<<""无可行解--""<<endl;
	}
	cout<<""计算结束""<<endl;
}
 
//输出结果
void LinearProgram::output()
{
	int width = 8,*basicp;
	double zero = 0.0;
	basicp = new int[n+m+1];
	setbasic(basicp);

	cout.setf(ios::fixed|ios::showpoint|ios::right);
	cout.precision(4);

	cout<<endl<<""最优值：""<<-minmax*a[0][0]<<endl<<endl;
	cout<<""最优解：""<<endl<<endl;
	for(int j=1; j<=n; j++)
	{
		cout<<""x""<<j<<"" ="";
		if(basicp[j]!=0)
		{
			cout<<setw(width)<<a[basicp[j]][0];
		}
		else
		{
			cout<<setw(width)<<zero;
		}
		cout<<endl;
	}
	cout<<endl;
	delete []basicp;
} 

void LinearProgram::setbasic(int * basicp)
{
	for(int i=0;i<=n+m;i++)
	{
		basicp[i] = 0;
	}
	for(int i=1;i<=m;i++)
	{
		basicp[basic[i]]=i;
	}
}

```"
6,6701,计算机算法设计与分析：随机化算法,3ewhtbksqp76,硬币实验,20582,"```cpp
#include ""RandomNumber.h""
#include <iostream>
using namespace std;
 
int TossCoins(int numberCoins);
 
int main()
{
	//模拟随机抛硬币事件
	int NCOINS;
	long NTOSSES;
	cin >>NCOINS;
	cin >>NTOSSES;
	
	//heads[i]是得到i次正面的次数
	long i,heads[NCOINS+1];
 
	int j,position;
 
	//初始化数组heads
	for(int j=0; j<NCOINS+1;j++)
	{
		heads[j] = 0;
	}
 
	//重复50,000次模拟事件
	for(int i=0; i<NTOSSES; i++)
	{
		heads[TossCoins(NCOINS)]++;
	}
 
	//输出频率图
	for(int i=0; i<=NCOINS; i++)
	{
		position = int(float(heads[i])/NTOSSES*72);
		cout<<i<<"" "";
		for(int j=0; j<position-1; j++)
		{
			cout<<"" "";
		}
		cout<<""*""<<endl;
	}
 
	return 0;
}
 
int TossCoins(int numberCoins)
{
	//随机抛硬币
	static RandomNumber coinToss(1);
	int i,tosses = 0;
	for(int i=0; i<numberCoins; i++)
	{
		//Random(2) = 1表示正面
		tosses += coinToss.Random(2);
	}
	return tosses;
}
```"
7,6701,计算机算法设计与分析：随机化算法,juv4fwp75tqk,用随机投点法求圆周率,20600,"```cpp
//随机化算法 用随机投点法计算π值
#include ""RandomNumber.h""
#include <iostream>
using namespace std;
 
double Darts(int n);
 
int main()
{
	int n1;
	cin>> n1;
	cout<<""n1=""<<n1<<""\npi=""<<Darts(n1)<<endl;
	return 0;
}
 
//用随机投点法计算π值
double Darts(int n)
{
	static RandomNumber dart(1);
	int k = 0;
 
	for(int i=1; i<=n; i++)
	{
		double x = dart.fRandom();
		double y = dart.fRandom();
		if((x*x + y*y)<=1)
		{
			k++;
		}
	}
 
	return 4*k/double(n);
}
```"
8,6701,计算机算法设计与分析：随机化算法,3jxgzyckoqst,解非线性方程组,20598,"```cpp
//随机化算法 解线性方程组
#include ""RandomNumber.h""
#include <iostream>
using namespace std;
 
bool NonLinear(double *x0,double *dx0,double *x,double *fx,double a0,
					double epsilon,double k,int n,int Steps,int M);
double f(double *x,double *fx);
 
int main()
{
	double  *x0,				//根初值
			*x,					//根
			*dx0,			//增量初值
			*fx,  // 函数值
			a0 = 0.0001,			//步长
			epsilon = 0.01,		//精度
			k = 1.1;			//步长变参
	int n = 2,					//方程个数
		Steps = 10000,			//执行次数
		M = 1000;				//失败次数
 
	x0 = new double[n+1];
	dx0 = new double[n+1];
	x = new double[n+1];
	fx = new double[n+1];
	
	cin >> fx[1];
	cin >> fx[2];
	
	//根初值
	x0[1] = 0.0;
	x0[2] = 0.0;
 
	//增量初值
	dx0[1] = 0.01;
	dx0[2] = 0.01;
 
	cout<<""The original equations are:""<<endl;
	cout<<""x1-x2=""<<fx[1]<<endl;
	cout<<""x1+x2=""<<fx[2]<<endl;
 
	cout<<""The roots are:""<<endl;
 
	bool flag = NonLinear(x0,dx0,x,fx,a0,epsilon,k,n,Steps,M);
	while(!flag)
	{		
		flag = NonLinear(x0,dx0,x,fx,a0,epsilon,k,n,Steps,M);
	}	
	for(int i=1; i<=n; i++)
	{
		cout<<""x""<<i<<""=""<<x[i]<<"" "";
	}
	cout<<endl;
 
	return 0;
}
 
//解非线性方程组的随机化算法
bool NonLinear(double *x0,double *dx0,double *x,double *fx,double a0,
					double epsilon,double k,int n,int Steps,int M)
{
	static RandomNumber rnd(1);
	bool success;			//搜索成功标志
	double *dx,*r;
 
	dx = new double[n+1];	//步进增量向量
	r = new double[n+1];	//搜索方向向量
	int mm = 0;				//当前搜索失败次数
	int j = 0;				//迭代次数
	double a = a0;			//步长因子
 
	for(int i=1; i<=n; i++)
	{
		x[i] = x0[i];
		dx[i] = dx0[i];
	}
 
	double fy = f(x,fx);		//计算目标函数值
	double min = fy;		//当前最优值
 
	while(j<Steps)
	{
		//(1)计算随机搜索步长
		if(fy<min)//搜索成功
		{
			min = fy;
			a *= k;
			success = true;
		}
		else//搜索失败
		{
			mm++;
			if(mm>M)
			{
				a /= k;
			}
			success = false;
		}
 
		if(min<epsilon)
		{
			break;
		}
 
		//(2)计算随机搜索方向和增量
		for(int i=1; i<=n; i++)
		{
			r[i] = 2.0 * rnd.fRandom()-1;
		}
 
		if(success)
		{
			for(int i=1; i<=n; i++)
			{
				dx[i] = a * r[i];
			}
		}
		else
		{
			for(int i=1; i<=n; i++)
			{
				dx[i] = a * r[i] - dx[i];
			}
		}
 
		//(3)计算随机搜索点
		for(int i=1; i<=n; i++)
		{
			x[i] += dx[i];
		}
 
		//(4)计算目标函数值
		fy = f(x,fx);
		j++;
	}	
 
	if(fy<=epsilon)
	{
		return true;
	}
	else
	{
		return false;
	}
}
 
double f(double *x, double* fx)
{
	return (x[1]-x[2]-fx[1])*(x[1]-x[2]-fx[1])
			+(x[1]+x[2]-fx[2])*(x[1]+x[2]-fx[2]);
}

```"
9,5978,课堂实践作业,4uq3p97az65y,资源调度——课堂作业1,,
10,5978,课堂实践作业,gm53clwqpzoj,资源调度——课堂作业2,,
11,4830,综合课堂测试实训,mt7libqfwv4r,另一种冒泡排序算法,,
12,4830,综合课堂测试实训,rq6cl9shtieo,散列技术及应用,,
13,4876,计算机算法设计与分析：分支限界法,ofnpbhg4cqw7,装载问题 (FIFO 优先队列法),15142,"//装载问题 队列式分支限界法求解 

```cpp
#include ""Queue.h""
#include <iostream>
using namespace std;
 
int N = 0;
 
template<class Type>
class QNode
{
	public:
		QNode *parent;	//指向父节点的指针
		bool LChild;    //左儿子标识
		Type weight;    //节点所相应的载重量
};
 
template<class Type>
void EnQueue(Queue<QNode<Type>*>&Q,Type wt,int i,int n,Type bestw,QNode<Type>*E,QNode<Type> *&bestE,int bestx[],bool ch);
 
template<class Type>
Type MaxLoading(Type w[],Type c,int n,int bestx[]);
 
int main()
{
	float c = 0;  
    float w[100] = {0};//下标从1开始  
    int x[100];  
	float bestw;
	
	cin>>N;
	cin >>c;
	for(int i=1; i<=N; i++)  
    {  
        cin>>w[i];  
    }  
    cout<<""Ship load:""<<c<<endl;  
    cout<<""The weight of the goods to be loaded is:""<<endl;  
    for(int i=1; i<=N; i++)  
    {  
        cout<<w[i]<<"" "";  
    }  
    cout<<endl;  
   
    bestw = MaxLoading(w,c,N,x);  
  
    cout<<""Result:""<<endl;  
    for(int i=1; i<=N; i++)  
    {  
        cout<<x[i]<<"" "";  
    }  
    cout<<endl;  
	cout<<""The optimal loading weight is:""<<bestw<<endl;
  
    return 0;  
}
 
//将活节点加入到活节点队列Q中
template<class Type>
void EnQueue(Queue<QNode<Type>*>&Q,Type wt,int i,int n,Type bestw,QNode<Type>*E,QNode<Type> *&bestE,int bestx[],bool ch)
{
	if(i == n)//可行叶节点
	{
		if(wt == bestw)
		{
			//当前最优装载重量
			bestE = E;
			bestx[n] = ch;			
		}
		return;
	}
	//非叶节点
	QNode<Type> *b;
	b = new QNode<Type>;
	b->weight = wt;
	b->parent = E;
	b->LChild = ch;
	Q.Add(b);
}
 
template<class Type>
Type MaxLoading(Type w[],Type c,int n,int bestx[])
{//队列式分支限界法，返回最优装载重量，bestx返回最优解
 //初始化
	Queue<QNode<Type>*> Q;		//活节点队列
	Q.Add(0);					//同层节点尾部标识
	int i = 1;					//当前扩展节点所处的层
	Type Ew = 0,				//扩展节点所相应的载重量
		 bestw = 0,				//当前最优装载重量
		 r = 0;					//剩余集装箱重量
 
	for(int j=2; j<=n; j++)
	{
		r += w[j];
	}
	
	QNode<Type> *E = 0,			//当前扩展节点
				*bestE;			//当前最优扩展节点
 
	//搜索子集空间树
	while(true)
	{
		//检查左儿子节点
		Type wt = Ew + w[i];
		if(wt <= c)//可行节点
		{
			if(wt>bestw)
			{
				bestw = wt;
			}
			EnQueue(Q,wt,i,n,bestw,E,bestE,bestx,true);
		}
 
		//检查右儿子节点
		if(Ew+r>bestw)
		{
			EnQueue(Q,Ew,i,n,bestw,E,bestE,bestx,false);
		}
		Q.Delete(E);//取下一扩展节点
 
		if(!E)//同层节点尾部
		{
			if(Q.IsEmpty())
			{
				break;
			}
			Q.Add(0);       //同层节点尾部标识
			Q.Delete(E);	//取下一扩展节点
			i++;			//进入下一层
			r-=w[i];		//剩余集装箱重量
		}
		Ew  =E->weight;		//新扩展节点所对应的载重量
	}
 
	//构造当前最优解
	for(int j=n-1; j>0; j--)
	{
		bestx[j] = bestE->LChild;
		bestE = bestE->parent;
	}
	return bestw;
}
```"
14,4876,计算机算法设计与分析：分支限界法,gcm6yk8f59zo,装载问题 (最优队列法),15143,"```cpp
//装载问题 优先队列式分支限界法求解 
#include ""MaxHeap.h""

 
int N;
 
class bbnode;
 
template<class Type>
class HeapNode
{

	public:
		operator Type() const{return uweight;}
		bbnode *ptr;		//指向活节点在子集树中相应节点的指针
		Type uweight;		//活节点优先级(上界)
		int level;			//活节点在子集树中所处的层序号
};
 
class bbnode
{
	template<class Type>
	friend void AddLiveNode(MaxHeap<HeapNode<Type>>& H,bbnode *E,Type wt,bool ch,int lev);
	template<class Type>
	friend Type MaxLoading(Type w[],Type c,int n,int bestx[]);
	friend class AdjacencyGraph;
 
	private:
		bbnode *parent;		//指向父节点的指针
		bool LChild;		//左儿子节点标识
};
 
template<class Type>
void AddLiveNode(MaxHeap<HeapNode<Type>>& H,bbnode *E,Type wt,bool ch,int lev);
 
template<class Type>
Type MaxLoading(Type w[],Type c,int n,int bestx[]);
 
 
int main()
{
	float c = 0;  
    float w[100] = {0};//下标从1开始  
    int x[100];  
	float bestw;
	
	cin>>N;
	cin >>c;
	for(int i=1; i<=N; i++)  
    {  
        cin>>w[i];  
    }  
    cout<<""Ship load:""<<c<<endl;  
    cout<<""The weight of the goods to be loaded is:""<<endl;  
    for(int i=1; i<=N; i++)  
    {  
        cout<<w[i]<<"" "";  
    }  
    cout<<endl;  
	
    bestw = MaxLoading(w,c,N,x);  
  
    cout<<""Result:""<<endl; 
    for(int i=1; i<=N; i++)  
    {  
        cout<<x[i]<<"" "";  
    }  
    cout<<endl;  
	cout<<""The optimal loading weight is:""<<bestw<<endl;
  
    return 0; 
}
 
//将活节点加入到表示活节点优先队列的最大堆H中
template<class Type>
void AddLiveNode(MaxHeap<HeapNode<Type>>& H,bbnode *E,Type wt,bool ch,int lev)
{
	bbnode *b = new bbnode;
	b->parent = E;
	b->LChild = ch;
	HeapNode<Type> N;
 
	N.uweight = wt;
	N.level = lev;
	N.ptr = b;
	H.Insert(N);
}
 
//优先队列式分支限界法，返回最优载重量，bestx返回最优解
template<class Type>
Type MaxLoading(Type w[],Type c,int n,int bestx[])
{
	//定义最大的容量为1000
	MaxHeap<HeapNode<Type>> H(1000);
 
	//定义剩余容量数组
	Type *r = new Type[n+1];
	r[n] = 0;
 
	for(int j=n-1; j>0; j--)
	{
		r[j] = r[j+1] + w[j+1];
	}
 
	//初始化
	int i = 1;//当前扩展节点所处的层
	bbnode *E = 0;//当前扩展节点
	Type Ew = 0; //扩展节点所相应的载重量
 
	//搜索子集空间树
	while(i!=n+1)//非叶子节点
	{
		//检查当前扩展节点的儿子节点
		if(Ew+w[i]<=c)
		{
			AddLiveNode(H,E,Ew+w[i]+r[i],true,i+1);
		}
		//右儿子节点
		AddLiveNode(H,E,Ew+r[i],false,i+1);
 
		//取下一扩展节点
		HeapNode<Type> N;
		H.DeleteMax(N);//非空
		i = N.level;
		E = N.ptr;
		Ew = N.uweight - r[i-1];
	}
 
	//构造当前最优解
	for(int j=n; j>0; j--)
	{
		bestx[j] = E->LChild;
		E = E->parent;
	}
 
	return Ew;
}

```"
15,4235,离散事件系统仿真-三段扫描法,jxob72fc5ap3,离散事件仿真原理-三段扫描法,12606,"```
#include <stdarg.h>
#include ""vector""
#include ""queue""
#include <iostream>
#include <math.h>
#include ""EventList.h""
#include <iomanip>
using namespace std;

int uniform_discrete(const int valuelist[], const float problist[], const int count);//离散均匀分布

//事件类型声明
#define ENDLOADING	1	//装载完成事件
#define ENDWEIGHING	2	//称重完成事件
#define ENDTRAVEL	3	//转运完成事件
#define ENDSIM		4	//结束仿真事件

//实体：Truck
struct Truck 
{
	int TruckID;//卡车ID
	/**********  Begin  **********/
	//定义到达时间属性
	double ArrivalTime;
	Truck(int ID)
	{
		TruckID = ID;
		//初始化到达时间属性的值为0
		ArrivalTime = 0;
	}
	/**********  End  **********/
};

//卡车活动结束事件的处理需要事件所属的卡车和活动开始时间
class TruckEvent : public EventNotice
{
public:
	Truck* m_pTruck;//事件相关的Truck
	TruckEvent(int type,double time,Truck* pTruck)
		: EventNotice(type,time)
	{
		m_pTruck = pTruck;
	}
};

//输入
const int		LoadingTime[3]		= {5,10,15};
const float		LoadingTimeProb[3]	= {0.3f,0.5f,0.2f};
const int		WeighingTime[2]		= {12,16};
const float		WeighingTimeProb[2]	= {0.7f,0.3f};
const int		TravelTime[4]		= {40,60,80,100};
const float		TravelTimeProb[4]	= {0.4f,0.3f,0.2f,0.1f};
const double	StopSimulationTime	= 480;

//统计量
int TotalServedCount = 0;//总服务卡车的数量
double TotalResponseTime = 0;//总响应时间长度
int TotalServedCountOver30 = 0;//响应时间超过30分钟的数量

double	Clock;//仿真时钟
EventList FutureEventList;//未来事件表

//实体集合
queue<Truck*> LoaderQueue;	//正在排队装载的卡车，按到达时间排序
queue<Truck*> ScaleQueue;	//正在排队称重的卡车，按到达时间排序

//状态变量
int Lt;	//正在装载的卡车数量 0,1,2
int Wt; //正在称重的卡车数量 0,1

/*
	开始装载(C例程)
*/
bool BeginLoadRoutine() 
{
	if (LoaderQueue.size()>0 && Lt < 2)
	{
		//队首Truck
		Truck* LoaderTruck = LoaderQueue.front(); LoaderQueue.pop();
		//占用一个Loader
		Lt++;
		//调度其结束装载事件
		const double LoadTime = uniform_discrete(LoadingTime,LoadingTimeProb,3);
		EventNotice* endload = new TruckEvent(ENDLOADING, Clock+LoadTime,LoaderTruck);
		FutureEventList.InsertEvent( endload );
		return true;
	}
	return false;
}

/*
	结束装载(B例程)
*/
void EndLoadRoutine(TruckEvent* pEvent)
{
	//进入称重队列
	ScaleQueue.push(pEvent->m_pTruck);
	//释放一个装载车
	Lt--;
}

/*
	开始称重(C例程)
*/
bool BeginWeighRoutine() 
{
	if (ScaleQueue.size()>0 && Wt == 0)
	{
		//占用Scale
		Wt = 1;
		//队首卡车
		Truck* WeighingTruck = ScaleQueue.front(); ScaleQueue.pop();
		//调度其结束称重事件
		const double WeighTime = uniform_discrete(WeighingTime,WeighingTimeProb,2);
		EventNotice* endweigh = new TruckEvent(ENDWEIGHING, Clock+WeighTime,WeighingTruck);
		FutureEventList.InsertEvent( endweigh );
		return true;
	}
	return false;
}

/*
	结束转运(B例程)
*/
void EndTravelRoutine(TruckEvent* pEvent)
{
	/**********  Begin  **********/
	//记录卡车到达时间
	pEvent->m_pTruck->ArrivalTime = Clock;
	/**********  End  **********/
	//卡车进入装载队列
	LoaderQueue.push(pEvent->m_pTruck);
}

/*
	结束称重(B例程)=开始转运
*/
void EndWeighRoutine(TruckEvent* pEvent)
{
	//调度结束转运事件
	const double travelTime = uniform_discrete(TravelTime,TravelTimeProb,4);
	EventNotice* endtravel = new TruckEvent(ENDTRAVEL, Clock+travelTime,pEvent->m_pTruck);
	FutureEventList.InsertEvent( endtravel );
	//称重台空闲
	Wt = 0;
	/**********  Begin  **********/
	//采集有关统计量
	double ResponseTime = Clock - pEvent->m_pTruck->ArrivalTime;
    TotalResponseTime += ResponseTime;
    if (ResponseTime>30)
    {
        TotalServedCountOver30++;
    }
    TotalServedCount++;
	/**********  End  **********/
}

void PrintReport() {
	const double AvgStayTime = TotalResponseTime/TotalServedCount;//平均响应时间
	cout <<Clock <<  "":"" << TotalServedCount<< "",""<< TotalServedCountOver30 << "","" << fixed << setprecision(2) <<AvgStayTime;
}

void Initialization(double SimStopTime)   
{ 
	//第1辆卡车
	Truck* truck1 = new Truck(1);
	EventNotice* evt = new TruckEvent(ENDWEIGHING, Clock+uniform_discrete( WeighingTime,WeighingTimeProb,2),truck1);
	FutureEventList.InsertEvent( evt );
	//称重台占用
	Wt = 1;
	//第2辆卡车
	Truck* truck2 = new Truck(2);
	evt = new TruckEvent(ENDLOADING, Clock+uniform_discrete( LoadingTime,LoadingTimeProb,3),truck2);
	FutureEventList.InsertEvent( evt );
	//第3辆卡车
	Truck* truck3 = new Truck(3);
	evt = new TruckEvent(ENDLOADING, Clock+uniform_discrete( LoadingTime,LoadingTimeProb,3),truck3);
	FutureEventList.InsertEvent( evt );
	//装载车占用
	Lt = 2;
	//第4,5,6辆卡车
	LoaderQueue.push(new Truck(4));
	LoaderQueue.push(new Truck(5));
	LoaderQueue.push(new Truck(6));
	/**********  Begin  **********/
	//在给定仿真时刻SimStopTime调度仿真结束事件ENDSIM
	evt = new EventNotice(ENDSIM, SimStopTime);
    FutureEventList.InsertEvent( evt );
	/**********  End  **********/
}

int _main(double SimStopTime)
{
	Initialization(SimStopTime);
	bool bSimStoped = false;
	while( !bSimStoped ) 
	{
		//Phase A: 推进仿真时钟
		vector<EventNotice*> CEL = FutureEventList.PopImminentEventListTypeAscend(); assert(CEL.size()>0);
		Clock = CEL[0]->GetTime();
		//Phase B: B例程执行
		for (unsigned i=0;i<CEL.size();i++)
		{
			TruckEvent* pEvent = (TruckEvent*)CEL[i];
			switch(pEvent->GetType())
			{
			case ENDWEIGHING: EndWeighRoutine(pEvent); break;
			case ENDLOADING: EndLoadRoutine(pEvent); break;
			case ENDTRAVEL: EndTravelRoutine(pEvent); break;
			case ENDSIM: bSimStoped = true; break;			
			}
			//删除事件
			delete pEvent;
		}
		/**********  Begin  **********/
		//Phase C: C例程扫描执行
		bool bRoutineExecuted = true;
        while(bRoutineExecuted)
        {
            bRoutineExecuted = false;
            if (BeginLoadRoutine()) bRoutineExecuted = true;
            if (BeginWeighRoutine()) bRoutineExecuted = true;
        }
		/**********  End  **********/
	}
	PrintReport();
	return 0;
}
```"
16,4181,贪心算法与动态规划-第十周,cful4efzsym7,贪心算法与实现（P188，习题4）,,
17,4181,贪心算法与动态规划-第十周,a49not5rk27p,动态规划与实现（P215，习题6）,,
18,4181,贪心算法与动态规划-第十周,maixuf852vbe,最长回文子序列,,
19,2193,随机数与随机变量生成,l6b4i9hx8vza,检验线性同余法随机数生成器的周期,12082,"```
unsigned ComputeLCMPeriod(unsigned a, unsigned c, unsigned m)
	{
		if (m < 10) return 0;//要求m>=0

		const unsigned x0 = m / 10;//默认选取m / 10作为种子。
		unsigned x = x0;
		unsigned p = 0;
		while (true)
		{
			x = (a * x + c) % m;
			p++;
			if (x == x0)
			{
				break;
			}
		}

		return p;//exception
	}
	```"
20,2193,随机数与随机变量生成,8jp3nmth7fga,设计威布尔分布随机变量生成器,,
21,4173,离散事件仿真原理-事件调度法,8m2bku53jstf,事件调度法使用条件事件子程序,12090,"```
#include <stdarg.h>
#include <vector>
#include <queue>
#include <iostream>
using namespace std;

#include ""EventList.h""

void Print(const char* strFormat,...);//同时打印到控制台和文件的函数，语法格式同printf函数
int uniform_discrete(const int valuelist[], const float problist[], const int count);//离散均匀分布


//事件类型声明
#define ABLECOMPLETE	1	//Able服务完成事件
#define BAKERCOMPLETE	2	//Baker服务完成事件
#define ARRIVAL			3	//Caller到达事件

//输入
const int		ArrivalInterval[]		= {1,2,3,4};
const float		ArrivalIntervalProb[]	= {0.25,0.40,0.20,0.15};
const int		AbleServiceTime[]		= {2,3,4,5};
const float		AbleServiceTimeProb[]	= {0.30,0.28,0.25,0.17};
const int		BakerServiceTime[]		= {3,4,5,6};
const float		BakerServiceTimeProb[]	= {0.35,0.25,0.20,0.20};

//统计量
double	TotalCallerDelay		= 0; //Caller总等待
double	TotalTimeInSystem		= 0; //Caller在系统中的总停留时间
int		TotalCallerEntered		= 0; //已经进入系统的Caller数
int		TotalCallerDeparted		= 0; //已经完成服务离开的Caller数
int		LongServiceCount		= 0; //等待时间超过4分钟的顾客数
int		MaxQueueLength			= 0; //最大队长（不算在服务的）

//仿真时钟
double	Clock = 0;

//未来事件表
EventList FutureEventList;

//实体：Caller，仅考察到达时间属性
struct Caller
{
	int CallerID;//属性：Caller ID
	float ArrivalTime;//属性：到达时间
};

//实体集合
queue<Caller*> CallerQueue;//正在排队的Caller队列，按到达时间排序

//状态变量
Caller*	AbleCaller = NULL;	//Able是否正在服务: NULL表示空闲，即LS_A(t)==0，否则指向正在服务的Caller实体指针
Caller* BakerCaller = NULL;	//Baker是否正在服务:NULL表示空闲，即LS_B(t)==0，否则指向正在服务的Caller实体指针



//AbleBegin条件事件历程
void AbleBeginRoutine()
{
    /***********Begin************/
    if (AbleCaller == NULL && CallerQueue.size() > 0)
    {
        //更新当前接受服务的Call
        AbleCaller = CallerQueue.front(); CallerQueue.pop();
        //计算其服务时间
        const int ServiceTime = uniform_discrete(AbleServiceTime, AbleServiceTimeProb, 4);
        //调度其服务完成事件
        EventNotice* depart = new EventNotice(ABLECOMPLETE, Clock + ServiceTime);
        FutureEventList.InsertEvent(depart);
    }
    /***********End************/
}
//BakerBegin条件事件历程
void BakerBeginRoutine()
{
    /***********Begin************/
    if (BakerCaller == NULL && AbleCaller != NULL && CallerQueue.size() > 0)
    {
        //更新当前接受服务的Call
        BakerCaller = CallerQueue.front(); CallerQueue.pop();
        //计算其服务时间
        const int ServiceTime = uniform_discrete(BakerServiceTime, BakerServiceTimeProb, 4);
        //调度其服务完成事件
        EventNotice* depart = new EventNotice(BAKERCOMPLETE, Clock + ServiceTime);
        FutureEventList.InsertEvent(depart);
    }
    /***********End************/
}



//Caller到达事件例程
void CallerArrivalRoutine(EventNotice* pCurrentEvent) 
{
	//首先创建Caller自己
	Caller* CurrentCaller = new Caller();
	CurrentCaller->CallerID = ++TotalCallerEntered;
	CurrentCaller->ArrivalTime = Clock;

	//其次调度下一Caller的到达事件
	const int NextArrivalInterval = uniform_discrete(ArrivalInterval,ArrivalIntervalProb,4);
	EventNotice* next_arrival = new EventNotice(ARRIVAL, Clock + NextArrivalInterval);
	FutureEventList.InsertEvent( next_arrival );

	CallerQueue.push(CurrentCaller);

    AbleBeginRoutine();
    BakerBeginRoutine();
}

//Able完成服务例程
void AbleCompleteRoutine(EventNotice* pCurrentEvent) 
{
	//离开时刻数据采集
	const double TimeInSystem = Clock - AbleCaller->ArrivalTime;//Caller的停留时间
	if (TimeInSystem>4) LongServiceCount++; //长时顾客
	TotalTimeInSystem += TimeInSystem;//更新总停留时间
	TotalCallerDeparted++;//离开Caller数增加

	//顾客离开系统
	delete AbleCaller;
	
    //置Able空闲
	AbleCaller = NULL;
    
    //扫描Able开始事件
    AbleBeginRoutine();
}

//Baker完成服务例程
void BakerCompleteRoutine(EventNotice* pCurrentEvent) 
{
	//离开时刻数据采集
	const double TimeInSystem = Clock - BakerCaller->ArrivalTime;//Caller的停留时间
	if (TimeInSystem>4) LongServiceCount++; //长时顾客
	TotalTimeInSystem += TimeInSystem;//更新总停留时间
	TotalCallerDeparted++;//离开Caller数增加

	//顾客离开系统
	delete BakerCaller; 
    
    //置Baker空闲
    BakerCaller = NULL;

	//扫描Baker开始服务事件
    BakerBeginRoutine();
}

//这里如果要算Able的利用率，有两个办法：
//办法1：每个顾客记一下开始服务时间
//办法2：记录Able的最近一次开始服务时间
void PrintReport() {
	const double AVGR  = TotalTimeInSystem/TotalCallerDeparted;
	const double PC4   = ((double)LongServiceCount)/TotalCallerDeparted;

	cout << Clock << "","" << TotalCallerDeparted << "","" << MaxQueueLength << "","" << PC4 << endl;
}

void Initialization()   
{
	//第一个Caller到达事件
	EventNotice* evt = new EventNotice(ARRIVAL, Clock+uniform_discrete( ArrivalInterval,ArrivalIntervalProb,4));
	FutureEventList.InsertEvent( evt );
}


void CollectStatistics()
{
	if (CallerQueue.size()>MaxQueueLength)
	{
		MaxQueueLength = CallerQueue.size();
	}
}

int _main(int nTotalDeparted)
{
	Initialization();
	while(TotalCallerDeparted < nTotalDeparted)
	{
		//Step1: 从FEL中移出imminent事件通知
		vector<EventNotice*> CEL = FutureEventList.PopImminentEventListTypeAscend(); assert(CEL.size()>0);

		//Step2: 将CLOCK推进至该事件的时间
		Clock = CEL[0]->GetTime();

		//Step3: 执行该事件，更新Snapshot表
		//Step4: 如果必要，调度新的未来事件
		for (unsigned i=0;i<CEL.size();i++)
		{
			EventNotice* pEvent = CEL[i];
			switch(pEvent->GetType())
			{
			case ARRIVAL: 
				CallerArrivalRoutine(pEvent);
				break;
			case ABLECOMPLETE: 
				AbleCompleteRoutine(pEvent);
				break;
			case BAKERCOMPLETE: 
				BakerCompleteRoutine(pEvent);
				break;	
			}

			//删除事件
			delete pEvent;
		}

		//Step5: 更新统计量
		CollectStatistics();
	}
	PrintReport();

	system(""pause"");
	return 0;
}



#include <math.h>

//线性同余法随机数生成器
class LCM
{
protected:
	int a, c, x;//参数
	int m;//周期
public:
	LCM(int _a, int _c, int _x0)//构造函数初始化参数值
	{
		a = _a; c = _c; x = _x0;
		m = (int)pow(2.0, 31);//周期为2^31
	}
	double rand()//获取下一个随机数
	{
		x = (a*x + c) % m;
		return 1.0*x / m;
	}
};

/*
离散均匀分布
e.g.:
int	ArrivalInterval[]			= {1,2,3,4};
double ArrivalIntervalProb[]	= {0.25,0.40,0.20,0.15};
uniform_discrete(ArrivalInterval,ArrivalIntervalProb);
*/

LCM myLcm(5, 3, 4245);
int uniform_discrete(const int valuelist[], const float problist[], const int count)
{
	assert(count > 1 && count < 100);

	float cdflist[100];
	cdflist[0] = problist[0];
	for (int i = 1; i<count; i++)
	{
		cdflist[i] = cdflist[i - 1] + problist[i];
	}
	assert(cdflist[count - 1] == 1);

	double u = myLcm.rand();
	for (int i = 0; i<count; i++)
	{
		if (u <= cdflist[i])
		{
			return valuelist[i];
		}
	}

	assert(0);
	return valuelist[count - 1];
}

```"
22,4130,向量的使用及哈夫曼编码,5bircfujasg6,字母统计及哈夫曼编码,,
23,4130,向量的使用及哈夫曼编码,bjp7rytgfex9,排序及哈夫曼编码2,,
24,3911,第四章 循环结构程序设计（一）,mbpffhqil6zx,求平均成绩,11850,"```c
#include <iostream>
#define N 10
/********** Begin *********/
      // 请在此添加代码
      //为实现保留1位小数输出的功能，需要添加头文件
#include <iomanip>
/********** End *********/ 
using namespace std;

int main()
{
    
    int x,s=0,i;
    /********** Begin *********/
      // 请在此添加代码
      //实现保留1位小数输出的功能
   cout<<setiosflags(ios::fixed)<<setprecision(1);     
   /********** End *********/ 
    for(i=1;i<=N;i++) //循环执行N次
   { 
      /********** Begin *********/
      // 请在此添加代码
      // 输入学生某门课程的成绩x
      // 将成绩x累加到s
    cin>>x;
	s=s+x;
     /********** End *********/ 
    }
   cout<<1.0*s/N<<""\n"";//求平均值并输出
   
    return 0;
}

```"
25,3911,第四章 循环结构程序设计（一）,elxn3tqar5is,特殊值控制循环,11851,"```c
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
    int x,s=0,n=0;

    while(1)
    {
	  /********** Begin *********/
      // 请在此添加代码
      // 输入学生某门课程的成绩x
      //如输入为特殊值（本程序设定为-1）则退出循环
      // 将成绩x累加到s
      cin>>x;
	  if(x!=-1)
	  s=s+x;
      else
          break;
      /********** End *********/ 
	  n++;
      }
   cout<<setiosflags(ios::fixed)<<setprecision(1);
   cout<<""所有学生平均成绩为：""<<1.0*s/n<<""\n"";//求平均值并输出   

    return 0;
}
```"
26,3911,第四章 循环结构程序设计（一）,irbxvo84e6ka,输出所有的数字字符,11822,"```cpp
#include <iostream>
using namespace std;
// 定义main函数
int main()
{
   char i;  
    i='0';
    /********** Begin *********/
while(i<='9')
{ 
cout<<i<<"" "";
  i++;
}
    /********** End *********/
    cout<<endl;
    return 0;
}
```"
27,3911,第四章 循环结构程序设计（一）,s7erlkhg4tov,输入一行以问号结束的字符，统计字母的个数,11296,"```c
#include <iostream>
using namespace std;
int main()
{
   char c;
   int x=0;
   cin>>c;
   /********** Begin *********/
 
	while(c!='?')
{ 
if(c>='a'&&c<='z'|| c>='A'&&c<='Z')  x++;
cin>>c;
}

    /********** End *********/ 
   cout<<""输入的字母的个数有""<<x<<""个\n"";   
 
    return 0;
}
```"
28,3911,第四章 循环结构程序设计（一）,q7o2s4vz9pc8,求1到100的自然数和,11825,"```c
#include <iostream>
using namespace std;
int main( )
{ 
int i=1,sum=0;
do 
  {
      /********** Begin *********/
      // 请在此添加代码，实现累加功能
sum=sum+i;
i++;
     /********** End *********/
     }
while(i<=100);
cout<<sum<<""\n"";
return 0; 
}
```"
29,3911,第四章 循环结构程序设计（一）,9srzfct74elv,求1/2+2/3+3/4+ … +9/10,11827,"```c
#include <iostream>
#include <iomanip>
using namespace std;
int main( )
{ 
float f1,s=0;
     /********** Begin *********/
      // 请在此添加代码，补充for语句，并设定保留2位小数输出
	for(f1=1;f1<=9;f1++) 
	s=s+f1/(f1+1);  
	cout<<setiosflags(ios::fixed)<<setprecision(2);
     /********** End *********/ 
cout<<s<<""\n"";
return 0; 
}
```"
30,3911,第四章 循环结构程序设计（一）,79v3waky2xcp,输出半径从1到10且周长小于40的圆的面积,11829,"```
#include <iostream>
#include <iomanip>
#define PI 3.14
using namespace std;


int main()
{  int r;
   float area, c;
   for(r=1;r<=10;r++)
    { 
     /********** Begin *********/
      // 请在此添加代码，计算圆的周长和面积，并判断圆的周长，如果周长大于40，就跳出循环
      //设定要求，保留2位小数输出
    c=2*PI*r;
	if(c>=40) break; 
    area=PI*r*r;
    cout<<setiosflags(ios::fixed)<<setprecision(2);
     /********** End *********/
      cout<<""r=""<<r<<"",c=""<<c<<"",area=""<<area<<""\n"";
      }
 
    return 0;
}
```"
31,3911,第四章 循环结构程序设计（一）,hpagtf3if8wy,输出九九乘法表,11830,"```c
#include <iostream>
#include <iomanip>
using namespace std;


int main()
{  int i,j;
   for(i=1;i<=9;i++) 
   { 
     /********** Begin *********/
      // 请在此添加代码，实现打印九九乘法表的功能
      // 要求输出的i*j的结果占两列宽度，i*j的结果之后空两格
      for(j=1;j<=i;j++)
	  cout<<i<<""*""<<j<<""=""<<setw(2)<<i*j<<""  "";
	  cout<<""\n"";
     /********** End *********/ 
    }
 
    return 0;
}
```"
32,3911,第四章 循环结构程序设计（一）,ub6ohwv9lmey,计算10-20 间每个数的所有因子（包括1和它本身）之和,11832,"```c
#include <iostream>
using namespace std;


int main()
{  int x,j,s;
   for(x=10;x<=20;x++) 
   { 
     /********** Begin *********/
      // 请在此添加代码，完成内层循环，找出每个数的因子，并实现累加和
      // 输出数字x和对应的累加和
      s=1+x;
	  for(j=2;j<=x/2;j++) 
      if(x%j==0)  s+=j;
      cout<<x<<"": ""<<s<<""\n"";
     /********** End *********/ 
    }
 
    return 0;
}
```"
33,3911,第四章 循环结构程序设计（一）,uyf53epirnzt,图形界面,11852,"```c
#include <iostream>
#include <iomanip>
using namespace std;


int main()
{  int i,j;
   for(i=1;i<=4;i++) 
     /********** Begin *********/
      // 请在此添加代码，用for语句实现内循环，输出`*`
      // 要求输出的`*`之后跟一个空格
      {
	 for(j=1;j<=i;j++)  
         cout<<""* "";
     cout<<""\n"";
	 }
     /********** End *********/ 
	
    return 0;
}
```"
34,3911,第四章 循环结构程序设计（一）,n69cz37kyq5i,判断n是否是素数,11834,"```c
#include <iostream>
#include <cmath>
using namespace std;

// 定义main函数
int main()
{
  	int n,i,k;
cin>>n;
    /********** Begin *********/
      // 请在此添加代码，判断`n`是否是素数
      k=sqrt(n);
      for(i=2;i<=k;i++)
      if(n%i==0) break;
     /********** End *********/
if(i>k) cout<<n<<"" is a prime number\n"";
else   cout<<n<<"" is not a prime number\n"";
 return 0;
}
```"
35,3911,第四章 循环结构程序设计（一）,8latf5hsvepq,输出100到200之间的所有素数,11844,"```c
#include <iostream>
#include  <iomanip>
#include <cmath>
using namespace std;

// 定义main函数
int main()
{int n,i,k,count=0;
for(n=101;n<200;n+=2)
{ 
k=sqrt(n);
     /********** Begin *********/
      // 请在此添加代码，判断数字`n`是否是素数
      // 如果不是素数，就跳出内循环；如果是素数，就进行输出,并且count加1
      // 每个素数站列宽为`5`
      for(i=2;i<=k;i++)
      if(n%i==0) break;
      if(i>k) 
      { 
      cout<<setw(5)<<n;
      count++;
      }
     /********** End *********/
if(count%10==0) cout<<""\n"";
}
 return 0;
}
```"
36,3911,第四章 循环结构程序设计（一）,bju7tf546mas, 统计一个整数的位数，并按逆序输出该数的所有位数,11847,"```c
#include <iostream>
#include  <iomanip>

using namespace std;

// 定义main函数
int main()
{long n; 
int count = 0;

cin>>n ;
if (n < 0)   n = -n; 
      /********** Begin *********/
      // 请在此添加代码，判断`n`是否是零，是零的话，跳出循环，否则进入循环
      // 从低位到高位依次输出数字，`n`变为`n/10`，`count`加`1`
      while (n != 0)
      {   
      cout<<setw(3)<<n%10;
      n = n / 10;         
      count ++;    
      }
     /********** End *********/
cout<<"" \nIt contains""<< count<<"" digits.\n"" ;
 return 0;
}
```"
37,3911,第四章 循环结构程序设计（一）,k2lcgnf47fye,输出数列,11848,"```c
#include <iostream>
using namespace std;

// 定义main函数
int main()
{int a1=1,a2=3,an,i;
cout<<a1<<""  ""<<a2<<""  "";
     /********** Begin *********/
      // 请在此添加代码，用for语句输出剩下的八个数，要求每个数输出后空两格
      // 循环体内完成数列通项公式的定义，以及a1、a2的重新赋值
      for(i=3;i<=10;i++)
     { 
     an=2*a1+a2;
     a1=a2;
     a2=an;
     cout<<an<<""  "";
     }
     /********** End *********/
cout<<""\n"";
return 0;
}
```"
38,3911,第四章 循环结构程序设计（一）,8hr97osmffi3,求1！+2！+3！+ … +10！,11849,"```c
#include <iostream>
using namespace std;

// 定义main函数
int main()
{int i;    
long t=1,s=1;
     /********** Begin *********/
      // 请在此添加代码，用`for`循环依次产生从`2`到`10`的阶乘，赋值给`t`
      // 用`s`实现阶乘的累加和
      for(i=2;i<=10;i++)
	 {
	 t=t*i;
	 s=s+t;
	 }
     /********** End *********/
cout<<s<<""\n"";
return 0; 
}
```"
39,3868,有信息搜索策略(启发式搜索),wli5v2gjo4bn,启发式搜索算法,11321,"```
using namespace std;
struct Node{
	int state[9];
	struct Node* parent;
	int value;
	int depth;
	friend bool operator < (Node A, Node B) //按照value值小的方案构造优先级队列
	{
		return A.value > B.value;
	}
};

priority_queue<Node> openTable;     //open表
queue<Node> closeTable;     //close表
stack<Node> Path;     //最终路径
int count1=0,count2=0;

int  read(Node& S,Node& G){
	/*初始化*/
	S.parent=NULL;	S.depth=0;	S.value=0;
	G.parent=NULL;	G.depth=0;	G.value=0;
	int a[]={1,2,3,4,5,6,7,0,8}; 
	int b[]={1,0,2,4,6,3,7,5,8};
	 //cout<<""Please enter the initial state\n"";
	 for(int i=0;i<num;i++)
		S.state[i]=a[i]; //cin>>S.state[i];
	 //cout<<""Please enter the target status\n"";
	  for(int i=0;i<num;i++)
		 G.state[i]=b[i];//cin>>G.state[i];

	  for(int i=0;i<=num-2;i++)
		  for(int j=i+1;j<num;j++)
			if(S.state[i]>S.state[j]&&S.state[i]*S.state[j]!=0)
				count1++;

	   for(int i=0;i<=num-2;i++)
		  for(int j=i+1;j<num;j++)
			if(G.state[i]>G.state[j]&&G.state[i]*G.state[j]!=0)
				count2++;

	   if(count1%2!=count2%2)
	   {
		   return 0;
	   }
		   return 1;
}

int value1(Node A,Node G){
	int count=8;
	
	for(int i=0;i<num;i++)
		if(A.state[i]==G.state[i]&&G.state[i]!=0)
			count--;

	return count +A.depth;

}

int value2(Node A,Node G){
	int count=0,begin[3][3],end[3][3];           //count记录所有棋子移动到正确位置需要的步数
	for(int i = 0; i < num; i++){
		begin[i/3][i%3]=A.state[i];
		end[i/3][i%3]=G.state[i];
	}


	for(int i = 0; i < 3; i++)   //检查当前图形的正确度
		for(int j = 0; j < 3; j++)
		{
			if(begin[i][j] == 0)
				continue;
			else if(begin[i][j] != end[i][j])
			{
				for(int k=0; k<3; k++)
					for(int w=0; w<3; w++)
						if(begin[i][j] == end[k][w])
							count = count + fabs(i-k*1.0) + fabs(j-w*1.0);
			}
		}
	return count +A.depth; 

}



bool judge(Node S, Node G)
{
	for (int i = 0; i <= 8; i++)
	{
		if (S.state[i] != G.state[i])
		{
			return false;
		}
	}
	return true;
}

//产生新节点，加入OPEN表
void creatNode(Node& S, Node G)
{
	/* 计算原状态下,空格所在的行列数，从而判断空格可以往哪个方向移动 */
	int blank; //定义空格下标
	for(blank=0;blank<9&&S.state[blank]!=0;blank++) ;//找到空白格

	int x =blank / 3, y = blank % 3; //获取空格所在行列编号

	for (int d = 0; d < 4; d++) //找到S扩展的子节点，加入open表中
	{   
		int newX=x,newY=y;//新空白格坐标
		Node tempNode;

		/*移动空白格*/
		if(d==0)  newX = x -1;
	    if(d==1)	 newY = y -1;
	    if(d==2)  newX = x +1;
	    if(d==3)	 newY = y +1;

		int newBlank = newX * 3 + newY; //空格新的位置

		/**********Begin**********/
if (newX >= 0 && newX < 3 && newY >= 0 && newY < 3) //如果移动合法
    {
        /* 交换新旧空白格的内容*/
        tempNode = S;
        tempNode.state[blank] = S.state[newBlank];
        tempNode.state[newBlank] =0;
        if ( S.parent!=NULL&&(*S.parent).state[newBlank] == 0) //如果新节点和爷爷节点一样，舍弃该节点
        {
            continue;
        }
        /* 把子节点都加入open表中 */
        tempNode.parent = &S;
        tempNode.value = value2(tempNode, G);
        tempNode.depth = S.depth + 1;
        openTable.push(tempNode);
    }

    	/**********End**********/

	}
}
```"
40,3868,有信息搜索策略(启发式搜索),fxynmcqshjwb,贪婪最佳优先搜索(GBS)——钱币找零问题,11322,"```
using namespace std;
//当前的钱库，面值以及对应数量
int single_money[7] = {1,2,5,10,20,50,100};
int number_money[7] = {2,5,0,3,4,0,4};
//每种面值使用贪心算法后需要使用的张数
int count[7] = {};
int total_count;
int tanxin(int money)
{
	/**********Begin**********/
if (money >= 0)   //考虑一下输入规范的问题
{
    for (int i = 6; i >= 0; i--)
    {
        count[i]=min(number_money[i],money/single_money[i]);
        money = money - count[i]*single_money[i];
    }
    return 0;
}
else
{
    return money;
}

	/**********End**********/
}
```"
41,3868,有信息搜索策略(启发式搜索),8a3jsflu6hx5,贪婪最佳优先搜索(GBS)——西红柿首富的烦恼问题,11323,"```
using namespace std;
int tanxin(int k,int a[],int m){
	int n=0,cnt=0;
	/**********Begin**********/
for(int i=k;i>=1;i--){
    if(m>=a[i]){
        n = m/a[i];
        m = m - n*a[i];
        cnt =cnt+n;
        cout<<""Price of the items is ""<<a[i]<<"": ""<<n<<endl;
        if(m==0)
            break;
    }
}
cout<<""The minimum number of items: ""<<cnt<<endl;

	/**********End**********/
}
```"
42,3868,有信息搜索策略(启发式搜索),42hvjlzo5fb8,贪婪最佳优先搜索(GBS)——西虹市首富的烦恼升级版,11324,"```
using namespace std;
int tanxin(int k,int a[],int b[],int m){
	int n,cnt=0,p;
	/**********Begin**********/
for(int i=k;i>=1;i--){
    if(m>=a[i]){
        n = m/a[i];
        p = min(n,b[i]);
        m = m - p*a[i];
        cnt +=p;
        cout<<""Price of the items is ""<<a[i]<<"": ""<<p<<endl;
        if(m==0)
            break;
    }
}
cout<<""The minimum number of items: ""<<cnt<<endl;

	/**********End**********/
}
```"
43,3868,有信息搜索策略(启发式搜索),ywxjot8lzb54,贪婪最佳优先搜索(GBS)——排队打水最少等待时间问题,11325,"```
using namespace std;
/**
class T
{
public:
    int x,y,z;
    T(int a,int b,int c):x(a),y(b),z(c)
    {
    }
};*/

class T
{
public:
    int x;
    T(int a):x(a)
    {
    }
};
 
bool operator<(const T&t1,const T&t2)
{
    return t1.x>t2.x;    //从小到大出队
}
 
int a[500];
int tanxin(){
	int n,r,i,re;
	priority_queue<T>q;
	while(cin>>n>>r){
     	re=0;
     	cout<<""Enter each person's water time:""<<endl;
     	for(i=0;i<n;i++){
     		cin>>a[i];
		 }
		 sort(a,a+n);
		 for(i=0;i<r;i++){
            q.push(T(a[i]));
		    re+=a[i];
		 }
 		/**********Begin**********/

    for(i=r;i<n;i++){
        T t=q.top();
        int tmp = t.x+a[i];
        re+=tmp;
        q.pop();
        q.push(tmp);
    }
    while(!q.empty()){
        q.pop();
    }

		/**********End**********/
		cout<<""Minimum queuing time: ""<<re<<endl;
	 }
}
```"
44,3868,有信息搜索策略(启发式搜索),thgkjv5fpz2r,A*搜索：搜索最小总评估代价,11326,"```
using namespace std;

const int ROW = 3;
const int COL = 3;
const int MAXDISTANCE = 10000;
const int MAXNUM = 10000;

typedef struct _Node{
	int digit[ROW][COL];
	int dist;   // distance between one state and the destination
	int dep;    // the depth of node
	// So the comment function = dist + dep.
	int index; // point to the location of parent
} Node;

Node src, dest;

vector<Node> node_v;   // store the nodes

bool isEmptyOfOPEN() {
	for (int i = 0; i < node_v.size(); i++) {
		if (node_v[i].dist != MAXNUM)
			return false;
	}
	return true;
}

bool isEqual(int index, int digit[][COL]) {
	for (int i = 0; i < ROW; i++)
		for (int j = 0; j < COL; j++) {
			if (node_v[index].digit[i][j] != digit[i][j])
				return false;
		}
	return true;
}

ostream& operator<<(ostream& os, Node& node) {
	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++)
			os << node.digit[i][j] << ' ';
		os << endl;
	}
	return os;
}

void PrintSteps(int index, vector<Node>& rstep_v) {
	rstep_v.push_back(node_v[index]);
	index = node_v[index].index;
	while (index != 0) {
		rstep_v.push_back(node_v[index]);
		index = node_v[index].index;
	}

	for (int i = rstep_v.size() - 1; i >= 0; i--)
		cout << ""Step "" << rstep_v.size() - i<< endl << rstep_v[i] << endl;
}

void Swap(int& a, int& b) {
	int t;
	t = a;
	a = b;
	b = t;
}

void Assign(Node& node, int index) {
	for (int i = 0; i < ROW; i++)
		for (int j = 0; j < COL; j++)
			node.digit[i][j] = node_v[index].digit[i][j];
}

int GetMinNode() {
	int dist = MAXNUM;
	int loc;   // the location of minimize node
	for (int i = 0; i < node_v.size(); i++) {
		if (node_v[i].dist == MAXNUM)
			continue;
		else if ((node_v[i].dist + node_v[i].dep) < dist) {
			loc = i;
			dist = node_v[i].dist + node_v[i].dep;
		}
	}

	return loc;
}

bool isExpandable(Node& node) {
	for (int i = 0; i < node_v.size(); i++) {
		if (isEqual(i, node.digit))
			return false;
	}
	return true;
}

int Distance(Node& node, int digit[][COL]) {
	int distance = 0;
	bool flag = false;
	for(int i = 0; i < ROW; i++) 
		for (int j = 0; j < COL; j++) 
		/**********Begin**********/
		for (int k = 0; k < ROW; k++) {
            for (int l = 0; l < COL; l++) {
                if (node.digit[i][j] == digit[k][l]) {
                    distance += abs(i - k) + abs(j - l);
                    flag = true;
                    break;
                }
                else 
                    flag = false;
            }
            if (flag)
                break;
        }

		/**********End**********/
	return distance;
}

int MinDistance(int a, int b) {
	return (a < b ? a : b);
}

void ProcessNode(int index) {
	int x, y;
	bool flag;
	for (int i = 0; i < ROW; i++) {
		for (int j = 0; j < COL; j++) {
			if (node_v[index].digit[i][j] == 0) {
				x =i; y = j;
				flag = true;
				break;
			}
			else flag = false;
		}
		if(flag)
			break;
	}

	Node node_up;
	Assign(node_up, index);
	int dist_up = MAXDISTANCE;
	if (x > 0) {
		Swap(node_up.digit[x][y], node_up.digit[x - 1][y]);
		if (isExpandable(node_up)) {
			dist_up = Distance(node_up, dest.digit); 
			node_up.index = index;
			node_up.dist = dist_up;
			node_up.dep = node_v[index].dep + 1;
			node_v.push_back(node_up);
		}
	}

	Node node_down;
	Assign(node_down, index);
	int dist_down = MAXDISTANCE;
	if (x < 2) {
		Swap(node_down.digit[x][y], node_down.digit[x + 1][y]);
		if (isExpandable(node_down)) {
			dist_down = Distance(node_down, dest.digit);
			node_down.index = index;
			node_down.dist = dist_down;
			node_down.dep = node_v[index].dep + 1;
			node_v.push_back(node_down);
		}
	}

	Node node_left;
	Assign(node_left, index);
	int dist_left = MAXDISTANCE;
	if (y > 0) {
		Swap(node_left.digit[x][y], node_left.digit[x][y - 1]);
		if (isExpandable(node_left)) {
			dist_left = Distance(node_left, dest.digit);
			node_left.index = index;
			node_left.dist = dist_left;
			node_left.dep = node_v[index].dep + 1;
			node_v.push_back(node_left);
		}
	}

	Node node_right;
	Assign(node_right, index);
	int dist_right = MAXDISTANCE;
	if (y < 2) {
		Swap(node_right.digit[x][y], node_right.digit[x][y + 1]);
		if (isExpandable(node_right)) {
			dist_right = Distance(node_right, dest.digit);
			node_right.index = index;
			node_right.dist = dist_right;
			node_right.dep = node_v[index].dep + 1;
			node_v.push_back(node_right);
		}
	}

	node_v[index].dist = MAXNUM;
}
```"
45,4041,问题求解与实践-第八周任务 词频统计,a43clszebxgf,文本处理与词频统计,,
46,4041,问题求解与实践-第八周任务 词频统计,afjcygurb5op,代码处理与词频统计,,
47,4067,二叉树应用训练,7lr59wnimo8s,第一关  二叉树创建及遍历,,
48,4067,二叉树应用训练,wexklj5c4qmu,计算二叉树中叶子的个数,,
49,4067,二叉树应用训练,ptc3v94rn2m5,实现二叉树左右子树互换,,
50,4067,二叉树应用训练,qfoawi8xg6lr,计算二叉树中有两个孩子的结点个数,,
51,3913,无信息的搜索策略,nv3moxbwr8yp,宽度优先搜索（BFS）策略,11283,"```
using namespace std;
char vextex[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I' };
typedef struct VertexNode  //链表表头结点
{
    char data;
    struct ArcNode * firstarc;
}VertexNode;

typedef struct ArcNode  //弧结点
{
    char data;
    struct ArcNode * nextarc;
}ArcNode;

ArcNode * InSertArcNode(char name)
{
    ArcNode * p = new ArcNode;
    p->data = name;
    p->nextarc = NULL;
    return p;
}

VertexNode * AdjList()//邻接链表表示法
{
    ArcNode * p=NULL;
    VertexNode * List_head = new VertexNode[9];
    int count = 0;
    List_head[count].data = 'A';
    p = List_head[count].firstarc = InSertArcNode('B');
    p = p->nextarc = InSertArcNode('D');
    p = p->nextarc = InSertArcNode('E');
    count++;
    List_head[count].data = 'B';
    p = List_head[count].firstarc = InSertArcNode('A');
    p = p->nextarc = InSertArcNode('C');
    p = p->nextarc = InSertArcNode('E');
    count++;
    List_head[count].data = 'C';
    p = List_head[count].firstarc = InSertArcNode('B');
    p = p->nextarc = InSertArcNode('F');
    count++;
    List_head[count].data = 'D';
    p = List_head[count].firstarc = InSertArcNode('A');
    p = p->nextarc = InSertArcNode('G');
    count++;
    List_head[count].data = 'E';
    p = List_head[count].firstarc = InSertArcNode('A');
    p = p->nextarc = InSertArcNode('B');
    p = p->nextarc = InSertArcNode('G');
    count++;
    List_head[count].data = 'F';
    p = List_head[count].firstarc = InSertArcNode('C');
    count++;
    List_head[count].data = 'G';
    p = List_head[count].firstarc = InSertArcNode('D');
    p = p->nextarc = InSertArcNode('E');
    p = p->nextarc = InSertArcNode('H');
    count++;
    List_head[count].data = 'H';
    p = List_head[count].firstarc = InSertArcNode('G');
    p = p->nextarc = InSertArcNode('I');
    count++;
    List_head[count].data = 'I';
    p = List_head[count].firstarc = InSertArcNode('H');
    return List_head;
}

void AdjMatrix(char arc[][9])
{
    for (int i = 0; i < 9; i++)   //初始化邻接矩阵
        for (int j = 0; j < 9; j++)
        {
            arc[i][j] = 0;
        }
    arc[0][1] = arc[0][3] = arc[0][4] = 1;
    arc[1][0] = arc[1][2] = arc[1][4] = 1;
    arc[2][1] = arc[2][5] = 1;
    arc[3][0] = arc[3][6] = 1;
    arc[4][0] = arc[4][1] = arc[4][6] = 1;
    arc[5][2] = 1;
    arc[6][3] = arc[6][4] = arc[6][7] = 1;
    arc[7][6] = arc[7][8] = 1;
    arc[8][7] = 1;
}

void BFS_list(VertexNode *GRAPH, int i, bool *visited, queue<char> &Q)
{
    cout << Q.front() << "",""; 
    Q.pop(); //出队列
    /*访问到顶点i的所有邻接点*/
    ArcNode *p = GRAPH[i].firstarc; //第一个邻结点
    /**********Begin**********/
	while ( p!=NULL )  //依次访问顶点i的邻接点
	{
		/*(p->data - 'A')代表顶点的序号*/
		if (*(visited + (p->data - 'A')) == 0)//检测邻接点是否被访问过
		{
			*(visited + (p->data - 'A')) = true;//访问标志置1
			Q.push(p->data); //邻接点加入优先队列
		}
		p = p->nextarc;  
	}
	if (!Q.empty()) //递归遍历队列里的顶点
	{
		BFS_list(GRAPH, Q.front() - 'A', visited, Q);
	}
    /**********End**********/
}

void BFS_AdjList(VertexNode *GRAPH)//广度优先搜索顶点i--邻接表存储
{
    bool visited[9] = { 0 }; //访问标志初始化
    queue<char> Q; //优先队列
   /**********Begin**********/
	for (int i = 0; i < 9; i++)
	{
		if (!visited[i])
		{
			visited[i] = true;  //访问标志置1
			Q.push(vextex[i]);   //进入顶点队列
			BFS_list(GRAPH, i, visited, Q); //广度优先搜索顶点i
		}
	}
    /**********End**********/ 
}

void BFS_KLevel(VertexNode * GRAPH, int i,int k) //计算距离顶点i为k的所有顶点
{
    if (k==0) //如果k=0，输出此顶点
    {
        cout << GRAPH[i].data << endl;
        return;
    }
    queue<char> Q1; //已访问顶点
    queue<unsigned int> Q2; //已访问顶点与顶点i的距离
    bool visited[9] = { 0 };//访问标志
    visited[i] = true;   //顶点i置1
    Q1.push(vextex[i]); //进入队列
    Q2.push(0);  //距离队列
    while (!Q1.empty())
    {
        int index = Q1.front() - 'A';  //顶点的序号
        ArcNode *p = GRAPH[index].firstarc;//第一个邻接点
        int level = Q2.front(); 
        while (p!=NULL)
        {
            if (*(visited+(p->data-'A')) == 0)  //结点没有被访问过
            {
                *(visited + (p->data - 'A')) =true;//访问标志置1
                Q1.push(p->data);  
                Q2.push(level + 1);  //距离+1
                if (level + 1 == k)  //判断距离
                {
                    cout << p->data << "","";
                }
            }
            p = p->nextarc; 
        }
        Q1.pop();
        Q2.pop();
    }
}
```"
52,3913,无信息的搜索策略,vf6wuhm2tirk,深度优先搜索（DFS）策略,11282,"```
using namespace std;
char vextex[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I' };

typedef struct VertexNode  //链表表头结点
{
    char data;
    struct ArcNode * firstarc;
}VertexNode;

typedef struct ArcNode  //弧结点
{
    char data;
    struct ArcNode * nextarc;
}ArcNode;

ArcNode * InSertArcNode(char name)
{
    ArcNode * p = new ArcNode;
    p->data = name;
    p->nextarc = NULL;
    return p;
}

VertexNode * AdjList()//邻接链表表示法
{
    ArcNode * p=NULL;
    VertexNode * List_head = new VertexNode[9];
    int count = 0;
    List_head[count].data = 'A';
    p = List_head[count].firstarc = InSertArcNode('B');
    p = p->nextarc = InSertArcNode('D');
    p = p->nextarc = InSertArcNode('E');
    count++;
    List_head[count].data = 'B';
    p = List_head[count].firstarc = InSertArcNode('A');
    p = p->nextarc = InSertArcNode('C');
    p = p->nextarc = InSertArcNode('E');
    count++;
    List_head[count].data = 'C';
    p = List_head[count].firstarc = InSertArcNode('B');
    p = p->nextarc = InSertArcNode('F');
    count++;
    List_head[count].data = 'D';
    p = List_head[count].firstarc = InSertArcNode('A');
    p = p->nextarc = InSertArcNode('G');
    count++;
    List_head[count].data = 'E';
    p = List_head[count].firstarc = InSertArcNode('A');
    p = p->nextarc = InSertArcNode('B');
    p = p->nextarc = InSertArcNode('G');
    count++;
    List_head[count].data = 'F';
    p = List_head[count].firstarc = InSertArcNode('C');
    count++;
    List_head[count].data = 'G';
    p = List_head[count].firstarc = InSertArcNode('D');
    p = p->nextarc = InSertArcNode('E');
    p = p->nextarc = InSertArcNode('H');
    count++;
    List_head[count].data = 'H';
    p = List_head[count].firstarc = InSertArcNode('G');
    p = p->nextarc = InSertArcNode('I');
    count++;
    List_head[count].data = 'I';
    p = List_head[count].firstarc = InSertArcNode('H');
    return List_head;
}

void AdjMatrix(char arc[][9])
{
    for (int i = 0; i < 9; i++)   //初始化邻接矩阵
        for (int j = 0; j < 9; j++)
        {
            arc[i][j] = 0;
        }
    arc[0][1] = arc[0][3] = arc[0][4] = 1;
    arc[1][0] = arc[1][2] = arc[1][4] = 1;
    arc[2][1] = arc[2][5] = 1;
    arc[3][0] = arc[3][6] = 1;
    arc[4][0] = arc[4][1] = arc[4][6] = 1;
    arc[5][2] = 1;
    arc[6][3] = arc[6][4] = arc[6][7] = 1;
    arc[7][6] = arc[7][8] = 1;
    arc[8][7] = 1;
}

void DFS_matrix(char G[][9],int i,bool *visited)  //深度优先搜索与结点i相通的所有节点
{
    visited[i] = true;  //顶点i被访问，标志置为true
    for (int j = 0; j < 9; j++)
    {
        if (!visited[j] && G[i][j]==1)
        {   
            cout << vextex[j] << "" "";
            DFS_matrix(G, j, visited); //递归
        }
    }
}

void DFS_AdjMatrix(char G[][9])  //深度优先搜索_邻近矩阵存储
{
    bool visited[9] = { 0 };  //初始化访问标志数组
    for (int i = 0; i < 9; i++) //检测是否所有节点都被访问过
    {
        if (!visited[i])//顶点i未被访问过，结点i进行深度优先搜索
        {
            cout << vextex[i]<<"" "";
            DFS_matrix(G, i, visited);//深度优先搜索顶点i
        }
    }
}

void DFS_list(VertexNode * GRAPH, int i, bool *visited)
{
    visited[i] = true;  //顶点i被访问，标志置为true
    cout << vextex[i] << "" "";
    ArcNode * p = GRAPH[i].firstarc; //找到第一个邻接链表结点
    /**********Begin**********/
	while (p!=NULL)
	{
		int temp = p->data - 'A'; //计算节点的位置
		if (!visited[temp]) //检测邻接顶点是否被访问过
			DFS_list(GRAPH, temp, visited); //深度优先搜索结点temp
		p = p->nextarc;//回溯到下一个邻接顶点
	}
    /**********End**********/
}
void DFS_AdjList(VertexNode * GRAPH)  //深度优先搜索--邻接链表存储
{
    bool visited[9] = { 0 }; //初始化访问标志数组
    /**********Begin**********/
	for (int i = 0; i < 9; i++)//检测是否所有节点都被访问过
	{
		if (!visited[i])
		{
			DFS_list(GRAPH, i, visited);//深度优先搜索顶点i
		}
	}
    /**********End**********/
}

```"
53,3923,局部搜索算法（八皇后问题）,c9js6buf3pea,爬山法,11243,"```
using namespace::std;

/* Use Hill-Climbing, Simulated-Annealing and Genetic-Algorithm to solve 8-Queens problem */
int SHC_success_total_steps = 0;	// 最陡上升爬山法成功总步数
int SHC_failed_total_steps = 0;		// 最陡上升爬山法失败总步数
int FCHC_success_total_steps = 0;	// 首选爬山法成功总步数
int FCHC_failed_total_steps = 0;	// 首选爬山法失败总步数
int RRSHC_success_total_steps = 0;	// 随机重启爬山法成功总步数
int RRSHC_failed_total_steps = 0;	// 随机重启爬山法失败总步数
int SA_success_total_steps = 0;		// 模拟退火成功总步数
int SA_failed_total_steps = 0;		// 模拟退火失败总步数
int generation = 0;					// 遗传算法成功所需总代数

class Board {
public:
	void fill_in_board() {
		initial();
		for (int i = 0; i < 8; ++i) {
			board[state[i]][i] = true;
		}
	}

	void initial() {
		for (int i = 0; i < 8; ++i) {
			for (int j = 0; j < 8; ++j) {
				board[i][j] = false;
			}
		}
	}

	void random_initial_state() {
		for (int i = 0; i < 8; ++i) {
			state[i] = rand() % 8;
		}
	}

	void display(int mode) {
		cout << endl << ""-------------------------------------"" << endl;
		cout << ""State: "" << get_state() << endl
			<< ""h: "" << (mode == 0 ? h_of_attack_pair() : h_of_not_attack_pair()) << endl
			<< ""Find Solution: "" << (check(mode) ? ""Success!!!"" : ""Failed..."") << endl
			<< ""Board: "" << endl;
		for (int i = 0; i < 8; ++i) {
			for (int j = 0; j < 8; ++j) {
				cout << board[i][j] << "" "";
			}
			cout << endl;
		}
		cout << endl << ""-------------------------------------"" << endl;
	}

	void display_h_value_on_board() {
		cout << ""H_Value On Board: "" << endl;
		for (int i = 0; i < 8; ++i) {
			for (int j = 0; j < 8; ++j) {
				cout << h_value_board[i][j] << "" "";
			}
			cout << endl;
		}
	}

	void set_state(string state_) {
		for (int i = 0; i < 8; ++i) {
			state[i] = state_[i] - '0';
		}
	}

	string get_state() {
		string res;
		for (int i = 0; i < 8; ++i) {
			res += state[i] + '0';
		}
		return res;
	}

	bool check(int mode) {
		if (mode == 0) return h_of_attack_pair() == 0;
		else return h_of_not_attack_pair() == 28;
	}

	int h_of_attack_pair() {
		int value = 0;
		for (int i = 0; i < 8; ++i) {
			value += count_attack(state[i], i);
		}
		return value / 2;
	}

	int h_of_not_attack_pair() {
		int value = 0;
		for (int i = 0; i < 8; ++i) {
			value += (7 - count_attack(state[i], i));
		}
		return value / 2;
	}

	int count_attack(int x, int y) {
		int count = 0;
		// 行
		for (int i = 0; i < 8; ++i) {
			if (i != y && board[x][i]) {
				count++;
			}
		}
		// 左上
		for (int i = x, j = y; i > 0 && j > 0; ) {
			if (board[--i][--j]) count++;
		}
		// 右下
		for (int i = x, j = y; i < 7 && j < 7; ) {
			if (board[++i][++j]) count++;
		}
		// 右上
		for (int i = x, j = y; i > 0 && j < 7; ) {
			if (board[--i][++j]) count++;
		}
		// 左下
		for (int i = x, j = y; i < 7 && j > 0; ) {
			if (board[++i][--j]) count++;
		}
		return count;
	}
	int h_value_board[8][8] = {};
	private:
		bool board[8][8];	// 棋盘
		int state[8];		// 状态的 8 位数串
};

Board b_tool;

/*******************	最陡上升爬山法	*******************/ 
bool Steepest_Hill_Climbing(Board* board) {		// 给定一个待求解的棋盘（八皇后已放置）
	int steps = 0;
	string old_state = board->get_state();		// 旧状态
	string new_state = old_state;				// 新状态，旧状态的后继
	string best_state = old_state;				// 最好的新状态
	int min_h = board->h_of_attack_pair();		// 最好的状态评估值
	int new_h;									// 新状态的评估值
	while (1) {
		++steps;								// 循环步数，对应着探索后继的步数
		bool local_max_flag = true;				// 局部最大值 flag
		// 对于棋盘第 i 列
		for (int i = 0; i < 8; ++i) {
			// 对第 i 列中的那个皇后，尝试其他的可能性（移动到 i 列中的其他行）
			for (int j = 0; j < 8; ++j) {
				if (old_state[i] != j + '0') {	// 若第 j 行不是 i 列中有皇后的那一行
					new_state = old_state;		
					new_state[i] = j + '0';
                    // 尝试把当前 i 列的皇后移到第 j 行
					board->set_state(new_state);
					board->fill_in_board();
					new_h = board->h_of_attack_pair();	// 对这次移动尝试使用评估函数进行评估
					board->h_value_board[j][i] = new_h; // 保存这次移动尝试的评估值
					/**********Begin**********/
					if (new_h < min_h) {    // 一旦有移动尝试的评估值更好
						min_h = new_h;        // 爬山，更新最好的评估值
						best_state = new_state;        // 更新最佳后继状态
						local_max_flag = false;        // 爬山成功，将局部最大值 flag 置假
						if (min_h == 0) {            // 找到全局最大值
							SHC_success_total_steps += steps; // 记录成功求解的循环步数
							return true;    // 返回 true 表示求解成功
						}
					}
					/**********End**********/
				}
                // 若第 j 行是 i 列中有皇后的那一行
				else board->h_value_board[j][i] = 0; // 赋值 0 以标志当前皇后位置
			}
		}
		board->set_state(best_state);	// 将最佳后继状态置为当前状态
		board->fill_in_board();
        old_state = best_state;
		if (local_max_flag) {			// 如果所有的移动尝试都没有更好的评估值
			SHC_failed_total_steps += steps;	// 失败，记录失败的循环步数
			return false;				// 返回 false 表示求解失败
		}
	}
}

/*******************	首选爬山法	*******************/ 
bool First_Choice_Hill_Climbing(Board* board) {	// 给定一个待求解的棋盘（八皇后已放置）
	int steps = 0;
	string old_state = board->get_state();		// 旧状态
	string new_state = old_state;				// 新状态，旧状态的后继
	string best_state = old_state;				// 最好的新状态
	int min_h = board->h_of_attack_pair();		// 最好的状态评估值
	int new_h;									// 新状态的评估值
	while (1) {									
		++steps;								// 循环步数，对应着探索后继的步数
		bool find_flag = false;					// 首选 flag
		// 对于棋盘第 i 列
		for (int i = 0; i < 8; ++i) {
			// 对第 i 列中的那个皇后，尝试其他的可能性（移动到 i 列中的其他行）
			for (int j = 0; j < 8; ++j) {
				if (old_state[i] != j + '0') {	// 若第 j 行不是 i 列中有皇后的那一行
					new_state = old_state;
					new_state[i] = j + '0';
                    // 尝试把当前 i 列的皇后移到第 j 行
					board->set_state(new_state);
					board->fill_in_board();
					new_h = board->h_of_attack_pair(); 	// 对这次移动尝试使用评估函数进行评估
					board->h_value_board[j][i] = new_h; // 保存这次移动尝试的评估值
					/**********Begin**********/
					if (new_h < min_h) {    // 一旦有移动尝试的评估值更好
						min_h = new_h;        // 爬山，更新最好的评估值
						best_state = new_state;    // 更新最佳后继状态
						find_flag = true;    // 将首选 flag 置真，首选完毕准备跳出 for 循环
						if (min_h == 0) {    // 找到全局最大值
							FCHC_success_total_steps += steps;    // 记录成功求解的循环步数
							return true;    // 返回 ture 表示成功求解
						}
						break;
					}
					/**********End**********/
				}
                // 若第 j 行是 i 列中有皇后的那一行
				else board->h_value_board[j][i] = 0; // 赋值 0 以标志当前皇后位置
			}
			if (find_flag) break;	// 找到首选，跳出 for 循环
		}
		board->set_state(best_state);	// 将最佳后继状态（首选后继状态）置为当前状态
		board->fill_in_board();
		if (!find_flag) {				// 如果所有的移动尝试都没有更好的评估值
			FCHC_failed_total_steps += steps;	// 失败，记录失败的循环步数
			return false;				// 返回 false 表示求解失败
		}
		old_state = best_state;
	}
}

/*******************	随机重启爬山法	*******************/
bool Random_Restart_Steepest_Hill_Climbing(Board* board) {
	// 随机重启上限为 1000 次
	for (int i = 0; i < 1000; ++i) {
		if (!Steepest_Hill_Climbing(board)) {	// 最陡上升爬山若失败
			board->random_initial_state();		// 重新随机生成初始状态
			board->fill_in_board();				// 按新的初始状态放置 8 皇后
		}
		else {									// 最陡上升爬山若成功
			RRSHC_success_total_steps += (SHC_failed_total_steps + SHC_success_total_steps);					// 记录随机重启爬山法的成功步数
			SHC_success_total_steps = 0;
			SHC_failed_total_steps = 0;
			return true;						// 返回 true 表示求解成功
		}
	}
    // 随机重启 1000 次仍然未找到解
    // 记录随机重启爬山法的失败步数
	RRSHC_failed_total_steps += (SHC_failed_total_steps + SHC_success_total_steps);
	SHC_success_total_steps = 0;
	SHC_failed_total_steps = 0;
	return false;								// 返回 false 表示求解失败
}

void SHC_test1() {
	Board board;
	cout << ""SHC：For the cases: "" << endl;
	board.initial();
	board.set_state(""16471352"");
	board.fill_in_board();
	board.display(0);
	Steepest_Hill_Climbing(&board);
	if (board.check(0)) {
		cout << ""Success"" << endl;
	}
	else cout << ""Failed"" << endl;
	board.display(0);
	cout << endl;
}

void FCHC_test1() {
	Board board;
	cout << ""FCHC:For the second cases: "" << endl;
	board.set_state(""45634565"");
	board.fill_in_board();
	board.display(0);
	First_Choice_Hill_Climbing(&board);
	if (board.check(0)) {
		cout << ""Success"" << endl;
	}
	else cout << ""Failed"" << endl;
	board.display(0);
	cout << endl;
}


void RRSHC_test1() {
	Board board;
	cout << ""For the cases: "" << endl;
	board.initial();
	board.set_state(""16471352"");
	board.fill_in_board();
	board.display(0);
	Random_Restart_Steepest_Hill_Climbing(&board);
	if (board.check(0)) {
		cout << ""Success"" << endl;
	}
	else cout << ""Failed"" << endl;
	board.display(0);
	cout << endl;
}
```"
54,3923,局部搜索算法（八皇后问题）,flvxytfes2mz,模拟退火算法,11241,"```

using namespace::std;

/* Use Hill-Climbing, Simulated-Annealing and Genetic-Algorithm to solve 8-Queens problem */
int SA_success_total_steps = 0;		// 模拟退火成功总步数
int SA_failed_total_steps = 0;		// 模拟退火失败总步数

class Board {
public:
	void fill_in_board() {
		initial();
		for (int i = 0; i < 8; ++i) {
			board[state[i]][i] = true;
		}
	}

	void initial() {
		for (int i = 0; i < 8; ++i) {
			for (int j = 0; j < 8; ++j) {
				board[i][j] = false;
			}
		}
	}

	void random_initial_state() {
		for (int i = 0; i < 8; ++i) {
			state[i] = rand() % 8;
		}
	}

	void set_state(string state_) {
		for (int i = 0; i < 8; ++i) {
			state[i] = state_[i] - '0';
		}
	}

	string get_state() {
		string res;
		for (int i = 0; i < 8; ++i) {
			res += state[i] + '0';
		}
		return res;
	}

	bool check(int mode) {
		if (mode == 0) return h_of_attack_pair() == 0;
		else return h_of_not_attack_pair() == 28;
	}

	int h_of_attack_pair() {
		int value = 0;
		for (int i = 0; i < 8; ++i) {
			value += count_attack(state[i], i);
		}
		return value / 2;
	}

	int h_of_not_attack_pair() {
		int value = 0;
		for (int i = 0; i < 8; ++i) {
			value += (7 - count_attack(state[i], i));
		}
		return value / 2;
	}

	int count_attack(int x, int y) {
		int count = 0;
		// 行
		for (int i = 0; i < 8; ++i) {
			if (i != y && board[x][i]) {
				count++;
			}
		}
		// 左上
		for (int i = x, j = y; i > 0 && j > 0; ) {
			if (board[--i][--j]) count++;
		}
		// 右下
		for (int i = x, j = y; i < 7 && j < 7; ) {
			if (board[++i][++j]) count++;
		}
		// 右上
		for (int i = x, j = y; i > 0 && j < 7; ) {
			if (board[--i][++j]) count++;
		}
		// 左下
		for (int i = x, j = y; i < 7 && j > 0; ) {
			if (board[++i][--j]) count++;
		}
		return count;
	}

	int h_value_board[8][8] = {};
	private:
		bool board[8][8];	// 棋盘
		int state[8];		// 状态的 8 位数串
};

Board b_tool;

//退火函数 
float schedule(float T) {
	return 0.9999 * T;
}

/*******************	模拟退火算法	*******************/
bool Simulated_Annealing(Board* board, float(*p)(float)) {
	int steps = 0;
	double T = 5;		// 把初始温度设置为 5
	string old_state = board->get_state();
	string new_state = old_state;
	int old_value = 0;
	int new_value = 0;

	while (T > 0.00001) {
		++steps;
		old_value = board->h_of_not_attack_pair();	// 使用不相互攻击的皇后的对数作为评价函数
		if (board->check(1)) {						// 如果成功找到解
			SA_success_total_steps += steps;
			return true;
		}
		T = (*p)(T);								// 降温
		// 随机选择一个新的邻接状态
		// 随机抽取一个列 y
		int y = rand() % 8;
		int x = 0;
		// 随机抽取该列中的 free 的行 x（也即没有皇后的行）
		while (1) {
			x = rand() % 8;
			if (x != old_state[y] - '0') break;
		}
		new_state = old_state;
		new_state[y] = x + '0';
		board->set_state(new_state);
		board->fill_in_board();
		new_value = board->h_of_not_attack_pair();	// 随机新状态的评估值
		int deltaE = (new_value - old_value);
		if (deltaE > 0) {							// 如果新的评估值更优
			old_state = new_state;					// 更新为新的状态
		}
		else {
			// cout << deltaE << "": "" << T << "":"" << deltaE / T << "" : "" << exp(deltaE / T) << endl;
			// 如果新的评估值差于旧的评估值，则有小概率采纳新的较差的评估值对应的新状态，允许下山
			/**********Begin**********/
			if (((float)(rand() % 1000) / 1000) < exp(deltaE / T)) {
				old_state = new_state;
			}
			else {    // 较差的新状态被否决，时间越长，较差的新状态越容易被否决
				board->set_state(old_state);
				board->fill_in_board();
			}
			/**********End**********/
		}
	}
	SA_failed_total_steps += steps;
	return false;
}


void SA_test1() {
	Board board;
	board.initial();
	board.set_state(""16471352"");
	board.fill_in_board();
	Simulated_Annealing(&board, &schedule);
	if (board.check(1)) {
		cout << ""Success"" << endl;
	}
	else cout << ""Failed"" << endl;
}


```"
55,3923,局部搜索算法（八皇后问题）,lzfecpf7s8kh,遗传算法,11242,"```
using namespace::std;

/* Use Hill-Climbing, Simulated-Annealing and Genetic-Algorithm to solve 8-Queens problem */
int generation = 0;					// 遗传算法成功所需总代数

class Board {
public:
	void fill_in_board() {
		initial();
		for (int i = 0; i < 8; ++i) {
			board[state[i]][i] = true;
		}
	}

	void initial() {
		for (int i = 0; i < 8; ++i) {
			for (int j = 0; j < 8; ++j) {
				board[i][j] = false;
			}
		}
	}

	void random_initial_state() {
		for (int i = 0; i < 8; ++i) {
			state[i] = rand() % 8;
		}
	}

	void set_state(string state_) {
		for (int i = 0; i < 8; ++i) {
			state[i] = state_[i] - '0';
		}
	}

	string get_state() {
		string res;
		for (int i = 0; i < 8; ++i) {
			res += state[i] + '0';
		}
		return res;
	}

	bool check(int mode) {
		if (mode == 0) return h_of_attack_pair() == 0;
		else return h_of_not_attack_pair() == 28;
	}

	int h_of_attack_pair() {
		int value = 0;
		for (int i = 0; i < 8; ++i) {
			value += count_attack(state[i], i);
		}
		return value / 2;
	}

	int h_of_not_attack_pair() {
		int value = 0;
		for (int i = 0; i < 8; ++i) {
			value += (7 - count_attack(state[i], i));
		}
		return value / 2;
	}

	int count_attack(int x, int y) {
		int count = 0;
		// 行
		for (int i = 0; i < 8; ++i) {
			if (i != y && board[x][i]) {
				count++;
			}
		}
		// 左上
		for (int i = x, j = y; i > 0 && j > 0; ) {
			if (board[--i][--j]) count++;
		}
		// 右下
		for (int i = x, j = y; i < 7 && j < 7; ) {
			if (board[++i][++j]) count++;
		}
		// 右上
		for (int i = x, j = y; i > 0 && j < 7; ) {
			if (board[--i][++j]) count++;
		}
		// 左下
		for (int i = x, j = y; i < 7 && j > 0; ) {
			if (board[++i][--j]) count++;
		}
		return count;
	}
	int h_value_board[8][8] = {};
	private:
		bool board[8][8];	// 棋盘
		int state[8];		// 状态的 8 位数串
};

Board b_tool;

// GENETIC-ALGORITHM
// 用于挑选种群 p 中参与繁殖的个体，适应度函数评价越高的个体越容易被挑选
string Random_Selection(vector<string> &p) {
	int total_value = 0;
	vector<int> h(p.size());
	vector<int> rand_array;
	for (int i = 0; i < p.size(); ++i) {
		b_tool.set_state(p[i]);
		b_tool.fill_in_board();
		h[i] = b_tool.h_of_not_attack_pair();
		total_value += h[i];
	}
	for (int i = 0; i < p.size(); ++i) {
		for (int j = 0; j < h[i]; ++j) {
			rand_array.push_back(i);
		}
	}
	int rv = rand() % total_value;
	return p[rand_array[rv]];
}

// 杂交，给定参与配对的父母状态 x 和 y
string Reproduce(string x, string y) {
	int cut = rand() % 7;	// 0 1 2 3 4 5 6
	cut++;					// 1 2 3 4 5 6 7
    // 以上两步处理确保杂交点不是第一个数字之前和最后一个数字之后，也即后代一定包括了父母双方的信息
	return x.substr(0, cut) + y.substr(cut); 
}

// 变异，给定的个体状态 s 以 rate 的几率发生变异
bool Mutate(string &s, float rate) {
	int rand_mutate_pos = rand() % 64;
	string new_s = s;
	int h = 0;
	int new_h = 0;
	if (((float)(rand() % 1000) / 1000) < rate) {
		new_s[rand_mutate_pos / 8] = (rand_mutate_pos % 8) + '0';
		b_tool.set_state(new_s);
		b_tool.fill_in_board();
		new_h = b_tool.h_of_not_attack_pair();
		b_tool.set_state(s);
		b_tool.fill_in_board();
		h = b_tool.h_of_not_attack_pair();
		if (new_h >= h) s = new_s;		// 为加快收敛速度，只保留有利变异
		return true;
	}
	return false;
}

// 打印种群，用于观察种群的演化过程
void print_p(const vector<string>& p) {
	for (auto str : p) {
		b_tool.set_state(str);
		b_tool.fill_in_board();
	}
}

// 遗传算法
bool Genetic_Algorithn(vector<string> &p, float mutate_rate) {
	vector<string> old_p = p;
	vector<string> new_p(p.size());
    // 遗传代数设置为 10000 代
	for (int n = 0; n < 10000; ++n) {
		for (int i = 0; i < p.size(); ++i) {
            // 挑选参与繁殖的两个个体
			string x = Random_Selection(old_p);
			string y = Random_Selection(old_p);
            // 产生后代
			string child = Reproduce(x, y);
            // 后代变异
            /**********Begin**********/
			Mutate(child, mutate_rate);
			new_p[i] = child;
			b_tool.set_state(child);
			b_tool.fill_in_board();
			if (b_tool.check(1)) {    // 若成功找到解，输出到 p[0] 上
				p[0] = child;
				generation += n;
				return true;
			}
			/**********End**********/
		}
		old_p = new_p;					// 旧一代种群被新一代种群取代
		print_p(old_p);					// 打印观察种群变化
	}
	p = old_p;							// 失败，但得到较好的种群
	return false;
}


bool GA_test1(int p_size = 4, float mutate_rate = 0.5) {
	vector<string> p(p_size);
	for (int i = 0; i < p_size; ++i) {
		b_tool.random_initial_state();
		b_tool.fill_in_board();
		p[i] = b_tool.get_state();
	}
	
	if (Genetic_Algorithn(p, mutate_rate)) {
		b_tool.set_state(p[0]);
		b_tool.fill_in_board();
		cout<<""Success!""<<endl;
		return true;
	}
	else {
		return false;
	}
}

```"
56,4002,哈夫曼树,7jesrqitp35x,哈夫曼编码及译码应用,11218,"```
/*请在此处编写代码，完成哈夫曼编码，并能输出每个叶子结点的编码*/
/**********  Begin  *********/
#include <iostream>
#include <stdlib.h>
#include <string>

using namespace std;
int N = 5; //表示有N个待编码的频率或数

struct node
{
	float data;
	char code[20]; //存放哈夫曼编码 
	struct node *left, *right;
	struct node *next;
	int code_n;
}; // 哈夫曼树的结点定义

struct node *Head; //头结点
int num=N-1;

void printcode(struct node *p)//输出哈夫曼编码
{
	int i ;
	if(p==NULL) return ;

	for(i= p->code_n-1;i>=0 ;i--)
		cout<<p->code[i];
}

void print(  ) //输出树的结点的数值
{
	struct node *p  ;
	p = Head->next;
	while(p!=NULL)
	{
		cout<<p->data<<"" "";
		p = p->next;
	}
	cout<<endl;
}

void Insert(struct node *b  ) //插入结点，保持递增
{
	struct node *p,*q;
	p=Head->next ; q = Head;
	if(p == NULL)
	{
		Head->next = b;
	}
	else
	{
		while(p!=NULL && p->data < b->data)
		{
			q = p;
			p = p->next;
		}
		b->next = p;
		q->next = b;
	}
}

void code(struct node *a,int flag) //编码过程
{
	if (a==NULL) return ;
	if(flag==1)  //flag为 1 表示左子树
	{
		a->code[a->code_n] = '0';
	}
	else if(flag==2)//flag为2 表示右子树
	{
		a->code[a->code_n] = '1';
	}
	a->code_n++;
	code(a->left, flag);
	code(a->right,flag);
}

void InitNode( ) //初始化结点
{
	struct node *p;
	int i;
	float m;
	Head =(struct node *)malloc(sizeof(struct node));
	Head->left =Head->right = Head->next =NULL ;
	for(i=0;i<N;i++)
	{
		cin>>m;
		p = (struct node *)malloc(sizeof(struct node));
		p->data = m;
		p->left = p->right = p->next =NULL;
		p->code_n = 0;
		Insert( p);
	}
}

void InOrder(struct node *T,int flag)
{
	if(T==NULL) return ;
	else
	{
		if(T->left == T->right  && T->left == NULL)
		{
			cout<<T->data <<"" "";
			printcode(T);
			cout<<endl;
		}
		InOrder(T->left,1);
		InOrder(T->right,2);
	}
}

void Huffman()//创建haffman树
{
	int i =0;
	struct node *temp;
	struct node  *p,*q;
	while(1)
	{
		p = Head->next;
		q = p->next;
		if(q!=NULL)
			Head->next = q->next;
		else
			Head->next = NULL;
			temp = (struct node *)malloc(sizeof(struct node));
			temp->data  = p->data + q->data ;
			temp->left = p;
			temp->right = q;
			temp->code_n = 0;
			code(p,1);
			code(q,2);
			temp->next = NULL;
			Insert( temp );
		if(Head->next->next == NULL) break;
	}
}


int main(void)
{
	cin>>N;
	InitNode( );
	Huffman();
	InOrder(Head->next,0);
}
/**********  End  *********/
```"
57,3947,实验四 二叉树及遍历,yf4t579efiql,二叉树的创建及遍历输出,,
58,3947,实验四 二叉树及遍历,3aqspgkmlvwb,选做关：完成二叉树相关应用,,
59,3936,问题求解与实践第六周任务 树与图,na9i4xs3eovy,树与图,,
60,3741,实验三 队列及应用,wbumn2sc6387,利用队列实现密码加密解密,,
61,3833,第三章  分支结构程序设计,f5umw2qxy8ps,一个学生单科考试成绩的及格判断,10560,"```cpp
#include <iostream>
using namespace std;

int main()
{
     int score;//存储输入的成绩
      
    /********** Begin *********/

        //输入一科成绩，成绩为整数
        //一个单if语句，当score的值大于等于60时，在屏幕上输出“Passed!” ，否则屏幕上不输出任何信息，程序结束。
        //  行尾加回车
     cin>>score;
     if(score>=60)
        cout<<""Passed!""<<endl;
    /********** End *********/

    return 0;
}
```"
62,3833,第三章  分支结构程序设计,ypsf8v7ecuom,求两个整数的最大值（if-else）,10561,"```cpp
#include <iostream>
using namespace std;

int main()
{
     
    /********** Begin *********/
   int a,b,max;
    cin>>a>>b;
    if(a>b)
        max=a;
    else
        max=b;
cout<<""max=""<<max<<endl;
     

    /********** End *********/

    return 0;
}
```"
63,3833,第三章  分支结构程序设计,3mcw2spilyh6,学生成绩按等级制处理,10562,"```c
#include <iostream>
using namespace std;

int main()
{
     int score;
     cin>>score;//输入一个学生单科考试成绩
    /********** Begin *********/
   if(score>=90)
    cout<<""Excellent!""<<endl;
    else if(score>=80)
        cout<<""Good!""<<endl;
    else if(score>=70)
        cout<<""Right!""<<endl;
    else if(score>=60)
        cout<<""Pass!""<<endl;
    else
        cout<<""Failed!""<<endl;

    /********** End *********/

    return 0;
}
```"
64,3833,第三章  分支结构程序设计,8cmtb5l24qzh,switch练习,10563,"```c
#include <iostream>
using namespace std;


int main()
{
      
     int  n;
    /********** Begin *********/
     cin>>n;
    switch (n)
    {
        case 1:cout<<""Monday""<<endl;break;
        case 2:cout<<""Tuesday""<<endl; break;
        case 3:cout<<""Wednesday""<<endl; break;
        case 4:cout<<""Thursday""<<endl; break;
        case 5:cout<<""Friday""<<endl; break;
        case 6:cout<<""Saturday""<<endl; break;
        case 7:cout<<""Sunday""<<endl; break;
        default:cout<<""error""<<endl;
      

	}
    /********** End *********/

    return 0;
}
```"
65,3833,第三章  分支结构程序设计,puawqoin5ly8,分支结构的嵌套（求三个数的最大值）,10564,"```c
#include <iostream>
using namespace std;


int main()
{
      int a,b,c,max;
    /********** Begin *********/
    cin>>a>>b>>c;
    if(a>b)
        max=a;
    else
        max=b;
    if(c>max)
        max=c;
    cout<<""max is:""<<max<<endl;
      

    /********** End *********/

    return 0;
}
```"
66,3833,第三章  分支结构程序设计,mcalksf46u3h, 三个数的排序,10565,"```c
#include <iostream>
using namespace std;


int main()
{
     int a,b,c,t;
     cin>>a>>b>>c;//输入三个整数
    /********** Begin *********/
if(a>b)
{
t=a;
a=b;
b=t;
}
if(a>c)
{
t=a;
a=c;
c=t;
}
if(b>c)
{
t=b;
b=c;
c=t;
}
      


    /********** End *********/
    cout<<a<<""  ""<<b<<""  ""<<c<<endl;//从下到大输出三个整数
    return 0;
}
```"
67,3833,第三章  分支结构程序设计,t5wrvhji3u4c,逻辑表达式（判断字符区间）,10566,"```c
#include <iostream>
using namespace std;


int main()
{
     
     char c;//输入一个字符
    /********** Begin *********/

      //判断用户输入的字符是数字、字母还是其他字符
	    cin>>c;
    if(c>=48&&c<=57)
        cout<<""It is a digital!""<<endl;
    else if(c>=65&&c<=90||c>=97&&c<=122)
            cout<<""It is a character!""<<endl;
        else 
             cout<<""It is a others!""<<endl;

    /********** End *********/
   
    return 0;
}
```"
68,3833,第三章  分支结构程序设计,8zspirc9j273,分支结构练习-闰年判断,10567,"```c
#include <iostream>
using namespace std;


int main()
{
     int year,leap;
     cin>>year;//输入年份
    /********** Begin *********/
     cin>>year;//输入年份
    if(year%4==0)
        if(year%100==0)
        if(year%400==0)
        leap=1;
    else
        leap=0;
    else 
        leap=1;
    else
        leap=0;
if(leap)
    cout<<year<<"" is a leap year.""<<endl;
else
    cout<<year<<"" is not a leap year.""<<endl;
     


    /********** End *********/
   
    return 0;
}
```"
69,3833,第三章  分支结构程序设计,wefvfgazlums,分支结构练习（一元二次方程）,10568,"```c
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;
// 定义main函数
int main()
{
     int a,b,c;
     cin>>a>>b>>c;//输入一元二次方程的三个系数
	 /********** Begin *********/
 double disc;
 
 cout<<setiosflags(ios::fixed)<<setprecision(2);
    disc=b*b-4*a*c;
    if(a==0)
        cout<<""该方程不是一元二次方程!""<<endl;
    else if(fabs(disc)<=1e-6)
         cout<<""方程有两个相同实根:x1=x2=""<<((-b)-sqrt(disc))/(2*a)<<endl;
    else if(disc>0)
        cout<<""方程有两个不同实根:x1=""<<(-b+sqrt( disc))/(2*a)<<"",x2=""<<(-b-sqrt( disc))/(2*a)<<endl;
    else if( disc<0)
        cout<<""方程有两个不同虚根:x1=""<<-b/(2*a)<<""+""<<sqrt(- disc)/(2*a)<<""i,x2=""<<-b/(2*a)<<""-""<<sqrt(- disc)/(2*a)<<""i""<<endl;
    /********** End *********/
	return 0;
}
```"
70,3833,第三章  分支结构程序设计,oiyzfqxlbnvp,分支结构练习（个人所得税）,10569,"```c
#include <iostream>
#include <iomanip>
using namespace std;


int main()
{
   
    /********** Begin *********/
       //输入个人应发工资
     
      //计算并输出个人所得税
     double mySalary,myTax=0;
     cin>>mySalary;//输入个人应发工资
     //计算并输出个人所得税
    cout<<setiosflags(ios::fixed)<<setprecision(2);
    if(mySalary<=800)
        myTax=0;
    else if(mySalary<=5000)
        myTax=(mySalary-800)*0.03;
    else 
       myTax=(mySalary-5000)*0.2+(5000-800)*0.03;
        cout<<""个人所得税""<<myTax<<""元""<<endl;

    /********** End *********/
   
    return 0;
}
```"
71,3855,问题求解与实践-简单数值计算（四）,fscuib9epnj7,一元线性回归,,
72,3831,问题求解与实践-简单数值计算（三）,56c8trulagfh,牛顿插值法求解函数近似值,,
73,3751,循环单链表操作,ut257ykz8vsh,单循环链表的创建及遍历,,
74,3751,循环单链表操作,rsbiv9n5pu8g,两个带头结点的单循环链表的合并,,
75,3816,算法设计与分析：递归与分治策略,8i3o9gxfqvn7,快速排序,10012,"```cpp
#include<iostream>
using namespace std;
 
void print(int a[], int n)
{  
    for(int j= 0; j<n; j++)
	{  
           cout<<a[j] <<"" "";  
        }  
}  
 
void quickSort(int a[], int low ,int high)
{
 /********************begin***********************/
 	if(low<high)  //判断是否满足排序条件，递归的终止条件
	{
		int i = low, j = high;   //把待排序数组元素的第一个和最后一个下标分别赋值给i,j，使用i,j进行排序；
		int x = a[low];    //将待排序数组的第一个元素作为哨兵，将数组划分为大于哨兵以及小于哨兵的两部分                                   
		while(i<j)  
		{
		  while(i<j && a[j] >= x) j--;  //从最右侧元素开始，如果比哨兵大，那么它的位置就正确，然后判断前一个元素，直到不满足条件
		  if(i<j) a[i++] = a[j];   //把不满足位次条件的那个元素值赋值给第一个元素，（也即是哨兵元素，此时哨兵已经保存在x中，不会丢失）并把i的加1
		  while(i<j && a[i] <= x) i++; //换成左侧下标为i的元素开始与哨兵比较大小，比其小，那么它所处的位置就正确，然后判断后一个，直到不满足条件
		  if(i<j) a[j--] = a[i];  //把不满足位次条件的那个元素值赋值给下标为j的元素，（下标为j的元素已经保存到前面，不会丢失）并把j的加1
		} 
	        a[i] = x;   //完成一次排序，把哨兵赋值到下标为i的位置，即前面的都比它小，后面的都比它大
		quickSort(a, low ,i-1);  //递归进行哨兵前后两部分元素排序 ， low,high的值不发生变化，i处于中间
		quickSort(a, i+1 ,high);
	}
 
 
 /********************end *************************/
}
 
int main()
{  
	int n;
	cin>>n;
	int *a = new int[n];
	for (int i=0;i<n;i++)
	{
		cin>>a[i];
	}
   
 /********************begin***********************/
    quickSort(a,0,n-1);   
    print(a,n);  
 /********************end *************************/
} 
```"
76,3816,算法设计与分析：递归与分治策略,6fr5ou4yenb7,归并排序,10055,"```cpp
#include<iostream>
using namespace std;
 
//归并过程
void merge(int arr[], int l, int mid, int r){
	int help[r-l+1];//辅助数组
	int i = 0;
	int lIndex = l;
	int rIndex = mid+1;
	while(lIndex <= mid && rIndex <= r){
		help[i++] = arr[lIndex] < arr[rIndex] ? arr[lIndex++]:arr[rIndex++];	
	}
    //左边和右边肯定有一边到头了，不可能同时，因为每次只移动一边
	while(lIndex <= mid){
		help[i++] = arr[lIndex++];
	} 
	while(rIndex <= r){
		help[i++] = arr[rIndex++];
	}
    //将排好序的辅助数组赋值给原始数组，不需要返回值
	for(i = 0; i < r-l+1; i++){
		arr[l+i] = help[i];
	}
}
 
//递归
static void mergeSort(int arr[], int l, int r){
	if(l == r){
		return;
	}
	int mid = (l + r) / 2;
    //左半部分归并排序
	mergeSort(arr, l, mid);
    //右半部分归并排序
	mergeSort(arr, mid+1, r);
    //左右部分归并
	merge(arr, l, mid, r);
}
 
//归并排序整个数组
void mergeSort(int arr[], int n){
    //如果数组为空或只有一个元素，不需要排序
	if(arr == NULL || n < 2){
		return;
	}
	mergeSort(arr,0,n-1);
}
 
 
int main(){
	int n; 
	cin >> n;
	int arr[n];
	for(int i = 0; i < n; i++) cin >> arr[i];

	mergeSort(arr, n);

	for(int i = 0; i < n; i++){
		cout << arr[i] << "" "";
	} 
	
	return 0;
} 

```"
77,3816,算法设计与分析：递归与分治策略,raf9687fgh5p,整数因子分解,10058,"```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 100000;
int ff[N];
 
int f(int n)
{
    int sum = 1;
    if(n < N && ff[n] != 0) return ff[n];
    for(int i = 2; i <= sqrt(n); i++)
    {
        if(n % i == 0)
        {
            if(i * i == n)
                sum += f(i);  
            else    
                sum += f(i) + f(n / i);      
        }
    }
    if(n < N) ff[n] = sum;
    return sum;
}
 
int main()
{    
    int n;
    scanf(""%d"", &n);
    memset(ff, 0, sizeof(ff));
    printf(""%d"", f(n));
    return 0;
}

```"
78,3742,线性表单元课堂测试,lj9oibckspxa,链式线性表操作,,
79,3742,线性表单元课堂测试,pasx3umkqfoe,利用栈操作，实现平衡符号判定,,
80,3742,线性表单元课堂测试,qw8bcli7n2zh,顺序表基本操作及应用,,
81,3681,问题求解与实践-简单数值计算（二）,i42fy7lfb6gn,牛顿迭代法求解一元非线性方程,,
82,3681,问题求解与实践-简单数值计算（二）,c5ifrqkp2e76,利用高斯法求解线性方程组,,
83,3593,顺序表的基本操作,oi5mffntyx4e,顺序表的查找功能,9501,"bool GetElem(SqList *L,int i,ElemType &e)	
//求线性表中第i个元素值
{
	if (i<1 || i>L->length)
		return false;
	e=L->data[i-1];
	return true;
}"
84,3593,顺序表的基本操作,9gtzso5uf4jk,顺序表的插入和删除功能,9503,"bool ListInsert(SqList *&L,int i,ElemType e)	//插入第i个元素
{
	int j;
	if (i<1 || i>L->length+1)
		return false;
	i--;						//将顺序表位序转化为elem下标
	for (j=L->length;j>i;j--) 	//将data[i]及后面元素后移一个位置
		L->data[j]=L->data[j-1];
	L->data[i]=e;
	L->length++;				//顺序表长度增1
	return true;
}"
85,3593,顺序表的基本操作,ef5qfwx3nk2o,顺序表的逆序,9506,"```cpp
void ListReverse(SqList *&L)
｛
	int i=0,j=L->length-1;
	ElemType tmp;
	while(i<j)
	{
		tmp=L->data[i];
		L->data[i]=L->data[j];
		L->data[j]=tmp;
	}
｝
```"
86,3655,单链表基本操作,8qv5ge9abcl4,单链表头结点后插入元素及遍历单链表,,
87,3655,单链表基本操作,4xntkg2eosvf,头插法建立单链表,,
88,3655,单链表基本操作,cb39oi7mhnpu,尾插法建立单链表,,
89,3655,单链表基本操作,blgkmzu8fxfy,单链表元素查找,,
90,3655,单链表基本操作,vafpbetn8zrs,单链表插入,,
91,3655,单链表基本操作,xioe8nrp3hl2,单链表结点删除,,
92,3563,课程设计-基于栈的算术表达式求值,awcn9p6hl4j5,中缀式求值,8975,"本关任务对应的参考代码实现如下：
```cpp
char Precede(char theta1, char theta2)//比较两个运算符θ1和θ2的优先关系，返回'>'、'<'或'='。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/	
    switch(theta1)
	{
	case '+':
	case '-': 
		......
	case '*':
	case '/':
		......
	case '(':
		......
	case ')':
		......
	case '#':
		......
	}
    /********** End **********/	
}

double Evaluation(char exp[80])//中缀式求值
{
    
	SqStack1 opnd;SqStack2 optr; char s[80],x,top;double sum,a,b,result; int i,j=0,n;
	InitStack1(&opnd);//构造栈opnd存放操作数 
	InitStack2(&optr);//构造栈optr存放运算符
	Push2(&optr,'#'); 
	GetTop2(optr, &top);//取出栈顶运算符，用top保存
	i=0;
	while(exp[i]!='#'||top!='#')
	{
	    // 请在这里补充代码，完成本关任务
        /********** Begin *********/	
        if(exp[i]>='0'&&exp[i]<='9')//读出的是操作数
		{
			......
		}
		else
			switch(Precede(top,exp[i]))//比较栈顶运算符top与读出的运算符exp[i]的优先级
		{
            ......
		}
		GetTop2(optr,&top);
        /********** End **********/	
	}
	Pop1(&opnd,&result);
	return(result);
}


```"
93,3563,课程设计-基于栈的算术表达式求值,qzfcpgr2e9uh,中缀式转换成后缀式,9300,"本关任务对应的参考代码实现如下：
```cpp
void Conversion(char exp[80],char suffix[80])//中缀式转换成后缀式
{    
	SqStack2 optr; char x,top; int i,j=0;
	InitStack2(&optr);//构造栈optr存放运算符
	Push2(&optr,'#'); 
	GetTop2(optr, &top);//取出栈顶运算符，用top保存
	i=0;
	while(exp[i]!='#'||top!='#')
	{
	    // 请在这里补充代码，完成本关任务
        /********** Begin *********/	
	    if(exp[i]>='0'&&exp[i]<='9')//读出的是操作数
		{
			......
		}
		else
			switch(Precede(top,exp[i]))//比较栈顶运算符top与读出的运算符exp[i]的优先级
		{
            ......
		}
		GetTop2(optr,&top);
        /********** End **********/
	}
	suffix[j]='\0';
}

char Precede(char theta1, char theta2)//比较两个运算符θ1和θ2的优先关系，返回'>'、'<'或'='。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/	
    switch(theta1)
	{
	case '+':
	case '-': 
		......
	case '*':
	case '/':
		......
	case '(':
		......
	case ')':
		......
	case '#':
		......
	}
    /********** End **********/	
}
```"
94,3563,课程设计-基于栈的算术表达式求值,k32zuo75bxsi,后缀式求值,8979,"本关任务对应的参考代码实现如下：
```cpp
double Evaluation(char suffix[80])//后缀式求值
{
    
	SqStack1 opnd; char s[80],x,top;double sum,a,b,result; int i,j=0,n;
	InitStack1(&opnd);//构造栈opnd存放操作数 
	i=0;
	while(suffix[i]!='\0')
	{
	    // 请在这里补充代码，完成本关任务
        /********** Begin *********/	
        if(suffix[i]>='0'&&suffix[i]<='9')//读出的是操作数
		{
			......
		}
		else if(suffix[i]==',') i++;
		else
		{
			......
		}
        /********** End **********/	
	}
	Pop1(&opnd,&result);
	return(result);
}
```"
95,3658,实验二 栈应用,ufrqtlzsjcn9,栈操作及数进制转换的实现,,
96,3658,实验二 栈应用,qcz47nxay8js,中缀表达式转换为后缀表达式,,
97,3544,问题求解与实践-简单数值计算,ls3apjxhu4zt,一元多项式化简与求导,,
98,3544,问题求解与实践-简单数值计算,yijbzolf9sht,一元多项式除法,,
99,3629,实验一 线性表应用,8uk4iaemofrw,一元多项式相加,9236,"```
#ifndef _LAB1_H_
#define  _LAB1_H_
#include <iostream>
#include <stdio.h> 

using namespace std ;

//存放多项式某项的结点结构 
struct node
{
  int exp ;  // 表示指数
  int coef ; //表示系数
  struct node *next;  //指向下一个结点的指针 
};

typedef  struct node * PNODE ;

/*
  函数功能：生成多项式
  函数名：createPoly
  函数参数：无
  返回值：指向多项式的头指针 
*/
PNODE createPoly(void)
{
    //在此处填写代码，能实现创建一个多项式并返回多项式头指针的函数
	//注意：头指针不存放多项式的项。 
    /**********  Begin **********/
 	PNODE head = new struct node,temp,tail = NULL;
    head->next = NULL;
    int exp = -1,coef =-1;
    while(1)
    {
        cin>>coef>>exp ;
        if(coef == 0) break;
        temp = new     struct node;
        temp->coef = coef ;
        temp->exp = exp;
        temp->next = NULL;
        if(tail == NULL) 
        {
            head->next = temp;
            tail = temp ;
        }
        else 
        {
            tail->next = temp;
            tail = temp;
        }
     } 
     return head;
     /**********  End **********/
} 
  
/*
   函数功能：进行多项式相加
   函数名：addPoly
   函数参数：polyAddLeft ：加法左边多项式头指针, polyAddRight：加法右边多项式头指针 
   返回值：指向结果多项式的头指针 
*/
PNODE addPoly(PNODE polyAddLeft , PNODE polyAddRight)
{
    //在此处填写代码，能实现创两个多项式相加并返回结果多项式头指针的函数
    /**********  Begin **********/
 	if(polyAddLeft == NULL && polyAddRight == NULL) return NULL;
    PNODE polyResult = new struct node ;
    if(polyAddLeft == NULL && polyAddRight!=NULL) 
        polyResult->next =  polyAddRight->next ;
    else if(polyAddLeft != NULL && polyAddRight == NULL) 
        polyResult->next =  polyAddLeft->next ;
    else
    {
        PNODE tail = NULL ,tempLeft = polyAddLeft->next ,tempRight = polyAddRight->next, tempResult;
        polyResult->next = NULL;
        while(tempLeft != NULL && tempRight->next !=NULL)
        {
            tempResult = new struct node ;
            tempResult->next = NULL;
            if(tempLeft->exp > tempRight->exp)
            {
                tempResult->coef =  tempRight->coef ;
                tempResult->exp =  tempRight->exp ;
                tempRight = tempRight->next ;
            }
            else if(tempLeft->exp < tempRight->exp)
            {
                tempResult->coef =  tempLeft->coef ;
                tempResult->exp =  tempLeft->exp ;
                tempLeft = tempLeft->next;
            }
            else
            {
                tempResult->coef =  tempLeft->coef + tempRight->coef ;
                tempResult->exp =  tempLeft->exp ;
                tempLeft = tempLeft->next;
                tempRight = tempRight->next;
                if(tempResult->coef == 0) 
                {
                    delete tempResult ;
                    continue ;
                }
            }
            if(tail == NULL) 
            {
                polyResult->next = tempResult;
                tail = tempResult;
            }
            else
            {
                tail->next = tempResult ;
                tail = tempResult;
            }
        }
            
        while(tempRight != NULL)
        {
            tempResult = new struct node ;
            tempResult->next = NULL;
            tempResult->coef = tempRight->coef;
            tempResult->exp = tempRight->exp;
            tail->next = tempResult ;
            tempRight = tempRight->next;
        }
        while(tempLeft != NULL)
        {
            tempResult = new struct node ;
            tempResult->next = NULL;
            tempResult->coef = tempLeft->coef;
            tempResult->exp = tempLeft->exp;
            tail->next = tempResult ;
            tempLeft = tempLeft->next;
        }
    } 
    return polyResult ;
    /**********  End **********/
}  
  
/*
   函数功能：输出多项式 
   函数名：printPoly
   函数参数：待输出多项式的头指针poly 
   返回值：无 
*/
 void printPoly(PNODE poly)
 {
 	//在此处填写代码，能实现按格式输出多项式的功能，输出格式样例见说明 
    /**********  Begin **********/
 	if(poly == NULL) return ;
    PNODE temp = poly->next;
    while(temp != NULL)
    {
        cout<<temp->coef<<""x^""<<temp->exp;
        if(temp->next == NULL)  break;
        cout<<""+"" ;
        temp = temp->next;
    }
    /**********  End **********/
}  

#endif
```"
100,3629,实验一 线性表应用,g9f8clexv2h5,利用单链表实现集合基本运算,9238,"```
#ifndef _LINKSET_H_
#define _LINKSET_H_
#include <iostream>
using namespace std;
typedef int DataType;

struct  node
{
    DataType  element;
    struct node  *next;
};
typedef struct node * SET;
void insert(DataType datax, SET set);

/*
  函数名： InitSet
  函数功能：根据参数num，初始化集合
  函数参数：集合元素的个数 
  返回值：集合头指针 
*/
SET InitSet(int num)
{

    SET p;
    p = new struct  node  ;
    p->next = NULL;
    p->element = num;
    int temp;
    for(int i =0;i<num;i++)
    {
        cin>>temp;
        insert(temp, p); //调用insert函数，将输入数据插入集合
    }
    return p; 
}


/*
  函数名： find
  函数功能：在集合中查找值为datax的成员 
  函数参数：datax:待查找的值 ； set：集合的头结点 
  返回值：找到值为datax的成员返回1，否则返回0 
*/
int find(DataType datax, SET  set)
{
    //请在此处填写代码，在set集合中查找值为datax的成员，若找到返回1，否则返回0
    /**********  Begin  **********/
    if(set == NULL || set->element == 0) return 0;
    SET p;
    p = set->next;
    while(p!=NULL && p->element!=datax) p = p->next;
    if(p==NULL) return 0;
    else return 1;
    /**********   End   **********/
}

/*
  函数名： insert
  函数功能：在集合set中插入值为datax的成员 ，插入位置在表头 
  函数参数：datax:待插入的值 ； set：集合的头结点 
  返回值：无 
*/
void insert(DataType datax, SET set)
{
    //请在此处填写代码，将datax插入集合set， 注意因集合元素是无序的，只需将新成员插入表头
    /**********  Begin  **********/
    SET temp;
    temp = (SET ) malloc(sizeof(struct node));
    temp->element = datax;
    temp->next = NULL;
    if(set == NULL) set = temp ;
    else
    {
    temp->next = set->next;
    set->next = temp;
    }
    set->element++;
    /**********   End   **********/
 }

/*
  函数名： copyList
  函数功能：将集合setA复制生成集合setB 
  函数参数：setA 、setB的头结点 
  返回值：无 
*/
void copySet(SET setA, SET setB)
{
    //请在此处填写代码，实现将集合setA的成员复制到集合setB的功能
    /**********  Begin  **********/
    if(setA == NULL || setA->element == 0) return ;
    SET  p;
    p = setA->next;
    while(p !=NULL)
    {
        insert(p->element,setB);
        p = p->next;
    }
    /**********   End   **********/
}

/*
  函数名： printSet
  函数功能：输出集合的元素，以空格作为元素之间分界符 
  函数参数：set的头结点 
  返回值：无 
*/
void printSet(SET set)
{
    //请在此处填写代码，实现输出集合元素的功能，元素之间以空格为分界符
    /**********  Begin  **********/
    if (set == NULL || set->element == 0) return ;
    SET p=  set->next;
    while(p!=NULL)
    {
        cout<<p->element<<"" "";
        p = p->next;
    }
    /**********  End  **********/
}

/*
  函数名： setUnion
  函数功能：求两个集合setA 和 setB的并集 
  函数参数：setA和setB的头结点 
  返回值：并集集合的头结点 
*/
SET setUnion(SET setA ,SET setB)
{
    //请在此处填写代码，可直接使用上面已经实现的各操作
    /**********  Begin  **********/
	SET  p;
    SET setC = new struct node ;
    setC->element = 0 ;
    setC->next = NULL;
    if(setA == NULL || setA->element == 0) setC = setA ;
    else if (setB == NULL || setB->element == 0) setC = setB ;
    else
    {
        copySet(setA,setC);
        p = setB->next;
        while(p!=NULL)
        {
            if(find(p->element, setC)==0)
                insert(p->element,setC);
            p = p->next;
        }
    }
    return setC;
    /**********  End  **********/
}

/*
  函数名： setIntersect
  函数功能：求两个集合setA 和 setB的交集 
  函数参数：setA和setB的头结点 
  返回值：交集集合的头结点 
*/
SET setIntersect(SET setA ,SET setB)
{
    //请在此处填写代码，可直接使用上面已经实现的各操作
    /**********  Begin  **********/
    if(setA == NULL || setA->element == 0 || setB == NULL || setB->element == 0 ) return NULL;
    SET setC = new struct node ;
    setC->element = 0 ;
    setC->next = NULL;
    SET p = setA->next ;
    while(p!=NULL)
    {
        if(find(p->element , setB) == 1)
           insert(p->element , setC);
        p = p->next;   
    }
    return setC ;    
    /**********  End  **********/
}
	
/*
  函数名： setExcept
  函数功能：求两个集合setA 和 setB的差 
  函数参数：setA和setB的头结点 
  返回值：结果集合的头结点 
*/
SET setExcept(SET setA ,SET setB)
{
    //请在此处填写代码，可直接使用上面已经实现的各操作
    /**********  Begin  **********/
    if(setA == NULL || setA->element == 0 ) return NULL;
    if(setB == NULL || setB->element == 0  ) return setA;
    SET setC = new struct node ;
    setC->element = 0 ;
    setC->next = NULL;
    SET p = setA->next ;
    while(p!=NULL)
    {
        if(find(p->element , setB) == 0)
           insert(p->element , setC);
        p = p->next;   
    }
    return setC ;  
    /**********  End  **********/      
}	
      
#endif
```"
101,3553,链表应用能力测评,wu2r3ha8lst7,链表插入操作,9147,"void printList_link(PLIST head )
{
	/*在此处完成任务，输出head为表头的单链表数据元素*/
	//begin
 
	PLIST temp = head->next ;
	while(temp)
	{
		cout<<temp->data <<"" "";
		temp = temp->next;
	 } 
	//end 
}
void insertDataTail(PLIST head , int insData )
{
	/*在此处完成任务，在head为表头的单链表表尾插入数据元素insData*/
	//begin
	PLIST temp = new struct node ;
	temp->data = insData ;
	temp->next = NULL;
	if(head->next == NULL)
	  head->next = temp;
	  else
	  {
	  	PLIST tail = head->next;
	  	while(tail->next != NULL)
	  	  tail = tail->next;
	  	tail->next = temp;  
	  }
	
	
	
	//end 	
}"
102,3460,课程设计-基于顺序存储结构的一元多项式的计算,cja5bfh9qfy4,一元多项式的相加,8863,"本关任务对应的参考代码实现如下：
```cpp
SqList Add(SqList  A, SqList  B)//求和M= A+B，和M作为函数值返回
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	SqList M; int i,j,k;  
	i=j=k=0;
	while(i<A.length&&j<B.length)
		if(A.elem[i].exp>B.elem[j].exp)//若A中对应项的指数大于B中对应项的指数
		{
            ......
		}
		else if(B.elem[j].exp>A.elem[i].exp)//若B中对应项的指数大于A中对应项的指数
		{
			......
		}
		else//若A和B的对应项的指数相等
		{
			if(A.elem[i].coef+B.elem[j].coef!=0)
			{
				......
			}
			else//如果指数相等，且对应项的系数相加之和为0，则舍弃该项
			{
				......
			}
		}
	while(i<A.length)  //将A的剩余元素赋给M
	{
		......
	}
	while(j<B.length)  //将B的剩余元素赋给M
	{
		......
	}
	M.length=k;
	return M;
	/********** End **********/	
}
```"
103,3460,课程设计-基于顺序存储结构的一元多项式的计算,fzthql7pucxv,一元多项式的相减,,
104,3460,课程设计-基于顺序存储结构的一元多项式的计算,rfckgzl35ui9,一元多项式的相乘,8865,"本关任务对应的参考代码实现如下：
```cpp
SqList Multiply(SqList  A, SqList  B)//求积M= A*B，将乘积M作为函数值返回
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
    SqList C,M; int i,j,k;
	M.length=0;  //建立空表M,用来存放乘积	
	i=0;//i存放A的第1项的下标
	while(i<A.length)
	{
		//先用A的第1项乘以B，得一个多项式C1；再用A的第2项乘以B，得一个多项式C2；….。然后将得到的各个多项式相加就得最后结果，即C1+C2+…。
		j=0;//j存放B的第1项的下标
		k=0;//k存放C的第1项的下标
		while(j<B.length)
		{
			......
		}
		C.length=k;//此时得到一个多项式C
		M=Add(M,C);//将C放到M中相加		
		......
	}
	return M;	
	/********** End **********/	
}
```"
105,3551,课程设计-基于链式存储结构的一元多项式的计算,yq6fziprsgeh,一元多项式的相加,8867,"本关任务对应的参考代码实现如下：
```cpp
LinkList Add(LinkList  A, LinkList  B)//求和M= A+B，返回和M的头指针。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //多项式求和类似于将两个递减有序的线性表合并成一个递减有序的线性表。
	LinkList M; LNode *p,*q,*s,*r;
	M=(LNode *)malloc(sizeof(LNode));
	M->next=NULL; r=M;  //建立空表M,M为头指针，r为尾指针	
	p=A->next; q=B->next;//p,q分别指向A,B表中第一个结点	
	while(p!=NULL&&q!=NULL)
	{
		if(p->exp>q->exp)//A中对应项的指数大于B
		{
			......
		}
		else if(q->exp>p->exp)//B中对应项的指数大于A
		{
			......
		}
		else//指数相等
		{
			if(p->coef+q->coef!=0)
			{
				......
			}
			else//如果指数相等，且对应项的系数相加之和为0，则舍弃该项
			{
				......
			}
		}
		r->next=s; r=s;  //将新结点*s插入到M的表尾
	}
	while(p!=NULL) //将A表的剩余元素逐个复制插入到M的表尾
	{
		......
	}
	while(q!=NULL) //将B表的剩余元素逐个复制插入到M的表尾
	{
		......
	}
	r->next=NULL;//将最后一个结点的next域置空
	return M;	
	/********** End **********/
}
```"
106,3551,课程设计-基于链式存储结构的一元多项式的计算,3elcr2hf9ts6,一元多项式的相减,,
107,3551,课程设计-基于链式存储结构的一元多项式的计算,wmluynpvbkea,一元多项式的相乘,8869,"本关任务对应的参考代码实现如下：
```cpp
LinkList Multiply(LinkList  A, LinkList  B)//求积M= A*B，返回积M的头指针。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LinkList M,C; LNode *p,*q,*s,*r;
	M=(LNode *)malloc(sizeof(LNode));
	M->next=NULL;  //建立空表M,用来存放乘积	
	p=A->next; //p指向A表中第一个结点
	while(p!=NULL)
	{
		//先用A的第1项乘以B，得一个多项式C1；再用A的第2项乘以B，得一个多项式C2；….。然后将得到的各个多项式相加就得最后结果，即C1+C2+…。
		q=B->next;//q指向B表中第一个结点
		C=(LNode *)malloc(sizeof(LNode));
		C->next=NULL; r=C;  //建立空表C,C为头指针，r为尾指针
		while(q!=NULL)
		{
		  //用A的某一项乘以B，将得到的各项插入到C的表尾
			......
		}
		r->next=NULL;//将最后一个结点的next域置空，此时得到一个多项式C
		M=Add(M,C);//将C放到M中相加
		......
	}
	return M;
	/********** End **********/	
}
```"
108,3055,问题求解与实践 - C++ 回顾  ,l8yw5c4m9h6b,表达式计算,,
109,3466,第二十一章 强化学习,qxfzcj68eyl3,第二十一章 强化学习习题,,
110,3097,第二届全国高校绿色计算大赛 决赛第三阶段（C++）,nx6k3rutazhf,明天会下雨吗？,,
111,3169,第二届全国高校绿色计算大赛 决赛第二阶段（C++）,vwh2z6tokyfq,城市道路,,
112,3169,第二届全国高校绿色计算大赛 决赛第二阶段（C++）,hu896loqpmzs,字符串,,
113,2943,第二届全国高校绿色计算大赛 预赛第三阶段（C++）,xlpvys6n8z4o,学生数学成绩预测,,
114,3012,第二届全国高校绿色计算大赛 预赛第二阶段（C++）,zab98iejfryn,文本编辑器,,
115,3012,第二届全国高校绿色计算大赛 预赛第二阶段（C++）,25bqlfncsawg,运输成本,,
116,2859,程序设计部分 动态规划,abm9p5n7chrw,最长上升子序列,7241,"```
#include <iostream>
#include <algorithm>
using namespace std;

void MaxUp(int arr[],int len)
{
	/**********   Begin   **********/
	int maxLen[110];
	maxLen[1] = 1;
	for(int s = 2;s <= len;s++)
	{
		int ma = 0;
		for(int d = 0;d < s - 1;d++)
		{
			if(arr[d] < arr[s - 1])
				ma = max(maxLen[d + 1],ma);
		}
		maxLen[s] = ma + 1;
	}
	int ma = 0;
	for(int s =1;s <= len;s++)
		ma = max(maxLen[s],ma);
	cout << ma << endl;
	/**********   End   **********/
}

```"
117,2859,程序设计部分 动态规划,6flim2bzgyc3,数字三角形,7242,"```
#include <iostream>
#include <algorithm>
using namespace std;

void MaxSum(int arr[][10],int wid)
{
	/**********   Begin   **********/
	int maxSum[10];
	for(int s =0;s < wid;s++)
		maxSum[s] = arr[wid - 1][s];

	for(int s = wid - 2;s >= 0;s--)
	{
		for(int d = 0;d < s + 1;d++)
			maxSum[d] = max(maxSum[d],maxSum[d + 1]) + arr[s][d];
	}
	cout << maxSum[0] << endl;
	/**********   End   **********/
}
```"
118,2860,程序设计部分 动态规划 习题,2j6x8o7ykznq,聪明的寻宝人,7243,"```
#include <iostream>
using namespace std;


void MaxValue(int values[],int weights[],int n,int m)
{
	/**********   Begin   **********/
	int table[55][55]={};
	for (int i=1;i <= n;i++)
		for(int j=1;j <= m;j++)
		{
			if (weights[i - 1] <= j)
			{
				if (values[i - 1] + table[i-1][j-weights[i - 1]] > table[i-1][j])
					table[i][j] = values[i - 1] + table[i-1][j-weights[i - 1]];
				else
					table[i][j] = table[i-1][j];
			}
			else
				table[i][j] = table[i-1][j];
		}

	cout << table[n][m] << endl;
	/**********   End   **********/
}


```"
119,2860,程序设计部分 动态规划 习题,kle52fnvf6yw,基因检测,7244,"```
#include <iostream>
#include <algorithm>
using namespace std;

void Similar(char *str1,char *str2)
{
	/**********   Begin   **********/
    int rs = 0;
    int dp[55][55];
    for(int i = 0 ; i <= 55; i++)
        dp[i][0] = 0;
    for(int i = 0; i <= 55; i++)
        dp[0][i] = 0;
    for(int i = 1; str1[i - 1];i++) 
        for(int j = 1; str2[j - 1];j++)
        {
            if(str1[i - 1] == str2[j - 1])
            {
                dp[i][j] = dp[i -1][j - 1] + 1;
                rs = max(rs,dp[i][j]);
            }
 
            else
                dp[i][j] = 0;
        }
    cout << rs << endl;
	/**********   End   **********/
}
```"
120,2860,程序设计部分 动态规划 习题,64ksoj8bzclv,药剂稀释,7245,"```
#include <iostream>
#include <algorithm>
using namespace std;

void Cal(double arr[],int n)
{
    /**********   Begin   **********/
    int dp[105];
    for(int i=0; i<n; i++) dp[i]=1;
    for(int i=1; i<n; i++)
        for(int j=0; j<i; j++)
            if(arr[j]>=arr[i]&&dp[j]+1>dp[i])
                dp[i]=dp[j]+1;
    int maxx = 0;
    for(int i=0; i<n; i++)
        maxx=max(maxx,dp[i]);
    cout << maxx << endl;
    /**********   End   **********/
}
```"
121,2860,程序设计部分 动态规划 习题,aqefbyvo8wpf,找相似串,7246,"```
#include <iostream>
#include <cstring>
using namespace std;

void Similar()
{
	/**********   Begin   **********/
	const int maxn = 55;
	char s[maxn],t[25][maxn];
	int f[maxn][maxn]= {},ans[maxn];
	int best = maxn, sum, dis, n;


    cin >> s;
    cin >> n;
    for (int i=1; i<=n; i++)
    {
        cin >> t[i];
        for (int j=1; j<=strlen(s); j++)
            f[j][0]=j;
        for (int k=1; k<=strlen(t[i]); k++)
            f[0][k]=k;
        for (int j=1; j<=strlen(s); j++)
            for (int k=1; k<=strlen(t[i]); k++)
                if (s[j-1]==t[i][k-1])
                    f[j][k]=f[j-1][k-1];
                else if (f[j-1][k]<f[j][k-1])
                    f[j][k]=f[j-1][k]+1;
                else
                    f[j][k]=f[j][k-1]+1;
        if (best>f[strlen(s)][strlen(t[i])])
        {
            best=f[strlen(s)][strlen(t[i])];
            sum=0;
        }
        if (best==f[strlen(s)][strlen(t[i])])
        {
            sum++;
            ans[sum]=i;
        }
    }
    for (int i=1; i<=sum; i++)
        cout << t[ans[i]] <<endl;
	/**********   End   **********/
}
```"
122,2857,程序设计部分 探索式递归,tyjzi5h6xos7,下楼问题,7235,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/
int take[100];
void Try(int n,int i)
{
    for(int j=3; j>0; j--)
    {
        if(i < j) 
			continue;
        take[n]=j;
        if(i == j)
        {
            for(int k = 1;k <= n;k++)
                cout << take[k] << "" "";
            cout << endl;
        }
        else
			Try(n+1,i-j);
    }
}
void Move(int n)
{
    Try(1,n);
}
/**********   End   **********/

```"
123,2857,程序设计部分 探索式递归,5uf7vgepnfoa,字符全排列,7236,"```
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

/**********   Begin   **********/
char *in;
char out[30] = {0};
int used[30] = {0};
int length = 0;
void ranker(int n)
{
    if (n == length)
    {
        cout << out << endl;
        return;
    }
    for (int i = 0; i< length; i++)
    {
        if (!used[i])
        {
            out[n]=in[i];
            used[i] = 1;
            ranker(n+1);
            used[i] = 0;
        }
    }
}
void Cal(char *str)
{
	in = str;
	length = strlen(in);
    sort(in,in+length);
	ranker(0);
}
/**********   End   **********/
```"
124,2857,程序设计部分 探索式递归,2bxasfwpiz9t,分书问题,7237,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/
int like[5][5]={};
int book[5]={}, take[5];

void trybook(int i)
{
    if (i==5)
    {
        for (int k=0; k<=4; k++) 
            cout << take[k] + 1 << "" "";
        cout << endl;
        return;
    }

    for (int j=0; j<=4; j++)
    {
        if (like[i][j] && book[j]==0)
        {
            take[i] = j;
            book[j] = 1;
            trybook(i+1);
            book[j] = 0;
        }
    }
}
void Cal()
{
	for(int i=0; i<5; i++)
        for(int j=0; j<5; j++)
            cin >> like[i][j];
    trybook(0);
}
/**********   End   **********/

```"
125,2940,程序设计部分 复盘题（一）,pu4bzlx29veq,计算打印费用,7227,"```
#include <iostream>
using namespace std;
void Sum(int arr[],int len)
{
	/**********   Begin   **********/
	int pages = 0;
	for(int s = 0;s < len;s++)
		pages += arr[s] / 70 + (arr[s] % 70 > 0);
    printf(""%.1lf\n"",pages/10.0);
	/**********   End   **********/
}
```"
126,2940,程序设计部分 复盘题（一）,jnyig78c3fhu,跳棋游戏,7228,"```
#include <iostream>
using namespace std;

void Step(int arr[],int len)
{
	/**********   Begin   **********/
    int pos=1,cnt=1;
    while(pos < len - 1)
    {
        if(arr[pos])
        {
            cnt++;
            int next = pos + arr[pos];
			if(next < 0)
				next = 0;
			else if(next > len - 1)
				next = len - 1;
			arr[pos] = 0;
            pos = next;
        }
        else
        {
            cnt+=2;
            pos++;
        }
    }
    cout << cnt << endl;
	/**********   End   **********/
}
```"
127,2940,程序设计部分 复盘题（一）,q9j2rfizfghn,打鱼还是晒网,7229,"```
#include <iostream>
using namespace std;
/**********   Begin   **********/
bool isLeap(int y)
{
    return y%4==0&&y%100!=0||y%400==0;
}
int daysOfMonth(int y,int m)
{
    int day[12]= {31,28,31,30,31,30,31,31,30,31,30,31};
    if(m!=2)
        return day[m-1];
    else
        return 28+isLeap(y);
}

void State(int year,int mon,int day)
{
	int days = 0;
	for(int y=1990; y<year; y++)
        days += 365+isLeap(y);
    for(int m=1; m<mon; m++)
        days+=daysOfMonth(year,m);
	days += day;

    int dif= days % 5;
    if(dif <= 3 && dif >= 1)
		cout << ""Fishing"" << endl;
    else 
		cout << ""Sleeping"" << endl;
    
}
/**********   End   **********/
```"
128,2940,程序设计部分 复盘题（一）,bm8fy4glj723,最大零矩阵,7230,"```
#include <iostream>
#include <cmath>
using namespace std;
/**********   Begin   **********/
int n,m;
int pic[25][25],fro[25][25]={};
int GetMax()
{
    for(int i=0; i<n; i++)
    {
        int tmp=0;
        for(int j=m-1; j>=0; j--)
        {
            if(pic[i][j]) tmp=0;
            else fro[i][j]=++tmp;
        }
    }
    int maxx=-1;
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<m; j++)
        {
            if(!fro[i][j]) continue;
            int row=0,col=0;
            for(int k=i; k<n; k++)
            {
                if(fro[k][j])
                {
                    row++;
                    if(col==0) col=fro[k][j];
                    else col=min(col,fro[k][j]);
                    maxx=max(maxx,row*col);
                }
                else break;
            }
        }
    }
    return max(0,maxx);
}

void Zero()
{
    cin >> n >> m;
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            cin >> pic[i][j];
	cout << GetMax() << endl;
}
/**********   End   **********/
```"
129,2941,程序设计部分 复盘题（二）,t2oi9cjqwk5r,找和为K的两个元素,7231,"```
#include <iostream>
using namespace std;
void Find(int arr[],int len,int k)
{
	/**********   Begin   **********/
    for(int i=0;i<len;i++)
        for(int j=i+1;j<len;j++)
            if(arr[i]+arr[j]==k)
			{
				cout << ""Yes"" << endl;
				return;
			}
	cout << ""No"" << endl;
	/**********   End   **********/
}
```"
130,2941,程序设计部分 复盘题（二）,chzf57m9gvko,孪生素数,7232,"```
#include <iostream>
using namespace std;
/**********   Begin   **********/

int isprime(int x)
{
    if(x==1) return 0;
    if(x==2) return 1;
    for(int i=2; i*i<=x; i++)
        if(x%i==0) return 0;
    return 1;
}

void MaxPrime(int n)
{
    while(n--)
        if(isprime(n)&&isprime(n-2))
        {
            printf(""%d %d\n"",n-2,n);
            break;
        }
}
/**********   End   **********/
```"
131,2941,程序设计部分 复盘题（二）,jkhnsi2gvq9r,迷信的病人,7233,"```
#include <iostream>
#include <cstdlib>
#include <cmath>
using namespace std;
/**********   Begin   **********/
int isprime(int x)
{
    if(x==1) return 0;
    if(x==2) return 1;
    for(int i=2; i*i<=x; i++)
        if(x%i==0) return 0;
    return 1;
}

void Count(int m,int n)
{
	char arr[10];
	int cnt = 0;
    for(int i=m; i<=n; i++)
    {
        int fro= i / 1e6;
        if(!isprime(fro))
			continue;

        int bac= i % 1000;

        int sqr=(int)sqrt(bac);

        if(sqr*sqr!=bac)
			continue;
		
        bool flag = false;
        int t = i;
        for(int j=0; j<8; j++)
        {
            if(t % 100 == 13)
            {
                flag = true;
                break;
            }
            t /= 10;
        }
        if(flag)
			continue;
        cnt++;
    }
    cout << cnt << endl;
}
/**********   End   **********/
```"
132,2941,程序设计部分 复盘题（二）,zol56gfmfx2q,医院排号,7234,"```
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
/**********   Begin   **********/

int n,k,tmp;
struct ill
{
    int id;
    int val;
};
int cmp(ill a,ill b)
{
  if(a.val==b.val)
    return a.id < b.id;
  else
    return a.val > b.val;
}

void Queue(int arr[],int n,int k)
{
	ill ills[20];
    for(int i=0; i<n; i++)
    {
        ills[i].id= i + 1;
        ills[i].val=arr[i];
    }
    sort(ills,ills+n,cmp);
    int minn=min(n,k);

    cout << minn << endl;
    for(int i=0; i<minn; i++)
		cout << ills[i].id << "" "";
	cout << endl;
}
/**********   End   **********/
```"
133,2858,程序设计部分 探索式递归 习题,luq2fxbwezga,悟空救师傅,7214,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/
int n,m,sx,sy;
int pic[25][25],flag[25][25]={},success = 0;

void DFS(int x,int y)
{
    if(x<0||x>=n||y<0||y>=m) return;
    if(pic[x][y]==1||flag[x][y]) return;
    if(pic[x][y]==3)
    {
        success = 1;
        return;
    }
    flag[x][y]=1;
    DFS(x+1,y);
    DFS(x-1,y);
    DFS(x,y+1);
    DFS(x,y-1);
}
void Help()
{
	cin >> n >> m;
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
        {
			cin >> pic[i][j];
            if(pic[i][j] == 2) 
				sx=i,sy=j;
        }
    DFS(sx,sy);
    if(success)
		cout << ""Yes"" << endl;
    else 
		cout << ""No"" << endl;
}
/**********   End   **********/

```"
134,2858,程序设计部分 探索式递归 习题,6pf74wflzcig,黑白瓷砖,7216,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/
int n,m,sx,sy,ex,ey;
char pic[50][50];
int flag[50][50]={},cnt;

void DFS(int x,int y)
{
    if(x<0||x>=n||y<0||y>=m) return;
    if(pic[x][y]=='#'||flag[x][y]) return;
    cnt++;
    flag[x][y]=1;
    DFS(x+1,y);
    DFS(x-1,y);
    DFS(x,y+1);
    DFS(x,y-1);
}

void Walk()
{
	cin >> m >> n;
    for(int i=0; i<n; i++)
        cin >> pic[i];
    for(int i=0; i<n; i++)
	{
		for(int j=0; j<m; j++)
		{
            if(pic[i][j]=='@')
			{
				sx=i;
				sy=j;
			}
		}
	}
    DFS(sx,sy);
    cout << cnt << endl;
}
/**********   End   **********/

```"
135,2858,程序设计部分 探索式递归 习题,7ql4nwutyc6b,穿越迷宫,7215,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/
int n,sx,sy,ex,ey;
char pic[15][15];
int flag[15][15] = {},success = 0;

void DFS(int x,int y)
{
    if(x<0||x>=n||y<0||y>=n) return;
    if(pic[x][y]=='#'||flag[x][y]) return;
    if(x==ex&&y==ey)
    {
        success = 1;
        return;
    }
    flag[x][y]=1;
    DFS(x+1,y);
    DFS(x-1,y);
    DFS(x,y+1);
    DFS(x,y-1);
}
void Walk()
{
	cin >> n;
    for(int i=0; i<n; i++)
        cin >> pic[i];
	cin >> sx >> sy >> ex >> ey;
    if(pic[sx][sy]=='#'||pic[ex][ey]=='#') 
		success=0;
    else 
		DFS(sx,sy);
    if(success) 
		cout << ""Yes"" << endl;
    else 
		cout << ""NO"" << endl;
}
/**********   End   **********/

```"
136,2858,程序设计部分 探索式递归 习题,gp4xu3a6qb7y,有理数树,7217,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/
int tn,tm;

void DFS(int x,int y,int num)
{
    if(x>tn||y>tm) return;
    if(x==tn&&y==tm)
    {
        printf(""%d\n"",num);
        return;
    }
    DFS(x,x+y,num*2);
    DFS(x+y,y,num*2+1);
}

void Find(int n,int m)
{
	tn = n;
	tm = m;
	DFS(1,1,1);
}
/**********   End   **********/

```"
137,2756,程序设计部分 函数的递归 习题,zsjq6wu23gml,因数分解,7109,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/

int count(int a,int start)
{
	if(a <= 2)
		return 1;
	int c = 1;
	for(int s = start;s * s <= a;s++)
	{
		if(a % s == 0)
			c += count(a / s,s);
	}
	return c;
}

void Count(int a)
{
	cout << count(a,2) << endl;
}
/**********   End   **********/

```"
138,2756,程序设计部分 函数的递归 习题,zfolxi5pqhus,寻找元素,7110,"```
#include <iostream>
#include <iomanip>
using namespace std;
/**********   Begin   **********/

bool isM(int n,int k)
{
	if(n == k)
		return true;
	if(k < n)
		return isM(n,k * 2 + 1) || isM(n,k * 3 + 1);
	return false;
}

void IsM(int n,int k)
{
	if(isM(n,k))
		cout << ""Yes"" << endl;
	else
		cout << ""No"" << endl;
}
/**********   End   **********/
```"
139,2756,程序设计部分 函数的递归 习题,jt4vnr27f5si,硬币面值组合,7111,"```
#include <iostream>
#include <cstdio>
using namespace std;
/**********   Begin   **********/

int typeValues[] = {5,2,1};
int typeCounts[3];
void cal(int n,int type)
{
	if(type == 2)
	{
		if(n % typeValues[type] == 0)
		{
			typeCounts[type] += n / typeValues[type];
			printf(""%d %d %d\n"",typeCounts[2],typeCounts[1],typeCounts[0]);
			typeCounts[type] -= n / typeValues[type];
		}
		return;
	}
	for(int s = 0;s <= n / typeValues[type];s++)
	{
		typeCounts[type] += s;
		cal(n - s * typeValues[type],type + 1);
		typeCounts[type] -= s;
	}
}

void Cal(int n)
{
	typeCounts[0] = typeCounts[1] = typeCounts[2] = 0;
	cal(n,0);
}

/**********   End   **********/
```"
140,2763,程序设计部分 指针（三）,4jmtfio2agku,指针作为函数参数,6951,"```
#include <iostream>
using namespace std;

void Sum(const int *arr,int len)
{
	/**********   Begin   **********/
	if(len == 0)
	{
		cout << 0 << endl;
	}
	else
	{
		int total = 0;
		int maxSum = 0;
		int max = arr[0];
		for(int s =0;s < len;s++)
		{
			if(arr[s] == max)
				maxSum += max;
			else if(arr[s] > max)
				maxSum = max = arr[s];
			total += arr[s];
		}
		cout << total - maxSum << endl;
	}
	/**********   End   **********/
}


```"
141,2763,程序设计部分 指针（三）,ag6c2yiox4f9,指针作为函数返回值,6952,"```
#include <iostream>
using namespace std;
/**********   Begin   **********/

int arr[10];

int* Read(int *len)
{
	cin >> *len;
	for(int s = 0;s < *len;s++)
		cin >> arr[s];
	
	return arr;
}
/**********   End   **********/
```"
142,2862,程序设计部分 从现实问题到计算机程序,kwxz97crfn4f,鸡兔同笼问题,7038,"```
#include <iostream>
using namespace std;

int main()
{
	/**********   Begin   **********/
	int a; //脚的总数
	cin >> a; //读取输入
	if(a % 2 == 1)
	{
		cout << ""数据错误"" << endl;
	}
	else if(a % 4 == 0)
	{
		cout << a / 2 << endl; //输出最多的数量
		cout << a / 4 << endl; //输出最少的数量
	}
	else
	{
		cout << a / 2 << endl;
		cout << a / 4 + 1 << endl;
	}
	/**********   End   **********/
}

```"
143,2862,程序设计部分 从现实问题到计算机程序,skcai47yujv3,百元买百鸡问题,7039,"```
#include <iostream>
using namespace std;

int main()
{
	/**********   Begin   **********/
	for(int a = 0;a <= 100;a=a+1) //初始值是0，最大值是100
	{
		for(int b = 0;b <= 50;b++)
		{
			int c = 100 - a - b;
			if(c >= 0)
			{
				if(a*0.5 + b*2 + c*3 == 100)
				{
					cout << a << "" "" << b << "" "" << c << endl; //输出每种鸡的数量，用空格分隔
				}
			}
		}
	}
	

	/**********   End   **********/
}
```"
144,2862,程序设计部分 从现实问题到计算机程序,vu5tcwyf28zj,谁做了好事？,7040,"```
#include <iostream>
using namespace std;
int main()
{
	/**********   Begin   **********/
	for(int x = 0;x <= 3;x=x+1)
	{
		if((x != 0) + (x == 2) + (x == 3) + (x != 3) == 3) //加上括号是因为加法的优先级高
		{
			char al = x + 65; //char代表字符类型。使用cout输出char类型的变量，实际得到的是其值对应的字符
			cout << al << endl;
		}
	}
	/**********   End   **********/
}
```"
145,2862,程序设计部分 从现实问题到计算机程序,g9pofqwvxy2r,刑警破案,7041,"```
#include <iostream>
using namespace std;
int main()
{
	/**********   Begin   **********/
	for(int A = 0;A <= 1;A=A+1) //每一个变量的取值范围都是0到1
	for(int B = 0;B <= 1;B=B+1)
	for(int C = 0;C <= 1;C=C+1)
	for(int D = 0;D <= 1;D=D+1)
	for(int E = 0;E <= 1;E=E+1)
	for(int F = 0;F <= 1;F=F+1)
	{
		if ((A||B) + 
		((A&&E)||(A&&F)||(E&&F)) +
		!(A&&D) +
		((B&&C)||(!B&&!C)) +
		((C&!D)||(!C&&D)) +
		(!D&&!E) == 6)
		{
			cout << ""作案人："";
			if(A == 1) cout <<""A"";
			if(B == 1) cout <<""B"";
			if(C == 1) cout <<""C"";
			if(D == 1) cout <<""D"";
			if(E == 1) cout <<""E"";
			if(F == 1) cout <<""F"";
			cout << endl;
		}
	}
	/**********   End   **********/
}
```"
146,2712,文件,akwo7yfqs6if,数字统计,6626,"```c
//请修改指定区域中的程序错误实现所需功能,
//不能修改其他代码。
#include<stdio.h>
void main()
{
	//---------------错误开始--------------
	FILE *fp;
	long cnt=0;
	char c,filename[20];
    void createfile();
    createfile();
	scanf(""%s"",filename);
	fp=fopen(filename,""r"");
	while(!feof(fp))
    //---------------错误结束--------------
	{
		c=fgetc(fp);
		if(c>='0'&&c<='9')
			cnt++;
	}
	printf(""%ld"",cnt);
	fclose(fp);
}

void createfile()
{
    char s1[20]=""1921.7.1"",s2[20]=""1927.8"";
    FILE *fp;
    fp=fopen(""test.txt"",""w"");
    fputs(s1,fp);
    fclose(fp);
    
    fp=fopen(""test2.txt"",""w"");
    fputs(s2,fp);
    fclose(fp);
}
```"
147,2712,文件,kcomf9gnxaus,学生信息存档,7158,"```c
#include<stdio.h>

struct student
{   char name[10];
    float score;
};

int  main()
{
    int i;
	FILE *fp;
	struct student s;
	
	scanf(""%s%f"",s.name,&s.score);  //从键盘输入每个人的信息
	fp=fopen(""stuinfo.dat"", ""wb"");  //打开将要写入信息的文件stuinfo.dat 	
	fwrite(&s,sizeof(struct student),1,fp);//将该学生信息存储到stuinfo.dat文件中
	
    fp=fopen(""stuinfo.dat"", ""rb"");  //打开要读取信息的文件stuinfo.dat	
    fread(&s,sizeof (struct student),1,fp); //从文件读取学生信息
    fclose(fp);    //关闭文件
	printf(""%s,%2f"",s.name,s.score); //输出学生信息

	return 0;
}
```"
148,2712,文件,oirwnfegf42q,最大值,7159,"```c
#include<stdio.h>

int getmax(char *filename)
{
	int max,num;
	FILE *fp;
	fp=fopen(filename,""rb"");
	fscanf(fp,""%d"",&max);   //假设第一个数最大
	while(!feof(fp))        //后续数据“打擂”
	{
		fscanf(fp,""%d"",&num);
		if(num>max)
			max=num;
	}
	fclose(fp);	
	return max;
}
void main()
{   
    int n;
	char filename[20];
	scanf(""%s"",filename);
    n=getmax(filename);
	printf(""%d"",n);                          
}
```"
149,2861,程序设计部分 认识C/C++程序语言,oiujqvtyhp4z,Hello World!,7031,"```
/**********   Begin   **********/
#include <iostream>
using namespace std;

int main()
{
	cout << ""Hello World!"" << endl;
}

/**********   End   **********/

```"
150,2861,程序设计部分 认识C/C++程序语言,s963fmaqr8fj,程序中的变量,7032,"```
#include <iostream>
using namespace std;

int main()
{
	/**********   Begin   **********/
	int a;
	int b;
	cin >> a >> b;
	cout << a + b << endl;
	/**********   End   **********/
}

```"
151,2861,程序设计部分 认识C/C++程序语言,otnslwb7xvz3,程序的基础结构,7033,"```
#include <iostream>
using namespace std;

int main()
{
	/**********   Begin   **********/
	int n;
	cin >> n;
	for(int s = 0;s <= n;s=s+1)
	{
		if(s % 2 == 0)
		{
			cout << s << endl;
		}
	}
	/**********   End   **********/
}

```"
152,2901,数据结构与算法 - 栈,4ka2moqnvgb8,实现一个顺序存储的栈,7119,"本关任务对应参考代码实现如下：
```cpp
bool SS_IsFull(SeqStack* stack)
// 判断栈是否为满。为满返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top+1>=stack->max;

    /********** End **********/
}

bool SS_IsEmpty(SeqStack* stack)
// 判断栈是否为空。为空返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top<0;

    /********** End **********/
}

int SS_Length(SeqStack* stack)
// 获取栈元素个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top+1;

    /********** End **********/
}

bool SS_Push(SeqStack* stack, T x)
// 将元素x进栈，若满栈则无法进栈，返回false，否则返回true
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (SS_IsFull(stack)) {
        return false;
    }
    stack->top++;
    stack->data[stack->top]=x;
    return true;

    /********** End **********/
}

bool SS_Pop(SeqStack* stack, T &item)
// 出栈的元素放入item。若出栈成功(栈不为空)，则返回true；否则(空栈)，返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (SS_IsEmpty(stack)) {
        return false;
    }
    item = stack->data[stack->top];
    stack->top--;
    return true;

    /********** End **********/
}
```"
153,2901,数据结构与算法 - 栈,lwqcoy938i75,实现一个链接存储的栈,7120,"本关任务对应参考代码实现如下：
```cpp
/*判断栈是否为空*/
bool LS_IsEmpty(LinkStack* ls)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return ls->len == 0;

    /********** End **********/
}

/*获取栈的长度*/
int LS_Length(LinkStack* ls)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return ls->len;

    /********** End **********/
}

/*将x进栈*/
void LS_Push(LinkStack* ls, T x)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=(LNode*)malloc(sizeof(LNode));
    node->data=x;
    node->next=ls->top;
    ls->top = node;
    ls->len ++;

    /********** End **********/
}

/*出栈。出栈元素放入item；如果空栈，将返回false*/
bool LS_Pop(LinkStack* ls, T& item)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=ls->top;
    if (node==NULL) {
        return false;
    }
    item = node->data;
    ls->top = node->next;
    ls->len --;
    free(node);
    return true;

    /********** End **********/
}

/*读栈顶元素放入item。如果空栈，将返回false*/
bool LS_Top(LinkStack* ls, T& item)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=ls->top;
    if (node==NULL) {
        return false;
    }
    item = node->data;
    return true;

    /********** End **********/
}
```"
154,2899,数据结构与算法 - 线性表,jyiw6zc39gbf,实现一个顺序存储的线性表,7115,"本关任务对应的参考代码实现如下：
```cpp
bool SL_InsAt(SeqList* slist, int i, T x)
// 在顺序表的位置i插入结点x, 插入d[i]之前, i的有效范围[0,plist->len]
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (i<0 || i>slist->len || slist->len==slist->max) {
        printf(""SL_InsAt(): location error, or slist full.\n"");
        return false;
    }

    for (int j=slist->len; j>=i+1; j--) {
        slist->data[j]=slist->data[j-1];
    }

    slist->data[i]=x;
    slist->len++;
    return true;
    /********** End **********/
}

T SL_DelAt(SeqList* slist, int i)
// 删除顺序表plist的第i号结点。i的有效范围应在[0,plist->len)内，否则会产生异常或错误。要求返回被删除的数据元素的值。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (i<0 || i>=slist->len) {
        printf(""SL_DelAt(): location error!\n"");
        SL_Free(slist);
        exit(0);
    }

    T res=slist->data[i];

    for (int j=i; j<slist->len-1; j++) {
        slist->data[j] = slist->data[j+1];
    }

    slist->len--;
    return res;
    /********** End **********/
}

int SL_DelValue(SeqList* slist, T x)
// 删除第一个值为x的结点, 存在值为x的结点则返回结点编号, 未找到返回－1
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int i=SL_FindValue(slist, x);
    if (i>=0) SL_DelAt(slist, i);
    return i;
    /********** End **********/
}
```"
155,2899,数据结构与算法 - 线性表,gsnoxjhqt2w6,实现一个连接存储的线性表,7116,"本关任务对应的参考代码实现如下：
```cpp
bool LL_InsAfter(LinkList* llist, T x)
// 在线性表的当前位置之后插入数据元素x。空表允许插入。当前位置指针将指向新结点。若插入失败，返回false，否则返回true。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LinkNode *newNode=(LinkNode*)malloc(sizeof(LinkNode));
    if (newNode==NULL) return false;
    newNode->data=x;

    if (llist->len==0)    {
        /* 在空表中插入*/
        newNode->next=NULL;
        llist->front = llist->rear = newNode;
    }
    else if (llist->curr == llist->rear || llist->curr == NULL)	{
        /* 在尾结点后插入*/
        newNode->next = NULL;
        llist->rear->next=newNode;
        llist->pre=llist->rear;
        llist->rear=newNode;
        llist->position=llist->len;
    }
    else{
        /* 在中间位置插入*/
        newNode->next = llist->curr->next;
        llist->curr->next=newNode;
        llist->pre=llist->curr;
        llist->position ++;
    }

    /* 增加链表的大小*/
    llist->len ++;

    /* 新插入的结点为当前结点*/
    llist->curr = newNode;
    return true;
    /********** End **********/
}
```"
156,2900,数据结构与算法 - 队列,rlth2j78yvmn,实现一个顺序存储的队列,7117,"本关任务对应的参考代码实现如下：
```cpp
bool SQ_IsEmpty(SeqQueue* sq)
// 判断队列是否为空，为空返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return sq->front==sq->rear;
    /********** End **********/

}

bool SQ_IsFull(SeqQueue* sq)
// 判断队列是否为满。为满返回true,否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return sq->front==(sq->rear+1)%sq->max;
    /********** End **********/
}

int SQ_Length(SeqQueue* sq)
// 队列长度
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return (sq->rear-sq->front+sq->max) % sq->max;
    /********** End **********/
}

bool SQ_In(SeqQueue* sq, T x)
// 将x入队。若入队失败(队列满)，则返回false，否则返回true。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if ( SQ_IsFull(sq) ) {
        return false;
    }
    else {
        sq->data[sq->rear]=x;
        sq->rear=(sq->rear+1)%sq->max;
        return true;
    }
    /********** End **********/
}

bool SQ_Out(SeqQueue* sq, T& item)
// 从队列sq出队一个元素，返回时item为出队的元素的值。若出队成功(队列不为空)，则返回true，否则(队列空)，返回false，此时item不会返回有效值。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if ( SQ_IsEmpty(sq) ) {
        return false;
    }
    else {
        item=sq->data[sq->front];
        sq->front=(sq->front+1)%sq->max;
        return true;
    }
    /********** End **********/
}
```"
157,2900,数据结构与算法 - 队列,p4sqr2bfmklj,实现一个链接存储的队列,7118,"本关任务对应的参考代码实现如下：
```cpp
bool CLQ_IsEmpty(LNode* rear)
// 判断队列是否为空
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return rear->next->data==0;
    /********** End **********/
}

int CLQ_Length(LNode* rear)
// 返回队列长度，rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return rear->next->data;
    /********** End **********/
}

void CLQ_In(LNode* & rear, T x)
// 入队列, 新结点加入链表尾部。rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* n=(LNode*)malloc(sizeof(LNode));
    n->data=x;
    n->next=rear->next;
    rear->next=n;
    rear=n;
    rear->next->data++;
    /********** End **********/
}

bool CLQ_Out(LNode* & rear, T& item)
// 出队列。空队列时，返回值为false。rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (CLQ_IsEmpty(rear)) return false;

    LNode* head=rear->next->next;
    item = head->data;
    rear->next->next = head->next;
    if (head==rear) rear=rear->next;
    free(head);
    rear->next->data --;
    return true;
    /********** End **********/
}
```"
158,2903,数据结构与算法 - 字符串匹配,k5jz6xmgcwt8,实现朴素的字符串匹配,7123,"本关任务对应参考代码实现如下：
```cpp
int FindSubStr(char* t, char* p)
/*
从字符串t查找子字符串p。
字符串以数值结尾，例如p=""str"",那么p[0]='s',p[1]='t',p[2]='r',p[3]=0。
采用朴素的匹配算法，返回子字符串第一次出现的位置,例如t=""string ring"",p=""ring""，则返回2。
若没有找到，则返回-1。
*/
{
    // 请在此添加代码，补全函数FindSubStr
    /********** Begin *********/
    int i=0, j=0;
    while(p[i]!=0 && t[j]!=0) {
        if (p[i]==t[j]) {
            i ++;
            j ++;
        }
        else {
            j = j-i+1;
            i = 0;
        }
    }
    if (p[i] == 0) return j-i;
    else return -1;
    /********** End **********/
}
```"
159,2903,数据结构与算法 - 字符串匹配,m4egutwsb7n6,实现KMP字符串匹配,7124,"本关任务对应参考代码实现如下：
```cpp
void KmpGenNext(char* p, int* next)
//生成p的next数组, next数组长度大于等于字符串p的长度加1
{
	next[0]= -1;
	int k= -1;
	for (int i=1; p[i-1]!=0; i++) 
	{    
		while(k>=0&&p[k]!=p[i-1])   k=next[k];
		k=k+1;
		if (p[i]==p[k])  next[i]=next[k];
		else	next[i]=k;
	}
}

```"
160,2902,数据结构与算法 - 计算表达式,63jinu2opc58,计算中缀表达式,7121,"本关任务对应参考代码实现如下：
```cpp
double ComputeInfix(char* s)
{
    // 请在此添加代码，补全函数ComputeInfix，计算中缀表达式
    /********** Begin *********/
    int i=0;
    // 1
    LinkStack* so=LS_Create(); // 运算符栈
    LinkStack* sd=LS_Create(); //操作数栈

    // 2
    while(s[i]) {

        // 2.1
        if ('0'<=s[i] && s[i]<='9') {
            LS_Push(sd, s[i++]-48);
            continue;
        }

        // 2.2
        if(s[i]=='('||LS_IsEmpty(so)) {
            LS_Push(so, s[i++]); 
            continue;
        }

        // 2.3 
        if(s[i]==')') {
            T topitem;
            while(LS_Top(so,topitem) && topitem !='(' ) 
                compute(so, sd);
            LS_Pop(so,topitem);
            i++;
            continue;
        }

        // 2.4
        if(s[i]=='*'||s[i]=='/') {
            T c;
            LS_Top(so,c);
            if (c=='*' || c=='/') 
                compute(so, sd);
            LS_Push(so, s[i++]);
            continue;
        }

        // 2.5
        if(s[i]=='+'||s[i]=='-') {
            T topitem;
            while(LS_Top(so,topitem) && topitem !='(' ) 
                compute(so, sd);
            LS_Push(so, s[i++]);
            continue;
        }
    }

    // 3
    while(!LS_IsEmpty(so)) 
        compute(so, sd);

    T res;
    LS_Top(sd,res);

    LS_Free(so);
    LS_Free(sd);

    return res;

    /********** End **********/
}
```"
161,2902,数据结构与算法 - 计算表达式,8k5a9jbntevp,计算后缀表达式,7122,"本关任务对应参考代码实现如下：
```cpp
double ComputePostfix(char* s)
{
    // 请在此添加代码，补全函数ComputePostfix，计算后缀表达式
    /********** Begin *********/
    LinkStack* sd=LS_Create();
    int i=0;
    T k,top1,top2;
    while(s[i]) {
        switch (s[i]) {
        case '+':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top1+top2;
            LS_Push(sd,k);
            break;
        case '-':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top2-top1;
            LS_Push(sd,k);
            break;
        case '*':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top1*top2;
            LS_Push(sd,k);
            break;
        case '/':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top2/top1;
            LS_Push(sd,k);
            break;
        default:
            LS_Push(sd, (int)(s[i]-48));
        }
        i++;
    }
    T res;
    LS_Top(sd,res);
    LS_Free(sd);
    return res;

    /********** End **********/
}
```"
162,2905,数据结构与算法 - 排序,5bzxw7k9gurn,实现直接插入排序,7127,"本关任务对应参考代码实现如下：
```cpp
void DirecInsSort(int* a, int n)
// direct insert sorting
{
    int i, k;

    for (i=1; i<n; i++)   {
        // 请在此添加代码，补全函数DirecInsSort
        /********** Begin *********/
        int temp=a[i];
        //find k to insert a[i] between a[k-1] and a[k]
        k=i;
        while (k-1>=0 && temp<a[k-1]) // k>0 means k-1>=0
        {   a[k]=a[k-1];  k--;   }
        a[k]=temp;
        /********** End **********/
    }
}
```"
163,2905,数据结构与算法 - 排序,6umh5xy9r7wt,实现快速排序,7128,"本关任务对应参考代码实现如下：
```cpp
void QSort__(int* a, int low, int high)
//快速排序私有函数，供QuickSort()调用
//在a[low:high]中选择一个中心值，用该中心值将a[low:high]分割为两部分
//然后对两个部分递归地进行该操作。
{
    int i, j;
    if(low>=high) return;

    Swap(a[low], a[rand()%(high-low+1)+low]); //select a pivot randomly

    i=low; j=high;
    int temp=a[i];
    // 请在此添加代码，补全函数QSort__
    /********** Begin *********/
    while (i<j){
        while (i<j && temp<a[j]) j--;
            if(i<j)  a[i++]=a[j];
                while (i<j && a[i]<=temp) i++;
                    if(i<j)  a[j--]=a[i];
    }
    a[i]=temp;
    QSort__(a, low, i-1);
    QSort__(a, i+1, high);
    /********** End **********/
}
```"
164,2907,数据结构与算法 - 树,fgxh56ejc89z,由双遍历序列构造二叉树,7131,"```
//请在此处实现你的代码
if (i1>i2) return NULL;
     int k=0;
     while (i1+k<=i2&&pa[p1]!=ia[i1+k]) k=k+1; 
	 if(i1+k>i2) {
		 return NULL;
	 }
	 TNode* t=new TNode; 
	 t->data=pa[p1];
	 t->left=InPreToTree(pa,ia,p1+1,p1+k,i1,i1+k-1); 
	 t->right=InPreToTree(pa,ia,p1+k+1,p2,i1+k+1,i2);
     return t;
	 ```"
165,2907,数据结构与算法 - 树,bxu3hs8fjop5,打印二叉树,7132,"```
//请在此处实现你的代码
	const int W=5;
	int i,j;
	if (r==NULL) return;
	PrintTreeRootLeft(r->right, layer+1);
	for(i=1; i<layer; i++) {
		for (j=0;j<W;j++) printf(""%c"", '-');
	}
	for (j=0; j<W-1; j++) printf(""%c"",'-');
	printf(""%c\n"", r->data);
	PrintTreeRootLeft(r->left, layer+1);
```"
166,2906,数据结构与算法 - 查找,bfptox6a4yw8,实现折半查找,7129,"本关任务对应参考代码实现如下：
```cpp
int BSL_FindKey(BSeqList* blist, int key)
//在排序的顺序表中查找关键码值为key的结点，返回结点的编号
//返回值大于等于时表示找到值为key的结点的编号，-1表示没有找到
{
    // 请在此添加代码，补全函数BSL_FindKey
    /********** Begin *********/
    int k, r, m;
    k=0; r=blist->len-1;
    while (k<=r) {
        m=(k+r)>>1; //m=(k+r)/2
        if (key==blist->pkey[m]) return m;
        else
            if (key<blist->pkey[m])  r=m-1;
            else k=m+1;
    }
    return -1;
    /********** End **********/
}
```"
167,2906,数据结构与算法 - 查找,zf4eo96hl7qb,实现散列查找,7130,"本关任务对应参考代码实现如下：
```cpp
bool ILH_InsKey(LHTable* pt, int x)
//插入关键码x
//返回true，表示插入成功
//返回false，表示插入失败(关键码已经存在)
{
    // 请在此添加代码，补全函数ILH_InsKey
    /********** Begin *********/
    int d=x%pt->n;
    if (pt->pn[d].key==0) {
        pt->pn[d].key=x;
        return true;
    }
    else if (pt->pn[d].key==x) 
        return false;

    HNode* prev=&(pt->pn[d]);
    HNode* curr=pt->pn[d].next;
    while (curr && curr->key!=x) {prev=curr; curr=curr->next;}

    if (curr) return  false;

    HNode* pnode=(HNode*)malloc(sizeof(HNode));
    pnode->key=x;
    pnode->next=NULL;//pt->pn[d].next;
    prev->next=pnode;
    return true;
    /********** End **********/
}

bool ILH_DelKey(LHTable* pt, int x)
//删除关键码
//返回true表示该关键码存在，且成功删除
//返回false表示该关键码不存在
{
    // 请在此添加代码，补全函数ILH_DelKey
    /********** Begin *********/
    int d=x%pt->n;//关键码x的散列值d
    if (pt->pn[d].key==0) {
        return false;
    }
    else if (pt->pn[d].key==x)  {
        if (pt->pn[d].next ==NULL) 
            pt->pn[d].key=0;
        else {
            HNode* first=pt->pn[d].next;
            pt->pn[d].key=first->key;
            pt->pn[d].next=first->next;
            free(first);
        }
        return true;
    }
    HNode* prev=&(pt->pn[d]);
    HNode* curr=pt->pn[d].next;
    while (curr && curr->key!=x) {prev=curr; curr=curr->next;}
    if (curr==NULL) return false;
    prev->next=curr->next;
    free(curr);
    return true;
    /********** End **********/
}

```"
168,2908,数据结构与算法 - 图,kibm2p79wflv,实现图的宽度优先遍历,7133,"```
	while (QueueNotEmpty) {
		Out__(parent, curr); 
		if (visited[curr]) continue;
		visited[curr]=1;
		tree[k].from=parent; tree[k].to=curr; k++;
		int j;
		for (j=0; j<=g->n-1;j++) {
			if (HasEdge(curr,j) && !visited[j])In__(curr,j);
		}

	}
```"
169,2908,数据结构与算法 - 图,2xb7p8rjzitk,实现图的深度优先遍历,7134,"```
/*请在BEGIN和END之间实现你的代码*/
/*****BEGIN*****/
const int MAX=1000;
	Edge stack[MAX];
	int top=-1;
#define Push__(a,b)  {top++; stack[top].from=a; stack[top].to=b;}////
#define Pop__(a,b)  {a=stack[top].from; b=stack[top].to; top--;}///////
#define StakNotEmpty (top>=0?1:0)////
#define HasEdge(i,j)  (g->adj[(i)*g->n+(j)]==1)

	char* visited=(char*)malloc(sizeof(char)*g->n);
	memset(visited, 0, sizeof(char)*g->n);

	int parent=-1;  
	int curr=start;
	Push__(parent, curr); 
	int k=0; //已经访问的结点数
	while (StakNotEmpty) {
		Pop__(parent, curr); 
		if (visited[curr]) continue;
		visited[curr]=1;
		tree[k].from=parent; tree[k].to=curr; k++;
		int j;
		for (j=g->n-1; j>=0; j--) {
			if (HasEdge(curr,j) && !visited[j]) Push__(curr,j);
		}

	}
	free(visited);
	return k;
#undef Push__////////////
#undef Pop__///////////////
#undef StakNotEmpty//////////////
#undef HasEdge
/*****END*******/
```"
170,2817,程序设计部分 链表,2t74kuy5flnf,动态内存分配,7022,"```
#include <iostream>
#include <cstring>
using namespace std;

char* Concat(char *str1,char *str2)
{
	/**********   Begin   **********/
	int len = strlen(str1) + strlen(str2);
	
	char *tar = new char[len];
	
	char *ptr = tar;
	while(*str1)*ptr++ = *str1++;
	while(*str2)*ptr++ = *str2++;
	*ptr = 0;
	
	return tar;
	/**********   End   **********/
}


```"
171,2817,程序设计部分 链表,62pktevbjyro,链表,7023,"```
#include <iostream>
using namespace std;

struct Node //链表节点的声明，不要改动
{
	int data;
	Node *next;	
};


Node* Create(int arr[],int len)
{
	/**********   Begin   **********/
	if(len == 0)
		return 0;
	
	Node *head = new Node;
	head->data = arr[0];
	head->next = 0;

	Node *ptr = head;

	for(int s = 1;s < len;s++)
	{
		ptr->next = new Node;
		ptr = ptr->next;
		ptr->data = arr[s];
		ptr->next = 0;
	}

	return head;
	/**********   End   **********/
}
```"
172,2817,程序设计部分 链表,3q8if7pbafog,单向链表操作,7024,"```
#include <iostream>
using namespace std;

struct Node //链表节点的声明，不要改动
{
	int data;
	Node *next;	
};

/**********   Begin   **********/

//可在此增加内容

Node* Delete(Node *head,int n)
{
	if(head == 0)
		return head;

	Node *ptr = head;

	while(ptr->next) 
    {
        if(ptr->next->data == n)
        {
			Node *tmp = ptr->next;
			ptr->next = ptr->next->next;
			delete tmp;
		}
		else
		{
        	ptr = ptr->next;
		}
    }

	while(head && head->data == n)
	{
		Node *tmp = head;
		head = head->next;
		delete tmp;
	}
	return head;
}
/**********   End   **********/
```"
173,2817,程序设计部分 链表,zyrklnc3t5xe,双向链表,7025,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/

struct Node
{
	char c;
	Node *prev;
	Node *next;
};


Node* insertBefore(Node *next,Node *n)
{
	if(next == 0)
		return n;

    Node *prev = next->prev;

    n->next = next;
    n->prev = prev;

    next->prev = n;
    if(prev != 0)
        prev->next = n;
    
    return n;
}


void Conv(char *input)
{
	Node *tail = new Node{};
	Node *ptr = tail,*head = tail;
	for(int s =0;input[s];s++)
	{
		if(input[s] == '<')
		{
			if(ptr && ptr->prev)
				ptr = ptr->prev;
		}
		else if(input[s] == '>')
		{
			if(ptr && ptr->next)
				ptr = ptr->next;
		}
		else
		{
			ptr = insertBefore(ptr,new Node{input[s]});
			if(ptr->prev == 0)
				head = ptr;
			ptr = ptr->next;
		}
	}
	while(head)
	{
		if(head->c)
			cout << head->c;
		Node *next = head->next;
		delete head;
		head = next;	
	}
	cout << endl;
}
/**********   End   **********/
```"
174,2818,程序设计部分 链表 习题,k5lztocjvrsy,数字7游戏,7027,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/
struct Node
{
	int id;
	Node *next;
};

void Select(int n)
{
	Node *ptr = new Node{1};
	Node *ins = ptr;
	for(int s = 1;s < n;s++)
	{
		ins->next = new Node{s + 1};
		ins = ins->next;
	}
	ins->next = ptr;

	int num = 1;
	while(ptr->next != ptr)
	{
		int next = num + 1;
		if(next % 7 == 0 || 
			next % 10 == 7 || next / 10 % 10 == 7 || next / 100 == 7)
		{
			Node *tmp = ptr->next;
			ptr->next = ptr->next->next;
			cout << tmp->id << endl;
			delete tmp;
		}
		else
		{
			ptr = ptr->next;
		}
		num++;
	}
	cout << ptr->id << endl;
}
/**********   End   **********/

```"
175,2818,程序设计部分 链表 习题,87g3xefyjcva,建立有序链表,7028,"```
#include <iostream>
using namespace std;

struct Node
{
	int data;
	Node *next;
};

/**********   Begin   **********/

Node* Build()
{
	Node hn = {};

	int n;
	cin >> n;
	for(int s =0;s < n;s++)
	{
		int t;
		cin >> t;

		Node *ptr = &hn;
		while(ptr->next && ptr->next->data <= t)
			ptr = ptr->next;
		
		ptr->next = new Node{t,ptr->next};

	}
	return hn.next;
}
/**********   End   **********/
```"
176,2818,程序设计部分 链表 习题,uhw2qks76m54,优先队列,7029,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/

struct Node
{
	int data;
	Node *next;
};

void insert(Node *head,int data)
{
	while(head->next && head->next->data <= data)
		head = head->next;
	head->next = new Node{data,head->next};
}
void Min()
{
	Node fn = {};
	
	int n,m;
	cin >> n >> m;
	for(int s =0 ;s < n;s++)
	{
		int t;
		cin >> t;
		insert(&fn,t);
	}

	for(int s =0;s < m;s++)
	{
		char cmd[10];
		cin >> cmd;
		if(cmd[0] == 'a')
		{
			int t;
			cin >> t;
			insert(&fn,t);
		}
		else
		{
			if(fn.next)
			{
				cout << fn.next->data << endl;
				Node *tmp = fn.next;
				fn.next = fn.next->next;
				delete tmp;
			}
			else
			{
				cout << ""null"" << endl;
			}
		}
	}

	Node *ptr = fn.next;
	while(ptr)
	{
		Node *next = ptr->next;
		delete ptr;
		ptr = next;
	}
}
/**********   End   **********/
```"
177,2764,程序设计部分 指针（三） 习题,ipulb8r7g93k,亲朋字符串,6955,"```
#include <iostream>
using namespace std;

void Conv(char *str)
{
	/**********   Begin   **********/

	char *ptr = str;
	while(ptr[1] != 0)
	{
		cout << (char)(ptr[0] + ptr[1]);
		ptr++;
	}
	cout << (char)(str[0] + ptr[0]) << endl;
	/**********   End   **********/
}


```"
178,2764,程序设计部分 指针（三） 习题,syzrf3kc6aeo,排队游戏,6956,"```
#include <iostream>
using namespace std;

void Pair(char *str)
{
	/**********   Begin   **********/
	char *ptr = str;
    while (true)
    {
        while(*ptr != ')' && *ptr != '\0') ptr++;
        if(*ptr == '\0')
            break;

        *ptr = ' ';
        int r = ptr - str;

        while(*ptr != '(' && *ptr != '\0') ptr--;
        *ptr = ' ';

        cout << ptr - str << "" "" << r << endl;
    }
	/**********   End   **********/
}
```"
179,2816,程序设计部分 结构体 习题,65fojp47ufth,单词统计,6981,"```
#include <iostream>
#include <cstring>
using namespace std;
/**********   Begin   **********/

struct Word
{
	int count;
	char word[21];
};


void Count(char *text)
{
	Word ws[101]={};
	int wc = 0;

	char buf[21];
	int blen = 0;
	while(true)
	{
		if('a' <= *text && *text <= 'z' || 
		   'A' <= *text && *text <= 'Z')
		   {
			   buf[blen++] = *text;
		   }
		else
		{
			if(blen > 0)
			{
				bool found = false;
				buf[blen] = 0;
				for(int s = 0;s < wc;s++)
				{
					if(strcmp(buf,ws[s].word) == 0)
					{
						ws[s].count++;
						found = true;
						break;
					}
				}

				if(!found)
				{
					ws[wc].count = 1;
					strcpy(ws[wc].word,buf);
					wc++;
				}
			}
			blen = 0;
			if(*text == 0)
				break;
		}
		text++;
	}
	for(int s =0;s < wc;s++)
	{
		cout << ws[s].word << "" "" << ws[s].count << endl;
	}
}

/**********   End   **********/
```"
180,2816,程序设计部分 结构体 习题,gjz26ly7mowa,一种等价类划分问题,6982,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/

struct Group
{
	int kk;
	int count;
	int num[80];
};

void Div(int m,int n,int k)
{
	Group gs[15];
	int gc = 0;
	for(int s = m + 1;s < n;s++)
	{
		int sum = s % 10 + s / 10 % 10 + s / 100;
		if(sum % k != 0)
			continue;
		
		bool found = false;
		for(int d = 0;d < gc;d++)
		{
			if(gs[d].kk == sum)
			{
				gs[d].num[gs[d].count++] = s;
				found = true;
				break;
			}
		}
		if(!found)
		{
			gs[gc].count = 1;
			gs[gc].kk = sum;
			gs[gc].num[0] = s;
			gc++;
		}
	}
	for(int s =0;s < gc;s++)
	{
		for(int d = 0;d < gs[s].count;d++)
			cout << gs[s].num[d] << "" "";
		cout << endl;
	}
}
/**********   End   **********/
```"
181,2816,程序设计部分 结构体 习题,me9y73glifhk,距离排序,6983,"```
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
/**********   Begin   **********/

struct Point
{
	int x;
	int y;
	int z;
};

struct Line
{
	Point A;
	Point B;
	double dis;
};

double getDis(Point p1,Point p2)
{
	int dx = p1.x - p2.x;
	int dy = p1.y - p2.y;
	int dz = p1.z - p2.z;
	return dx * dx + dy * dy + dz * dz;
}


void Sort()
{
	int n;
	Point ps[10];
	cin >> n;
	for(int s =0;s < n;s++)
		cin >> ps[s].x >> ps[s].y >> ps[s].z;

	Line ls[50];
	int lc = 0;
	for(int s =0;s < n;s++)
	{
		for(int d = s + 1;d < n;d++)
		{
			ls[lc].A = ps[s];
			ls[lc].B = ps[d];
			ls[lc].dis = getDis(ps[s],ps[d]);
			lc++;
		}
	}

	for(int s = 0;s < lc;s++)
	{
		for(int d = 1;d < lc - s;d++)
		{
			if(ls[d].dis > ls[d - 1].dis)
			{
				Line l = ls[d];
				ls[d] = ls[d - 1];
				ls[d - 1] = l;
			}
		}
	}

	for(int s =0;s < lc;s++)
	{
		printf(""(%d,%d,%d)-(%d,%d,%d)=%0.2lf\n"",
			ls[s].A.x,ls[s].A.y,ls[s].A.z,
			ls[s].B.x,ls[s].B.y,ls[s].B.z,
			sqrt(ls[s].dis));
	}
}
/**********   End   **********/
```"
182,2815,程序设计部分 结构体,5g9qf6azv4bj,结构体,6975,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/


struct Student
{
	char id[6];
	int mon;
	int day;
}stu[50];

void Count()
{
	int n, count[100]={0}; 
	cin>>n; 
	for(int i=0; i<n; i++) 
		cin>>stu[i].id >> stu[i].mon>> stu[i].day;

	for(int m=1; m <= 12; m++)
	{
		for(int d=1; d<=31; d++) 
		{ 
			int c = 0;
			for(int i=0; i<n; i++)
			{
				if (stu[i].mon == m && stu[i].day == d) 
				{
					count[c++] = i; 
				}
			}
				 
			if(c > 1) //count[j]用于记录生日相同同学的学号 
			{ 
				cout << m << "" ""<< d <<"" ""; 
				for(int k=0; k < c; k++) 
					cout<< stu[count[k]].id << "" "";
				cout << endl;
			}
		}
	}
}
/**********   End   **********/


```"
183,2815,程序设计部分 结构体,qf3xbf46eyzu,共用体,6976,"```
#include <iostream>
using namespace std;
/**********   Begin   **********/

union RoomID
{
	struct
	{
		char build;
		char floor;
		char room;
	};
	char id[4];
};

/**********   End   **********/
```"
184,2815,程序设计部分 结构体,erfzfhybo4pw,枚举类型,6977,"```
#include <iostream>
using namespace std;
/**********   Begin   **********/

enum WeekDay 
{
    Sun = 7,
    Mon = 1,
    Tue,
    Wed,
    Thu,
    Fri,
    Sat
};

void Sum()
{
	float pre = 0;
	cin >> pre;
	int n;
	cin >> n;

	float sum = 0;
	for(int s = 0;s < n;s++)
	{
		int d,t;
		cin >> d >> t;
		switch ((WeekDay)d)
		{
		case Sat:
			sum += t * 1.5f * pre;
			break;
		case Sun:
			sum += t * 2 * pre;
			break;
		default:
			sum += t * pre;
			break;
		}
	}
	cout << sum << endl;
}
/**********   End   **********/
```"
185,2762,程序设计部分 指针（二） 习题,h5lsqwnibr29,矩阵乘法,6936,"```
#include <iostream>
using namespace std;

void Mul()
{
	int a[10][10],b[10][10];
	int n,m,k;
	/**********   Begin   **********/
	cin >> n >> m >> k;

	for(int s = 0;s < n;s++)
	{
		for(int d = 0;d < m;d++)
			cin >> *(*(a + s) + d);
	}

	for(int s = 0;s < m;s++)
	{
		for(int d = 0;d < k;d++)
			cin >> *(*(b + s) + d);
	}
	

	for(int s = 0;s < n;s++)
	{
		for(int d = 0;d < k;d++)
		{
			int sum = 0;
			for(int f = 0;f < m;f++)
				sum += *(*(a + s) + f) * *(*(b + f) + d);
			cout << sum << "" "";
		}
		cout << endl;
	}
	/**********   End   **********/
}


```"
186,2762,程序设计部分 指针（二） 习题,rm7fw2vqlkju,字符串p型编码,6937,"```
#include <iostream>
using namespace std;

void P(char *str)
{
	/**********   Begin   **********/
	char cur = -1;
	int c = 0;
	while(true)
	{
		if(*str != cur)
		{
			if(c > 0)
				cout << c << cur;
			cur = *str;
			c = 1;
		}
		else
		{
			c++;
		}
		
		if(*str == 0)
			break;
		str++;
	}
	cout << endl;
	/**********   End   **********/
}
```"
187,2761,程序设计部分 指针（二）,qpton8iv2uc5,字符串与指针,6934,"```
#include <iostream>
#include <cstring>
using namespace std;

/**********   Begin   **********/

void rev(char *start,char *end)
{
    while(start < end)
    {
        char t = *start;
        *start = *end;
        *end = t;
		start++;
		end--;
    }
}

void Shift(char *str,int n)
{
    int len = strlen(str);
	n = n % len;
    rev(str,str + n - 1);
    rev(str + n, str + len - 1);
    rev(str,str + len - 1);
	cout << str << endl;
}
/**********   End   **********/



```"
188,2761,程序设计部分 指针（二）,eu5tgb3i9vfm,指针与二维数组,6935,"```
#include <iostream>
using namespace std;

void Add()
{
	/**********   Begin   **********/
	int r,c,ma[5][5];
	int (*ptr)[5] = ma;
    cin >> c >> r;

	for(int i = 0;i < c;i++)
    {
        for(int j = 0;j < r;j++)
        {
            cin >> *(*(ptr + i) + j);
        }
    }
    for(int i = 0;i < c;i++)
    {
        for(int j = 0;j < r;j++)
        {
            int t;
            cin >> t;
            *(*(ptr + i) + j) += t;
        }
    }

    for(int i = 0;i < c;i++)
    {
        for(int j = 0;j < r;j++)
            cout << *(*(ptr + i) + j) << "" "";
        cout << endl;
    }

	/**********   End   **********/
}
```"
189,2755,程序设计部分 函数的递归,wqkrumxb6hnv,函数的递归,6744,"```
#include <iostream>
using namespace std;

void Reverse(int n)
{
	/**********   Begin   **********/
	cout << n % 10;
	int t = n / 10;
	if(!t)
	{
		cout << endl;
		return;
	}
	Reverse(t);
	/**********   End   **********/
}




```"
190,2755,程序设计部分 函数的递归,yu96nq5lt2jg,用递归实现递推,6745,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/

int fib_rec(int n)
{
	if(n == 1 || n == 2)
		return 1;
	return fib_rec(n - 1) + fib_rec(n - 2);
}

void Fib(int n)
{
	cout << fib_rec(n) << endl;
}
/**********   End   **********/
```"
191,2755,程序设计部分 函数的递归,46tpqribsxlf,使用递归模拟连续发生的动作,6746,"```
#include <iostream>
using namespace std;

/**********   Begin   **********/

void conv_rec(int n,int k)
{
	int t = n / k;
	if(t)
		conv_rec(t,k);
	cout << n % k;
}

void Conv(int n,int k)
{
	conv_rec(n,k);
	cout << endl;
}
/**********   End   **********/

```"
192,2755,程序设计部分 函数的递归,s23huqrkml5t,使用递归进行自动分析,6747,"```
#include <iostream>
using namespace std;
/**********   Begin   **********/

float cal_rec()
{
	char str[2];
	cin >> str;
	switch (str[0])
	{
		case '+':
			return cal_rec() + cal_rec();
		case '-':
			return cal_rec() - cal_rec();
		case '*':
			return cal_rec() * cal_rec();
		case '/':
			return cal_rec() / cal_rec();
		default:
			return str[0] - '0';
	}
}

void Cal()
{
	cout << cal_rec() << endl;
}

/**********   End   **********/
```"
193,2830,面向对象程序设计 上机考试,np8is7gcfov9,偶数类的设计,,
194,2830,面向对象程序设计 上机考试,nmj6folfpire,设计银行账户类,,
195,2830,面向对象程序设计 上机考试,f42iokmy3n56,分数的加法,,
196,2758,程序设计部分 指针（一） 习题,r4wj39zqgt6b,解密字符串,6891,"```
#include <iostream>
using namespace std;

/**********   gegin   **********/


void rolling(char *str,int n,int *g,char *b,int gc)
{
	int st = (gc - (n % gc)) % gc;
	for(int s =0;s < gc;s++)
	{
		str[g[s]] = b[st];
		st = (st + 1) % gc;
	}
}

void Dec(char *str,int n1,int n2,int n3)
{
	int g1[25],g2[25],g3[25];
	char b1[25],b2[25],b3[25];
	int gc1 = 0,gc2 = 0,gc3 = 0;

	for(int s =0;str[s] != 0;s++)
	{
		if(str[s] <= 'i' && str[s] >= 'a')
		{
			g1[gc1] = s;
			b1[gc1] = str[s];
			gc1++;
		}
		else if(str[s] <= 'r' && str[s] >= 'j')
		{
			g2[gc2] = s;
			b2[gc2] = str[s];
			gc2++;
		}
		else if((str[s] <= 'z' && str[s] >= 's') || str[s] == '_')
		{
			g3[gc3] = s;
			b3[gc3] = str[s];
			gc3++;
		}
	}

	if(gc1 > 0)
	{
		rolling(str,n1,g1,b1,gc1);
	}
	if(gc2 > 0)
	{
		rolling(str,n2,g2,b2,gc2);
	}
	if(gc3 > 0)
	{
		rolling(str,n3,g3,b3,gc3);
	}
	cout << str << endl;
}
/**********   End   **********/
```"
197,2758,程序设计部分 指针（一） 习题,fmnxa9irpb4y,字符串最大跨距,6892,"```
#include <iostream>
#include <cstring>
using namespace std;

void Max(char *s,char *s1,char *s2)
{
	/**********   Begin   **********/
	int pos = 0,l1 = 0;
	while(s1[l1] != 0 && s[pos] != 0)
	{
		if(s1[l1] == s[pos])
			l1++;
		else
			l1 = s1[0] == s[pos];
		pos++;
	}
	if(s1[l1])
	{
		cout << -1 << endl;
		return;
	}


	int pos2 = strlen(s) - 1,end2 = strlen(s2) - 1;
	int l2 = end2;
	while(pos2 >= 0 && l2 >=0)
	{
		if(s2[l2] == s[pos2])
			l2--;
		else
			l2 = end2 - s2[end2] == s2[pos2];
		pos2--;
	}
	if(l2 >= 0 || pos2 < pos)
	{
		cout << -1 << endl;
	}
	else
	{
		cout << pos2 - pos + 1 << endl;
	}
	/**********   End   **********/
}
```"
198,2757,程序设计部分 指针（一）,ywmkupocfxqg,指针的使用,6893,"```
#include <iostream>
using namespace std;

void Max(int *a,int *b,int *c)
{
	/**********   Begin   **********/
	if(*a > *b)
	{
		int t = *a;
		*a = *b;
		*b = t;
	}
	if(*b > *c)
	{
		int t = *c;
		*c = *b;
		*b = t;
	}
	if(*a > *b)
	{
		int t = *b;
		*b = *a;
		*a = t;
	}
	/**********   End   **********/
}


```"
199,2757,程序设计部分 指针（一）,n4fotqi95zep,指针运算,6894,"```
#include <iostream>
using namespace std;
void Reverse(int *start,int *end)
{
	/**********   Begin   **********/
	while(start < end)
	{
		int t = *start;
		*start = *end;
		*end = t;
		start++;
		end--;
	}
	/**********   End   **********/
}
```"
200,2757,程序设计部分 指针（一）,qec7xkrot6b8,指针与数组,6895,"```
#include <iostream>
using namespace std;

void Split(int *arr,int len)
{
	/**********   Begin   **********/
	int* start = arr;
	int* end = arr + len - 1;
	while(true)
	{
		while(start < end && *start == 0) start++;
		while(start < end && *end == 1) end--;
		if(start < end)
		{
			int t = *start;
			*start = *end;
			*end = t;
		}
		else
			break;
	}
	/**********   End   **********/
}
```"
201,2794,Akari回溯思考题（开放性实验）,2fvw9p8qz6rs,串行算法复杂度分析,,
202,2794,Akari回溯思考题（开放性实验）,guscxo374j9t,分析并行实现的正确性,,
203,2794,Akari回溯思考题（开放性实验）,cp6n9h2j47bg,大数场景分析,,
204,2794,Akari回溯思考题（开放性实验）,i7hncytw843j,并行优化方案设计,,
205,2833,C++第17周上机练习：多态性与虚函数,e9h3ofx5sml2,动物世界,,
206,2833,C++第17周上机练习：多态性与虚函数,g7vb95kj2cqn,几何图形的面积,,
207,2760,Akari 问题求解,ysqbmuj6oan9,使用回溯法解决 Akari 问题,6752,"```cpp
# include <bits/stdc++.h>
# include ""akari.h""
using namespace std;

namespace aka{


const int N = 250;

struct BlackAround{
    int x, y;
    bool flag;
};

struct BlackCell{
    int x, y;
};

vector<BlackAround> point;
vector<BlackCell> bcell;
vector<vector<int> > gg, ff;
bool vis[N][N], connect[N][N], light[15][15];
int n, m;

bool checking(int now)
{
    int ps[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
        int dx = point[now].x + ps[i][0], dy = point[now].y + ps[i][1];
        if (dx >= 0 && dx < n && dy >= 0 && dy < m && gg[dx][dy] == 0) return false;
    }
    return true;
}
void do_undo(int now, int delta)
{
    int ps[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
        int dx = point[now].x + ps[i][0], dy = point[now].y + ps[i][1];
        if (dx >= 0 && dx < n && dy >= 0 && dy < m && gg[dx][dy] >= 0) gg[dx][dy] += delta;
    }
}
bool check(int x, int y) {
    int ps[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
        int dx = x + ps[i][0], dy = y + ps[i][1];
        if (dx >= 0 && dx < n && dy >= 0 && dy < m && ff[dx][dy] >= 0) return false;
    }
    for (int k = x + 1; k < n; ++k) {
        if (light[k][y] == true) return false;
        if (ff[k][y] != -2) break;
    }
    for (int k = x - 1; k >= 0; --k) {
        if (light[k][y] == true) return false;
        if (ff[k][y] != -2) break;
    }
    for (int k = y + 1; k < m; ++k) {
        if (light[x][k] == true) return false;
        if (ff[x][k] != -2) break;
    }
    for (int k = y - 1; k >= 0; --k) {
        if (light[x][k] == true) return false;
        if (ff[x][k] != -2) break;
    }
    return true;
}

bool determine_light_cell (int x, int y)
{
    if (x == n) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (ff[i][j] != -2 || light[i][j] == true) continue;
                bool mark = false;
                for (int k = i + 1; k < n; ++k) {
                    if (light[k][j] == true) {mark = true; break;}
                    if (ff[k][j] != -2) break;
                }
                if (mark == true) continue;
                for (int k = i - 1; k >= 0; --k) {
                    if (light[k][j] == true) {mark = true; break;}
                    if (ff[k][j] != -2) break;
                }
                if (mark == true) continue;
                for (int k = j + 1; k < m; ++k) {
                    if (light[i][k] == true) {mark = true; break;}
                    if (ff[i][k] != -2) break;
                }
                if (mark == true) continue;
                for (int k = j - 1; k >= 0; --k) {
                    if (light[i][k] == true) {mark = true; break;}
                    if (ff[i][k] != -2) break;
                }
                if (mark == false) return false;
            }
        }
        return true;
    }
    if (light[x][y] == true || ff[x][y] != -2) {
        return determine_light_cell(y == m - 1 ? x + 1 : x, y == m - 1 ? 0 : y + 1);
    }
    else {
       if (check(x, y) == true) {
            light[x][y] = true;
            if (determine_light_cell(y == m - 1 ? x + 1 : x, y == m - 1 ? 0 : y + 1) == true)
                return true;
            light[x][y] = false;
       }
       return determine_light_cell(y == m - 1 ? x + 1 : x, y == m - 1 ? 0 : y + 1);
    }
}
bool determine_black_cell_around(int now)
{
    if (now == (int)point.size()) {
        for (int i = 0; i < (int)bcell.size(); ++i) if (gg[bcell[i].x][bcell[i].y] != 0) return false;
        memset(light, false, sizeof(light));
        for (int i = 0; i < (int)point.size(); ++i) {
            if (point[i].flag == true) light[point[i].x][point[i].y] = true;
        }
        bool flag = determine_light_cell(0, 0);
        return flag;
    }
    if (checking(now)) {
        bool mark = false;
        for (int i = 0; i < now; ++i) {
            if (point[i].flag == true && connect[i][now] == true) {mark = true; break;}
        }
        if (mark == false) {
            point[now].flag = true;
            do_undo(now, -1);
            if (determine_black_cell_around(now + 1) == true) return true;
            point[now].flag = false;
            do_undo(now, 1);
        }
    }
    return determine_black_cell_around(now + 1);
}

vector<vector<int> >  solveAkari(vector<vector<int> > & g)
{
    // 请在此函数内返回最后求得的结果
    n = (int)g.size(); m = (int)g[0].size();
    int ps[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    for (int i = 0; i < n; ++i) {
        gg.push_back(vector<int>()); ff.push_back(vector<int>());
        for (int j = 0; j < m; ++j) {
            gg[i].push_back(g[i][j]); ff[i].push_back(g[i][j]);
            if (g[i][j] >= 0 && g[i][j] <= 4) {
                bcell.push_back(BlackCell{i, j});
                for (int k = 0; k < 4; ++k) {
                    int dx = i + ps[k][0], dy = j + ps[k][1];
                    if (dx >= 0 && dx < n && dy >= 0 && dy < m && g[dx][dy] == -2 && vis[dx][dy] == false) {
                        point.push_back(BlackAround{dx, dy, false});
                        vis[dx][dy] = true;
                    }
                }
            }
        }
    }
    int siz = (int)point.size();
    for (int i = 0; i < siz; ++i) {
        for (int j = i + 1; j < siz; ++j) {
            if (point[i].x == point[j].x) {
                bool mark = false;
                for (int k = min(point[i].y, point[j].y)+1; k <= max(point[i].y, point[j].y)-1; ++k) {
                    if (gg[point[i].x][k] >= -1) {mark = true; break;}
                }
                if (mark == false) connect[i][j] = true;
            }
            else if (point[i].y == point[j].y) {
                bool mark = false;
                for (int k = min(point[i].x, point[j].x)+1; k <= max(point[i].x, point[j].x)-1; ++k) {
                    if (gg[k][point[i].y] >= -1) {mark = true; break;}
                }
                if (mark == false) connect[i][j] = true;
            }
        }
    }
    determine_black_cell_around(0);
    for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) if (light[i][j] == true) ff[i][j] = 5;
    return ff;
}

}
```"
208,2760,Akari 问题求解,y6ph5qi9zsn8,使用并行回溯法求解Akari问题,,
209,2760,Akari 问题求解,cmofli7zrjuk,使用改进的并行回溯法求解Akari问题,,
210,2780,斐波那契数列计算思考题,g9fusjpa3b4r,串行算法复杂度分析,,
211,2780,斐波那契数列计算思考题,54u3zqjt2e8y,分析并行实现的正确性,,
212,2780,斐波那契数列计算思考题,7lcnpqx6u5kj,大数场景分析,,
213,2780,斐波那契数列计算思考题,26c5zjqhev4y,并行优化方案设计,,
214,2785,程序设计二（面向对象）_实训2_构造函数,hbl85tcvwxye,为类提供默认构造函数,,
215,2785,程序设计二（面向对象）_实训2_构造函数,6gunxajy8lv3,为类提供拷贝构造函数,,
216,2785,程序设计二（面向对象）_实训2_构造函数,cgf5uvoan3ij,为类提供功能构造函数,,
217,2785,程序设计二（面向对象）_实训2_构造函数,xonz53rqfa8c,为类提供构造函数重载,,
218,2786,程序设计二（面向对象）_实训7_赋值运算符重载,9z2tl74g58me,拷贝赋值运算符重载,6825,"```cpp
/**
 * 这是一个包装类(wrapper class)，包装类在C++中有点小小的用处(基本上没用)，在Java中的用处更大一些。
 */
#ifndef _INT_H_  //这是define guard 
#define _INT_H_  //在C和C++中，头文件都应该有这玩意 

class Int{
private://这是访问控制——私有的 
    int value; //这是数据成员，我们称Int是基本类型int的包装类，就是因为Int里面只有一个int类型的数据成员 
    
public:    //这是公有的 
    Int():value(0){}
    Int(Int const&rhs):value(rhs.value){}
    Int(int v):value(v){}
    
    int getValue()const{return value;}
    void setValue(int v){value=v;}

    //拷贝赋值运算符重载
    Int& operator = (const Int&rhs){
        //在这里写具体实现，注意做自我赋值的检测
        if(&rhs!=this){
            this->value = rhs.value;
        }
        return *this;
    }

};//记住这里有一个分号 

#endif

```"
219,2786,程序设计二（面向对象）_实训7_赋值运算符重载,54bfkyqx3u2o,其他赋值运算符重载,6826,"```cpp
/**
 * 这是一个包装类(wrapper class)，包装类在C++中有点小小的用处(基本上没用)，在Java中的用处更大一些。
 */
#ifndef _INT_H_  //这是define guard 
#define _INT_H_  //在C和C++中，头文件都应该有这玩意 

class Int{
private://这是访问控制——私有的 
    int value; //这是数据成员，我们称Int是基本类型int的包装类，就是因为Int里面只有一个int类型的数据成员 
    
public:    //这是公有的 
    Int():value(0){}
    Int(Int const&rhs):value(rhs.value){}
    
    int getValue()const{return value;}
    void setValue(int v){value=v;}

    //其他赋值运算符重载
    Int& operator = (int rhs){
        //在这里写具体实现
        this->value = rhs;
        return *this;
    }

};//记住这里有一个分号 

#endif

```"
220,2786,程序设计二（面向对象）_实训7_赋值运算符重载,9a2ex7wjsyth,算术复合赋值符运算符重载,6827,"```cpp
/**
 * 这是一个包装类(wrapper class)，包装类在C++中有点小小的用处(基本上没用)，在Java中的用处更大一些。
 */
#ifndef _INT_H_  //这是define guard 
#define _INT_H_  //在C和C++中，头文件都应该有这玩意 

class Int{
private://这是访问控制——私有的 
    int value; //这是数据成员，我们称Int是基本类型int的包装类，就是因为Int里面只有一个int类型的数据成员 
    
public:    //这是公有的 
    Int():value(0){}
    Int(Int const&rhs):value(rhs.value){}
    Int(int v):value(v){}
    
    int getValue()const{return value;}
    void setValue(int v){value=v;}

    //算术复合赋值运算符运算符重载
    Int& operator += (const Int&rhs){
        //在这里实现算术复合赋值运算符
        this->value += rhs.value;
        return *this;
    }

};//记住这里有一个分号 

#endif

```"
221,2786,程序设计二（面向对象）_实训7_赋值运算符重载,wz29amn3jkhf,复用算术运算符重载复合赋值运算符,,
222,2786,程序设计二（面向对象）_实训7_赋值运算符重载,fuz3tomhwf2b,复用复合赋值运算符重载算术运算符,,
223,2787,C&C++表达式语句实训,8g5beci9yphk,整型数据的运算：剩下的苹果哪去了,6830,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    // 定义变量，m-苹果数，n-人数，x-人均苹果数
    int m, n, x;

    // 请在此添加代码，输入苹果数、人数，并计算人均苹果数
    /********** Begin *********/
    scanf(""%d%d"",&m,&n);
    x = m / n;
    /********** End **********/

    // 输出人均苹果数
    printf(""人均苹果数为：%d"",x);
    return 0;
}
```"
224,2787,C&C++表达式语句实训,n5gyfvq96cmh,浮点型数据的运算：你的身材标准吗,6831,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    float up, low;
    // 请在此添加代码，输入身高，计算标准身材的体重上下限
    /********** Begin *********/
    float h, w;
    scanf(""%f"",&h);
    w = (h - 100) * 0.9;
    low = w * 0.9;
    up = w * 1.1;
    /********** End **********/

    // 输出标准身材的体重上下限
    printf(""体重范围为：%.2f -- %.2f\n"",low,up);
    return 0;
}
```"
225,2787,C&C++表达式语句实训,yw98r4ihnjsf,字符型数据的运算：循环加密是怎么实现的,6832,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // c-存储输入的大写字母,d-存储加密后的大写字母
    char c, d;

    // step-秘钥，往前走的步数，大于等于，小于
    int step;

    // 请在此添加代码，输入明文、秘钥，计算密文存入d中
    /********** Begin *********/
    cin >> c >> step;
    d = c + step;
    d = (d > 'Z') ? (d - 26) : d;
    /********** End **********/

    // 输出密文
    cout << d;
    return 0;
}
```"
226,2787,C&C++表达式语句实训,f2miksqp9ten,二进制数据的位运算：字符是怎么存储的,6833,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // c是存储输入的字符
    char c;

    // 输入字符
    cin >> c;

    // 请在此添加代码，输出c的位二进制表示
    /********** Begin *********/
    cout << (int)(bool)(c & 0x80);
    cout << (int)(bool)(c & 0x40);
    cout << (int)(bool)(c & 0x20);
    cout << (int)(bool)(c & 0x10);
    cout << (int)(bool)(c & 0x08);
    cout << (int)(bool)(c & 0x04);
    cout << (int)(bool)(c & 0x02);
    cout << (int)(bool)(c & 0x01);
    /********** End **********/

    return 0;
}
```"
227,2387,Hello World!,yb87lx94iame,C 之 Hello world!,,
228,2387,Hello World!,pnbglu2ze5cj,在屏幕上输出多行信息,,
229,2709,数据结构-排序的实现及其应用,yvi3gu4sqbfr,直接插入排序,6622,"本关任务对应的参考代码实现如下：
```cpp
void InsertSort(SeqList  *L) /*直接插入排序*/
{	
	int i,j;
	for(i=2;i<=L->length;i++)
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
		if(L->r[i].key<L->r[i-1].key)/*将L->r[i]插入到前面的有序子序列L->r[1..i-1]中，插入后仍有序*/
		{
			L->r[0]=L->r[i]; /*复制为哨兵*/
			L->r[i]=L->r[i-1];
			for(j=i-2; L->r[0].key<L->r[j].key; j--)
				L->r[j+1]=L->r[j]; /*记录后移*/
			L->r[j+1]=L->r[0]; /*插入*/
		}		
    /********** End **********/		
}
```"
230,2709,数据结构-排序的实现及其应用,me9wuf75bfjq,希尔排序,6623,"本关任务对应的参考代码实现如下：
```cpp
void ShellInsert(SeqList *L, int d) /*对顺序表L作一趟增量为d的希尔插入排序*/
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int i,j;
	for(i=d+1;i<=L->length;i++)
		if(L->r[i].key<L->r[i-d].key)
		{
			L->r[0]=L->r[i]; L->r[i]=L->r[i-d];
			for(j=i-2*d;(j>0)&&(L->r[0].key<L->r[j].key);j-=d)
				L->r[j+d]=L->r[j]; /*记录后移*/
			L->r[j+d]=L->r[0]; /*插入*/
		}
	/********** End **********/	
}
```"
231,2709,数据结构-排序的实现及其应用,sepfrao82qwv,快速排序,6624,"本关任务对应的参考代码实现如下：
```cpp
void QuickSort(SeqList *L, int low, int high) /*对顺序表L的子序列L.r[low…high]作快速排序*/
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int i,j;
	if(low>=high)return;
	L->r[0]=L->r[low]; /*将第一个作枢轴存入r[0]中*/
	i=low; j=high;
	while(i<j) /*一趟快速排序*/
	{
		while((i<j)&&(L->r[j].key>=L->r[0].key))j--; /*从j向前扫描*/
		L->r[i]=L->r[j];/*将j所指元素存放到i所指位置*/
		while((i<j)&&(L->r[i].key<=L->r[0].key))i++; /*从i向后扫描*/
		L->r[j]=L->r[i];/*将i所指元素存放到j所指位置*/
	}
	L->r[i]=L->r[0]; /*将枢轴放入最终位置*/	
	/********** End **********/		
	/*分别对左、右两部分进行递归排序*/
	QuickSort(L,low,i-1);/*对左半区L->r[low..i-1]进行快速排序*/
	QuickSort(L,i+1,high);/*对右半区L->r[i+1..high]进行快速排序*/	
}
```"
232,2709,数据结构-排序的实现及其应用,g6kcjalxis9q,堆排序,6625,"本关任务对应的参考代码实现如下：
```cpp
void HeapAdjust(SeqList *L, int low, int high)
{/*已知L.r[low..high]中记录的关键字除L.r[low].key之外均满足堆的定义，*/
 /*调整L.r[low].key，使L.r[low..high]成为一个新大顶堆。*/
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int j;
	L->r[0]=L->r[low];
	for(j=2*low;j<=high;j*=2) /*沿较大关键字孩子向下筛选*/
	{
		if((j<high)&&(L->r[j].key<L->r[j+1].key))
			++j;  /*j为较大关键字的记录的下标*/
		if(L->r[0].key>=L->r[j].key) break;
		L->r[low]=L->r[j]; low=j;
	}
	L->r[low]=L->r[0]; /*插入在位置low上*/
	/********** End **********/
}
```"
233,2686,数据结构实训,tg4co89u3qwi,字符串连接,,
234,2686,数据结构实训,f4rg5xofeuk2,字符串长度,,
235,2664,语义分析器（C/C++）,fjvamxt98fc2,Translation Schema,,
236,2649,数据结构-图及其应用,vqb7x4syl3w9,创建采用邻接表存储的无向图,6494,"本关任务对应的参考代码实现如下：
```cpp
void CreateUDG_ALG(ALGraph *g) /*构造无向图的邻接表*/
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
   	int i,j,k;ENode *p;
	scanf(""%d%d%d"",&g->kind,&g->vexnum,&g->edgenum);
	for(i=0;i<g->vexnum;i++) /*构造头结点数组*/
	{
		g->vertices[i].vex=i;
		g->vertices[i].firstarc=NULL; /*初始化头结点指针域为空*/
	}
	for(k=0;k<g->edgenum;k++) /*构造邻接表*/
	{
		scanf(""%d%d"",&i,&j); /*输入一条边所依附的两个顶点的编号*/
		/*将顶点Vj插入到第i个单链表的表头，也就是用“头插法”建立一个单链表*/
		p=(ENode *)malloc(sizeof(ENode)); /*生成表结点*/
		p->adjvex=j; p->weight=0;
		p->nextarc=g->vertices[i].firstarc; /*插入表结点*/
		g->vertices[i].firstarc=p;
		/*将顶点Vi插入到第j个单链表的表头，也就是用“头插法”建立一个单链表*/
		p=(ENode *)malloc(sizeof(ENode));
		p->adjvex=i; p->weight=0;
		p->nextarc=g->vertices[j].firstarc;
		g->vertices[j].firstarc=p;
	}
    /********** End **********/	
}
```"
237,2649,数据结构-图及其应用,c7a6f4e9sg2n,图的深度优先遍历,6495,"本关任务对应的参考代码实现如下：
```cpp

void DFS(ALGraph  g, int i)/*从未被访问的顶点Vi出发深度优先遍历图g*/ 
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
   	int w; ENode *p;
	printf(""%d "",i);  visited[i]=1;
	p=g.vertices[i].firstarc; /*i号顶点的第一个邻接点*/
	while(p)
	{
		w=p->adjvex;
		if(!visited[w]) DFS(g,w);
		p=p->nextarc; /*i号顶点的下一个邻接点*/
	}
    /********** End **********/		
}

```"
238,2649,数据结构-图及其应用,f6mwavxutc9y,图的广度优先遍历,6496,"本关任务对应的参考代码实现如下：
```cpp

void BFSTraverse(ALGraph  g) 
{/*广度优先遍历以邻接表存储的图g，由于BFS要求”先被访问的顶点的邻接点也先被访问”，故需借助队列Q实现*/
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
   	int i,j,w; ENode *p; SeqQueue q;
	InitQueue(&q);
	for(i=0;i<g.vexnum;i++) /*访问标志数组初始化*/
		visited[i]=0;
	for(i=0;i<g.vexnum;i++)
		if(!visited[i])
		{
			printf(""%d "",i);  visited[i]=1;
			EnQueue(&q,i);
			while(!QueueEmpty(q))
			{
				DeQueue(&q,&j); /*出队一个顶点号j*/
				p=g.vertices[j].firstarc; /*j号顶点的第一个邻接点*/
				while(p)
				{
					w=p->adjvex;
					if(!visited[w])
					{
						printf(""%d "",w);  visited[w]=1;  EnQueue(&q, w); 
					}
					p=p->nextarc; /*j号顶点的下一个邻接点*/
				}
			}
		}
    /********** End **********/		
}  

```"
239,2659,数据结构-查找的实现及其应用,9bi8y2ko4ffr,顺序查找,6510,"本关任务对应的参考代码实现如下：
```cpp
int Search_Seq(SSTable L, KeyType key) 
{/*在静态查找表L中采用顺序查找法，查找其关键字等于key的记录，若找到返回该记录在表中位置，否则返回0*/
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int i;
	L.r[0].key=key;
	for(i=L.length; L.r[i].key!=key; i--);
	return i;	
    /********** End **********/	
}
```"
240,2659,数据结构-查找的实现及其应用,qwbmetprffl8,折半查找,6511,"本关任务对应的参考代码实现如下：
```cpp
int Search_Bin(SSTable L, KeyType key)/*在递增有序的顺序表L中折半查找其关键字等于key的记录*/
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int low,high,mid;
	low=1;high=L.length;
	while(low<=high)
	{
		mid=(low+high)/2;
		if(key==L.r[mid].key) return mid; /*找到*/
		else if(key<L.r[mid].key) high=mid-1;/*在左半区继续查找*/
		else low=mid+1; /*在右半区继续查找*/
	}
	return 0; /*没找到*/	
    /********** End **********/		
}

```"
241,2659,数据结构-查找的实现及其应用,crbi9qh5uv4x,二叉排序树的查找,6512,"本关任务对应的参考代码实现如下：
```cpp
BiTree Search_BST(BiTree T, KeyType key, BiTNode **parent)
{/*在二叉排序树T上查找其关键字等于key的记录结点。若找到返回该结点指针，parent指向其双亲；否则返回空指针，parent指向访问路径上最后一个结点。*/
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	BiTNode *p;   p=T; /*p指向根结点*/
	while(p)
	{
		if(key==p->data.key) return p; /*查找成功，返回该结点指针*/
		if(key<p->data.key) /*在左子树中继续查找*/
		{
			*parent=p; p=p->lchild;
		}
		else /*在右子树中继续查找*/
		{
			*parent=p; p=p->rchild;
		}
	}
	return NULL; /*查找失败，返回空指针*/	
    /********** End **********/	
}
```"
242,2450,算法与竞赛(第16章) - 数据结构进阶,o48viujcthq7,并查集,6049,"```cpp

int find(int x)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    if (F[x]!=x)
    {
        F[x] = find(F[x]);
    }
    return F[x];
    
    
    /********* End *********/
}

bool merge(int a,int b)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int f1 = find(a);
    int f2 = find(b);
    if (f1!=f2)
    {
        F[f2] = f1;
        return true;
    }
    return false;
    
    /********* End *********/
}

int main(int argc, const char * argv[]) {
    
    for (int i=0; i<maxn; i++)
    {
        F[i] = i;
    }
    
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int n, m;
    scanf(""%d %d"", &n, &m);
    
    int ans = n;
    int a, b;
    bool flag;
    while (m--)
    {
        scanf(""%d %d"", &a, &b);
        flag = merge(a, b);
        if (flag == true)
        {
            ans--;
        }
    }
    printf(""%d\n"", ans);

    
    /********* End *********/
    
    return 0;
}

```"
243,2450,算法与竞赛(第16章) - 数据结构进阶,6lky2gjufebr,字典树,6050,"```cpp

Node* create_node(char c, int v)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    Node* node = (Node*)malloc(sizeof(Node));
    node->val = v;
    node->ch = c;
    for (int i=0; i<26; i++) {
        node->children[i] = NULL;
    }
    return node;
    
    
    /********* End *********/

}

void add_name(Node* root, char* name, int val)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int len = int(strlen(name));
    Node* ptr = root;
    for (int i=0; i<len; i++) {
        if (ptr->children[name[i]-'a']!=NULL) {
            ptr = ptr->children[name[i]-'a'];
        }
        else{
            int v = (i==len-1)?val:-1;
            Node* node = create_node(name[i], v);
            ptr->children[name[i]-'a'] = node;
            ptr = ptr->children[name[i]-'a'];
        }
    }
    
    
    /********* End *********/

}

int find_name(Node* root, char* name)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    Node* ptr = root;
    int len = int(strlen(name));
    for (int i=0; i<len; i++) {
        if (ptr->children[name[i]-'a']==NULL) {
            return -1;
        }
        else{
            ptr = ptr->children[name[i]-'a'];
        }
    }
    return ptr->val;
    
    
    /********* End *********/

}

void Up2Down(char* name)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int len = int(strlen(name));
    for (int i=0; i<len; i++) {
        name[i] = ('a'<=name[i]&&name[i]<='z')?name[i]:(name[i]-'A'+'a');
    }
    
    
    /********* End *********/

}

int main(int argc, const char * argv[]) {

    Node* root = create_node('$', -1);
    
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int n, m;
    int val;
    char name[20];
    scanf(""%d"", &n);
    while (n--) {
        scanf(""%s %d"", name, &val);
        Up2Down(name);
        add_name(root, name, val);
    }
    scanf(""%d"", &m);
    while (m--) {
        scanf(""%s"", name);
        Up2Down(name);
        val = find_name(root, name);
        printf(""%d\n"", val);
    }

    
    /********* End *********/

    return 0;
}

```"
244,2450,算法与竞赛(第16章) - 数据结构进阶,35nesokmjw4b,树状数组,6051,"```cpp

inline int lowbit(int x)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    return x&(-x);
    
    /********* End *********/
}

void insert(int x, int n, int val)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    while (x<=n) {
        arr[x] += val;
        x += lowbit(x);
    }
    
    /********* End *********/
}

int getsum(int x)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int sum = 0;
    while (x>0) {
        sum += arr[x];
        x -= lowbit(x);
    }
    return sum;
    
    /********* End *********/
}

int main(int argc, const char * argv[]) {
    
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int n;
    scanf(""%d"", &n);
    int val;
    for (int i=1; i<=n; i++) {
        scanf(""%d"", &val);
        insert(i, n, val);
    }
    
    char str[10];
    int x, y;
    int sum;
    while (scanf(""%s"", str)) {
        if (str[0]=='E') {
            break;
        }
        scanf(""%d %d"", &x, &y);
        if (str[0]=='Q') {
            sum = getsum(y) - getsum(x-1);
            printf(""%d\n"", sum);
        }
        else if (str[0]=='A'){
            insert(x, n, y);
        }
        else if (str[0]=='S'){
            insert(x, n, -y);
        }
    }
    
    
    /********* End *********/
    
    return 0;
}

```"
245,2514,程序设计部分 C 语言的基本成分 — 控制成分（一）,nwq4juiple3z,简单分支结构,6208,"	#include <stdio.h>
	#include <iostream>
	using namespace std;

	int main(void)
	{
		char c;
		/********** Begin **********/
		scanf(""%c"",&c);
		if(c<32)
			cout << c << ""是控制字符"";
		else if(c>='0'&&c<='9')
			cout << c << ""是数字"";
		else if(c>='A'&&c<='Z')
			cout << c << ""是大写字母"";
		else if(c>='a'&&c<='z')
			cout << c << ""是小写字母"";
		else
			cout << c << ""是其他字符"";
		/********** End  **********/
		return 0;
	}"
246,2514,程序设计部分 C 语言的基本成分 — 控制成分（一）,khlemo4uyg2f,嵌套分支,6209,"	#include <stdio.h>
	#include <iostream>
	using namespace std;

	int main(void)
	{
		int year;
		/********** Begin **********/
		cin >> year;
		if (year % 4 == 0) {
			if (year % 100 == 0) {
				if (year % 400 == 0)
					cout << year << ""年是闰年"";
				else
					cout << year << ""年不是闰年"";
				}
			else
				cout <<  year << ""年是闰年"";
			}
		else
			cout << year << ""年不是闰年"";
		/********** End **********/
		return 0;
	}"
247,2514,程序设计部分 C 语言的基本成分 — 控制成分（一）,qyghfw6v4luk,多分支语句,6210,"	#include <iostream>
	using namespace std;

	int main(void)
	{
		int x;
		/********** Begin **********/
		cin >> x;
		switch ((!(x % 7) << 2) + (!(x % 5) << 1) + (!(x % 3))){
		//此处的精妙点在于只用了三次求余，把每次求余的结果组合成一个
		//三位二进制数来恰好表示所需要的八种情况
		case 0:cout << x << ""不能被3,5,7任一个整除""; break;
		case 1:cout << x << ""能被3整除""; break;
		case 2:cout << x << ""能被5整除""; break;
		case 3:cout << x << ""能同时被3,5整除""; break;
		case 4:cout << x << ""能被7整除""; break;
		case 5:cout << x << ""能同时被3,7整除""; break;
		case 6:cout << x << ""能同时被5,7整除""; break;
		case 7:cout << x << ""能同时被3,5,7整除""; break;
		}
		/********** End **********/
		return 0;
	}"
248,2287,结构和数组,2plmvqu8haft,复数的加、减、乘、除运算,,
249,2287,结构和数组,glwka6389ump,打印出3门课程的总平均成绩，以及最高平均分的学生的数据。,,
250,2287,结构和数组,xroymgf8l57t,学生成绩统计、查找。,,
251,2287,结构和数组,jkro3yugzaql,名词由单数变成复数。,,
252,2520,LR parser(C/C++),56vlz9gshp87,LR parser,,
253,2465,[YZNCXB] C函数，函数指针，函数指针数组,27f9atvlk3mj,[指针版]几点几分了？,6094,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>

void whatTime (int secs, int *ph, int *pm, int *ps)
{
    //在此处添加代码
    /********** Begin *********/
    *ph = secs / 3600;
    secs = secs % 3600;
    *pm = secs / 60;
    *ps = secs % 60;
    /********** End **********/
}

int main()
{
    int secs = 0;

    int h, m, s;

    scanf (""%d"", &secs);

    whatTime (secs, &h, &m, &s);

    printf (""%d:%d:%d\n"", h, m, s);

    return 0;
}

```"
254,2465,[YZNCXB] C函数，函数指针，函数指针数组,ze54qynwmsj2,递归求P函数,6095,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>

double funP (int n, double x)
{
    /********** Begin *********/
    if (n == 0)
    {
        return 1;
    }
    if (n == 1)
    {
        return x;
    }
    return ((2 * n - 1) * funP (n - 1, x) - (n - 1) * funP (n - 2, x)) / n;

    /********** End **********/
}

int main()
{
    int n;
    double x;
    /********** Begin *********/
    //读取n和x
    scanf (""%d%lf"", &n, &x);
    /********** End **********/

    ///输出,保留两位小数
    printf (""%.2f\n"", funP (n, x));

    return 0;
}

```"
255,2465,[YZNCXB] C函数，函数指针，函数指针数组,glxfe5i3nr8p,指针函数,6184,"```
#include <stdio.h>
#include <stdlib.h>

int *myAllocMem (int n)
{
    /********* BEGIN ************/
    //动态分配内存
    int *p = (int *)calloc (n, sizeof (int));
    //建议通过if ( p == NULL )检查内存分配是否成功
    return p;
    /********* END ************/
}

double calcAve (int *p, int n)
{
    /********* BEGIN ************/
    //计算平均值
    double sum = 0;
    int i = 0;
    for (i = 0; i < n ; i++)
    {
        sum += p[i];
    }
    return sum / n;
    /********* END ************/
}

int calcMax (int *p, int n)
{
    /********* BEGIN ************/
    //计算最大值
    int max = p[0];
    int i = 0;
    for (i = 1; i < n ; i++)
    {
        if (max < p[i])
        {
            max = p[i];
        }
    }
    return max;
    /********* END ************/

}


int main()
{
    int num = 0;
    scanf (""%d"", &num);

    int *pown = myAllocMem (num);
    /********* BEGIN ************/
    //依次读入后续输入
    int i = 0;
    for (i = 0; i < num; i++)
    {
        scanf (""%d"", pown + i);
    }
    /********* END ************/

    ///输出，保留两位有效数字
    printf (""%.2f,%d\n"", calcAve (pown, num), calcMax (pown, num));

    ///不要忘记释放内存
    free (pown);

    return 0;
}

```
"
256,2465,[YZNCXB] C函数，函数指针，函数指针数组,sutm7jy9ibxv,函数指针与函数指针数组,6185,"```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

void own_gets (char *str, int num)
{
    if (fgets (str, num, stdin) != 0)
    {
        size_t len = strlen (str);
        if (len > 0 && str[len - 1] == '\n')
        {
            str[len - 1] = '\0';
        }
    }
}

//关心5种类型的情况
#define NN 5

int main()
{

    /******************** BEGIN ****************************/
    ///建议：按要求的顺序使用isspace, isdigit等函数完成函数指针数组的初始化
    int (*test_func[5]) (int) =
    {
        isspace,
        isdigit,
        islower,
        isupper,
        ispunct
    };
    /******************** END ****************************/

    // 定义存储字符串的一维字符数组
    char s[1024];

    // 输入一行字符，可以包含空格
    own_gets (s, 1023);

    int count[NN] = {0};

    int i = 0;
    /******************** BEGIN ****************************/
    //依次遍历字符，统计各类型对应的个数
    char *p = s;
    while (*p != '\0')
    {
        for (i = 0; i < NN; i ++)
        {
            if ((*test_func[i]) (*p)) ///或直接写成if(test_func[i](*p))
            {
                count[i]++;
            }
        }
        p++;
    }
    /******************** END ****************************/

    ///输出
    for (i = 0; i < NN; i ++)
    {
        printf (""%d "", count[i]);
    }

    printf (""\n"");
    return 0;
}

```"
257,2469,LL parser(C/C++),qjfla6u3hg2y,LL parser,,
258,2398,分布式编程实践,bpyg7oz9fejx,利用pthread实现多线程任务,5940,"```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#define NUM_THREADS 5
void *PrintHello(void *threadid)
{
 //******************begin**************************//
 long tid;
 //打印每个线程的pid号
 tid = (long)threadid;
 tid+=1;
 //printf(""Hello everyone! It's me, thread #%ld!\n"", tid);
 pthread_exit(NULL);
 //******************end**************************//

}
int main(int argc,char *argv[])
{
 //******************begin**************************//
 pthread_t threads[NUM_THREADS];
   int rc;
   long t;
   for(t=0;t<NUM_THREADS;t++){
     printf(""In main: creating thread %ld\n"", t);
     rc = pthread_create(&threads[t], NULL, PrintHello, (void *)t);
     if (rc){
       printf(""ERROR; return error code from pthread_create() is %d\n"", rc);
       exit(-1);
       }
     }
   /* main()函数等待其他线程执行完毕后退出 */
   pthread_exit(NULL);
 //******************end**************************//
}


```"
259,2398,分布式编程实践,m3csz7ijvy2x,pthread线程阻塞,5958,"```c
#include<stdlib.h>
#include <pthread.h>
#include <stdio.h>
#include <math.h>
#define NUM_THREADS 4
void *BusyWork(void *t)
{
  int i;
  //long tid;
  double result=0.0;
  //tid = (long)t;
  //printf(""Thread %ld starting...\n"",tid);
  for (i=0; i<1000000; i++)
 {
 result = result + i-i;
 }
  //printf(""Thread %ld done. Result = %e\n"",tid, result);
  pthread_exit((void*) t);
}
int main (int argc, char *argv[])
{
pthread_t thread[NUM_THREADS];
pthread_attr_t attr;
int rc;
long t;
void *status;
/* 初始化并设置线程属性 */
pthread_attr_init(&attr);
pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_JOINABLE);
for(t=0; t<NUM_THREADS; t++) {
printf(""Main: creating thread %ld\n"", t);
rc = pthread_create(&thread[t], &attr, BusyWork,(void*)t);
if (rc) {
printf(""ERROR; return code from pthread_create() is %d\n"", rc);
exit(-1);
 }
}
/* 释放属性并等待其他线程*/
pthread_attr_destroy(&attr);
for(t=0; t<NUM_THREADS; t++) {
rc = pthread_join(thread[t], &status);
if (rc) {
printf(""ERROR; return code from pthread_join() is %d\n"", rc);
exit(-1);
 }
printf(""Main: completed join with thread %ld having a status of %ld\n"",t,(long)status);
}
printf(""Main: program completed. Exiting.\n"");
pthread_exit(NULL);
}
```"
260,2398,分布式编程实践,tgn7hjys4afz,pthread实现向量点乘,5959,"```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
typedef struct
 {
   double      *a;
   double      *b;
   double     sum;
   int     veclen;
 } DOTDATA;
#define NUMTHRDS 4
#define VECLEN 100000
DOTDATA dotstr;
pthread_t callThd[NUMTHRDS];
pthread_mutex_t mutexsum;
void *dotprod(void *arg)
{
   int i, start, end, len ;
   long offset;
   double mysum, *x, *y;
   offset = (long)arg;
   len = dotstr.veclen;
   start = offset*len;
   end   = start + len;
   x = dotstr.a;
   y = dotstr.b;
   mysum = 0;
   for (i=start; i<end ; i++)
    {
      mysum += (x[i] * y[i]);
    }
/*
锁住共享锁以便更新数据，释放锁当数据更新完毕。
*/
   pthread_mutex_lock (&mutexsum);
   dotstr.sum += mysum;
   printf(""mysum=%f global sum=%f\n"",mysum, dotstr.sum);
   pthread_mutex_unlock (&mutexsum);
   pthread_exit((void*) 0);
}
int main (int argc, char *argv[])
{
long i;
double *a, *b;
void *status;
pthread_attr_t attr;
/* Assign storage and initialize values */
a = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double));
b = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double));
for (i=0; i<VECLEN*NUMTHRDS; i++) {
  a[i]=1;
  b[i]=2;
  }
dotstr.veclen = VECLEN;
dotstr.a = a;
dotstr.b = b;
dotstr.sum=0;
pthread_mutex_init(&mutexsum, NULL);
/* 创建线程执行点积  */
pthread_attr_init(&attr);
pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_JOINABLE);
for(i=0;i<NUMTHRDS;i++)
  {
   pthread_create(&callThd[i], &attr, dotprod, (void *)i);
   }
pthread_attr_destroy(&attr);
/* Wait on the other threads */
for(i=0;i<NUMTHRDS;i++) {
  pthread_join(callThd[i], &status);
  }
printf (""Sum =  %f \n"", dotstr.sum);
free (a);
free (b);
pthread_mutex_destroy(&mutexsum);
pthread_exit(NULL);
}
```"
261,2233,数组和指针,xoehm2albnyr,字符串拼接,,
262,2233,数组和指针,6bsv3qzowl8c,求子串。,,
263,2233,数组和指针,3tpej6oisc8b,约瑟夫问题,,
264,2233,数组和指针,pakcfgizvewq,魔术师的猜牌术。,,
265,2214,数组,jvcpm8zu32fg,十进制整数转转换成十六进制数输出。,,
266,2214,数组,gbwcxlfhe6p9,回文数。,,
267,2214,数组,nib7o63hcq4a,求数列的第n项以及前n项之和。,,
268,2214,数组,nfrl52ofkc86,求数中的第k位数字。,,
269,2114,数据结构-树和二叉树及其应用,6u4pif9kswr3,二叉树的创建,5083,"本关任务对应的参考代码实现如下：
```cpp
BiTree CreateBiTree()
// 利用先序遍历创建二叉树，返回根指针。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
   	BiTree T;char ch;
	ch=getchar();
	if(ch=='#') T=NULL; //'#'代表空树		
	else
	{
		T=(BiTNode *)malloc(sizeof(BiTNode)); //生成根结点
		T->data=ch;
		T->lchild=CreateBiTree( ); //建立左子树
		T->rchild=CreateBiTree( ); //建立右子树
	}
	return T;
    /********** End **********/
}

void InOrder(BiTree T)
// 二叉树的中序遍历
// 参数：二叉树根指针T
// 输出：中间没有空格，末尾不换行。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(T)
	{
		InOrder(T->lchild);
		printf(""%c"",T->data);
		InOrder(T->rchild);
	}       
    /********** End **********/
}
```"
270,2114,数据结构-树和二叉树及其应用,2qawtirvjomn,计算二叉树的深度和结点个数,5084,"本关任务对应的参考代码实现如下：
```cpp
int GetTreeDepth(BiTree T)
// 计算二叉树的深度
// 参数：二叉树根指针T
// 返回：二叉树的深度
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int dl,dr;
	if(T==NULL) return 0;
	else
	{
		dl=GetTreeDepth(T->lchild);
		dr=GetTreeDepth(T->rchild);
		return (dl>=dr?dl:dr)+1;
	}
    /********** End **********/
}

int GetNodeNumber(BiTree T)
// 计算二叉树的总结点个数
// 参数：二叉树根指针T
// 返回：二叉树的总结点个数
{
    // 请在这里补充代码，完成本关任务
	/********** Begin *********/
    int nl,nr;
	if(T==NULL) return 0;
	else
	{
		nl=GetNodeNumber(T->lchild);
		nr=GetNodeNumber(T->rchild);
		return nl+nr+1;
	}
    /********** End **********/
}

int GetLeafNodeNumber(BiTree T)
// 计算二叉树的叶子结点个数
// 参数：二叉树根指针T
// 返回：二叉树的叶子结点个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int nl,nr;
	if(T==NULL) return 0;//空树
	else if(T->lchild==NULL&&T->rchild==NULL) return 1;//只有一个根结点
	else
	{
		nl=GetLeafNodeNumber(T->lchild);
		nr=GetLeafNodeNumber(T->rchild);
		return nl+nr;
	}    
    /********** End **********/
}
```"
271,2114,数据结构-树和二叉树及其应用,k26lhxjczqwo,实现二叉树左右子树交换,5085,"本关任务对应的参考代码实现如下：
```cpp
BiTree BiTreeChange(BiTree T)
// 实现二叉树左右子树的交换
// 参数：二叉树根指针T
// 返回：二叉树根指针
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	BiTNode* p;
	if(T==NULL)return T;
	else
	{
		p=T->lchild;T->lchild=T->rchild;T->rchild=p;//交换根结点的左右指针的指向
		T->lchild=BiTreeChange(T->lchild);
		T->rchild=BiTreeChange(T->rchild);
		return T;
	}    
    /********** End **********/
}

void PreOrder(BiTree T)
// 二叉树的先序遍历
// 参数：二叉树根指针T
// 输出：二叉树的先序遍历，中间没有空格，末尾不换行。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(T)
	{
		
		printf(""%c"",T->data);
		PreOrder(T->lchild);
		PreOrder(T->rchild);
	}    
    /********** End **********/
}
```"
272,2114,数据结构-树和二叉树及其应用,swp47fj8bqch,层次遍历二叉树,5087,"本关任务对应的参考代码实现如下：
```cpp
void HierarchyOrder(BiTree T)
// 二叉树的层次遍历（借助队列实现）
// 参数：二叉树根指针T
// 输出：二叉树的层次遍历，中间没有空格，末尾不换行。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	SqQueue Q; BiTNode *p;
	SQ_Initiate(&Q); //构造一个空队列
	p=T;
	if(p==NULL) return;
	SQ_In(&Q,p);
	while(!SQ_IsEmpty(Q))
	{
		SQ_Out(&Q,&p); //出队一个结点指针
		printf(""%c"",p->data);
		if(p->lchild!=NULL) SQ_In(&Q,p->lchild);
		if(p->rchild!=NULL) SQ_In(&Q,p->rchild);
	}
    /********** End **********/
}
```"
273,2335,[YZNCXB]C 指针实训,fvqws6ryc34z,去掉字符串首尾空格,5764,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>
#include <string.h>

// 说明：gets因为安全隐患，已被c11标准遗弃．
// 虽然新的c标准中增加了gets_s, 但目前各编译器支持力度不一．
// 另外的替代方案是fgets

// 但是fgets和gets有些许差异，体现在:
// (1) gets和scanf在接受用户输入时，不会将换行符记录到字符串中，且会自动添加结尾的'\0'
// (2) fgets会将换行符记录到字符串中，不会自动添加结尾的'\0'

// 为方便大家使用，自定义实现own_gets, 接受两个参数,str和num
// 内部实现使用fgets，但会将换行符进行处理，替换成'\0'

void own_gets (char *str, int num)
{
    if (fgets (str, num, stdin) != 0)
    {
        size_t len = strlen (str);
        if (len > 0 && str[len - 1] == '\n')
        {
            str[len - 1] = '\0';
        }
    }
}

int main()
{
    // 定义存储字符串的一维字符数组
    char s[1024];
    char *p = NULL;

    // 输入一行字符，可以包含空格
    own_gets (s, 1023);

    p = s;
    //先将p挪动到尾部的'\0'
    while (*p != '\0')
    {
        p ++;
    }

    p --; //最后1个有效字符

    // 向前回溯，如果是空格，就改写成'\0'，实现空格删除
    while (*p == ' ')
    {
        *p = '\0';
        p --;
    }

    // 回到数组首部
    p = s;
    while (*p == ' ')
    {
        p ++;  // 不需要额外处理，只移动ｐ即可
    }

    // 输出去掉首尾空格后的字符串
    printf (""%s\n"", p);

    return 0;
}

```"
274,2335,[YZNCXB]C 指针实训,lxcvgpr9fie3,选出串中的数字,5765,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>
#include <string.h>

// 说明：gets因为安全隐患，已被c11标准遗弃．
// 虽然新的c标准中增加了gets_s, 但目前各编译器支持力度不一．
// 另外的替代方案是fgets

// 但是fgets和gets有些许差异，体现在:
// (1) gets和scanf在接受用户输入时，不会将换行符记录到字符串中，且会自动添加结尾的'\0'
// (2) fgets会将换行符记录到字符串中，不会自动添加结尾的'\0'

// 为方便大家使用，自定义实现own_gets, 接受两个参数,str和num
// 内部实现使用fgets，但会将换行符进行处理，替换成'\0'

void own_gets (char *str, int num)
{
    if (fgets (str, num, stdin) != 0)
    {
        size_t len = strlen (str);
        if (len > 0 && str[len - 1] == '\n')
        {
            str[len - 1] = '\0';
        }
    }
}

int main()
{
    char s[1024];

    char *p = s, *q = s;

    // 输入一行字符
    own_gets (s, 1023);

    // 选出数字
    while (*p != '\0')
    {
        if ('0' <= *p && *p <= '9')
        {
            *q = *p;
            q ++;
        }
        else if ('-' == *p && q == s)
        {
            *q = '-';
            q ++;
        }
        p ++;
    }

    *q='\0';    //字符串封尾

    // 输出选出的数字
    printf (""%s\n"", s);

    return 0;
}

```"
275,2335,[YZNCXB]C 指针实训,3gey6woftvnr,大写字母好看,5766,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>

#include <string.h>

// 说明：gets因为安全隐患，已被c11标准遗弃．
// 虽然新的c标准中增加了gets_s, 但目前各编译器支持力度不一．
// 另外的替代方案是fgets

// 但是fgets和gets有些许差异，体现在:
// (1) gets和scanf在接受用户输入时，不会将换行符记录到字符串中，且会自动添加结尾的'\0'
// (2) fgets会将换行符记录到字符串中，不会自动添加结尾的'\0'

// 为方便大家使用，自定义实现own_gets, 接受两个参数,str和num
// 内部实现使用fgets，但会将换行符进行处理，替换成'\0'

void own_gets (char *str, int num)
{
    if (fgets (str, num, stdin) != 0)
    {
        size_t len = strlen (str);
        if (len > 0 && str[len - 1] == '\n')
        {
            str[len - 1] = '\0';
        }
    }
}

int main()
{
    char s[1024];

    // 输入一行字符

    own_gets(s,1023);

    // 转换成大写字母
    char * p = s;

    for (; *p!='\0'; p++)
    {
        if( 'a' <= *p && *p <= 'z' )
        {
            *p = *p + 'A' - 'a';
        }
    }

    // 输出变更后的字符串
    printf(""%s\n"",s);

    return 0;
}

```"
276,2335,[YZNCXB]C 指针实训,ruhkbzpnsmt5,子串出现的次数,5767,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>

// 包含字符串函数库
#include <string.h>

// 说明：gets因为安全隐患，已被c11标准遗弃．
// 虽然新的c标准中增加了gets_s, 但目前各编译器支持力度不一．
// 另外的替代方案是fgets

// 但是fgets和gets有些许差异，体现在:
// (1) gets和scanf在接受用户输入时，不会将换行符记录到字符串中，且会自动添加结尾的'\0'
// (2) fgets会将换行符记录到字符串中，不会自动添加结尾的'\0'

// 为方便大家使用，自定义实现own_gets, 接受两个参数,str和num
// 内部实现使用fgets，但会将换行符进行处理，替换成'\0'

void own_gets (char *str, int num)
{
    if (fgets (str, num, stdin) != 0)
    {
        size_t len = strlen (str);
        if (len > 0 && str[len - 1] == '\n')
        {
            str[len - 1] = '\0';
        }
    }
}

int main()
{
    char sub[128], str[1024];

    // 输入子串, 最长127位
    own_gets (sub, 127);

    // 输入长串，最长1023位
    own_gets (str, 1023);

    // 计算子串在长串中出现的次数n
    int n = 0;

    char *p = str;
    char *q = NULL;
    while ((q = strstr (p, sub)) != NULL)
    {
        n ++;
        p = q + strlen (sub);
    }

    // 输出次数
    printf (""%d\n"", n);

    return 0;
}

```"
277,2335,[YZNCXB]C 指针实训,rqa7ipjceth8,字符串的部分复制,5768,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>
#include <string.h>

// 说明：gets因为安全隐患，已被c11标准遗弃．
// 虽然新的c标准中增加了gets_s, 但目前各编译器支持力度不一．
// 另外的替代方案是fgets

// 但是fgets和gets有些许差异，体现在:
// (1) gets和scanf在接受用户输入时，不会将换行符记录到字符串中，且会自动添加结尾的'\0'
// (2) fgets会将换行符记录到字符串中，不会自动添加结尾的'\0'

// 为方便大家使用，自定义实现own_gets, 接受两个参数,str和num
// 内部实现使用fgets，但会将换行符进行处理，替换成'\0'

void own_gets (char *str, int num)
{
    if (fgets (str, num, stdin) != 0)
    {
        size_t len = strlen (str);
        if (len > 0 && str[len - 1] == '\n')
        {
            str[len - 1] = '\0';
        }
    }
}

int main()
{
    char s[128], t[128];

    int m, n;

    // 输入源串
    own_gets (s, 127);

    // 输入m和n,用空格隔开
    scanf (""%d%d"", &m, &n);

    // 字符串复制
    char *p = s + m;
    char *q = t;
    for (int i = 0 ; i < n; i ++)
    {
        *q = *p;
        q ++;
        p ++;
    }

    // 输出复制结果
    printf (""t:%s\n"", t);

    return 0;
}

```"
278,2110,PL语言编译程序扩充,eju9oti4ayc8,PL语言编译程序扩充(初窥门径),,
279,2110,PL语言编译程序扩充,9m7us2v6fo3k,PL语言编译程序扩充(登堂入室),,
280,2110,PL语言编译程序扩充,upnbg9xrkijy,PL语言编译程序扩充(炉火纯青),,
281,2157,函数,82k3ltsi4xgo,计算三角形的面积和周长。,,
282,2157,函数,a97zh4moutp2,用函数求解级数。,,
283,2157,函数,4hfojpl3a79k,求正整数n内的所有素数。,,
284,2157,函数,y26eopvn4fck,正整数n转换成十六进制字符串逆序输出。,,
285,2230,Lexical Analysis(C/C++),abfpsl759xr2,C语言语法分析器,,
286,2270,数据结构-稀疏矩阵的转置,yk9zcu5it7rl,一般转置算法,5516,"```cpp
void TransSMatrix(SPMatrix a, SPMatrix *b)//一般转置，即：按列序转置
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int p, q, k;
	b->m=a.n; b->n=a.m; b->t=a.t;
	q=0;
	for(k=0;k<a.n;k++)
		for(p=0;p<a.t;p++)//找a的第k列非零元素存入b.data[]中
			if(a.data[p].j==k)
			{
				b->data[q].i=a.data[p].j;
				b->data[q].j=a.data[p].i;
				b->data[q].v=a.data[p].v;
				q++;
			}   	
    /********** End **********/
}
```"
287,2270,数据结构-稀疏矩阵的转置,rl846kmpjc7t,快速转置算法,5517,"本关任务对应的参考代码实现如下：
```cpp
void FastTransSMatrix(SPMatrix a, SPMatrix *b)//快速转置
{	
	int p,q,i,k;  int x[N],y[N];
	b->m=a.n; b->n=a.m; b->t=a.t;
	if(b->t==0)
	{
		printf(""The matrix has no nonzero element!\n""); return;
	}
	for(i=0;i<a.n;i++) x[i]=0;
	for(p=0;p<a.t;p++) //求A中每一列非零元个数存放到x[ ]中
	{
		/********** Begin *********/
		k=a.data[p].j; x[k]++;
		/********** End **********/
	}
	y[0]=0; 
	for(i=1;i<a.n;i++)//求A中每一列的第一个非零元在B.data中的位置存放到y[ ]中
	{
		/********** Begin *********/
		y[i]=y[i-1]+x[i-1];
	    /********** End **********/
	}
	for(p=0;p<a.t;p++) //扫描A.data，将A中每一三元组存放到B中恰当位置
	{
		/********** Begin *********/
		k=a.data[p].j; q=y[k];
		b->data[q].i=a.data[p].j; b->data[q].j=a.data[p].i; 
		b->data[q].v=a.data[p].v; y[k]++;
		/********** End **********/
	}    	
}
```"
288,2261,[YZNCXB] C数组实训,m5a8f7y4oqsp,销售波动统计,,
289,2261,[YZNCXB] C数组实训,ilf35fpyebva,最大销售增幅,,
290,2261,[YZNCXB] C数组实训,2fo7pe39zsiw,猴子选大王,,
291,2261,[YZNCXB] C数组实训,9ia3blz7qktv,犯二的程度,,
292,2261,[YZNCXB] C数组实训,jsx2menq6o4b,队列变换,,
293,1937,数据结构-串的运算及应用,lg6xyh7cpojs,求子串,3410,"```cpp
void SubStr(SString t, SString s,int i,int len)
//从s的第i个字符开始截取长度为len的子串存入t中。
//其中1≦i≦串s的长度, 0≦len≦ 串s的长度-i+1。
//若i和len超出取值范围，则输出""error""；否则输出子串t。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int j,k;
	if(i<1 || i>s[0] || len<0 || len>s[0]-i+1)
	{
		printf(""error"");return;
	}
	for(k=1,j=i;k<=len;j++,k++)
		t[k]=s[j];
	t[0]=len; 
	t[k]='\0'; //在串尾存储一个结束符'\0'
	puts(t+1);
  /********** End **********/
}
```"
294,1937,数据结构-串的运算及应用,38x4cmf2gzhs,串的模式匹配之简单算法,3403,"本关任务对应的参考代码实现如下：
```cpp
int StrIndex_BF(SString s, SString t, int pos)
//从主串s的第pos个字符开始查找子串t。
//若找到，则返回子串t在主串s中第一次出现的位置，否则返回0。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int i,j;
	i=pos;j=1;
	while(i<=s[0]&&j<=t[0])
		if(s[i]==t[j]) //若字符相等，则继续比较
		{
			i++;j++;
		}
		else //若字符不等，则回溯，进行下一趟比较
		{
			i=i-j+2; //i回退到S的下一个起始位置
			j=1;
		}
	if(j>t[0]) return i-j+1; //匹配成功，返回t在s中的位置
	else return 0; //匹配失败，返回0  
    /********** End **********/
}
```"
295,1937,数据结构-串的运算及应用,hyqe7rcvfzni,串的模式匹配之KMP算法,3404,"本关任务对应的参考代码实现如下：
```cpp
void GetNext(SString t, int next[])
//求模式串T的next值并存入next数组中
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
       int j,k;
       j=1;k=0;next[1]=0;
       while(j<t[0])
       if(t[j]==t[k]||k==0)  next[++j]=++k;
       else  k=next[k]; 
	/********** End   *********/
}
```"
296,2158,循环程序2,ygsi6e4rutmf,编程求出四位正整数。,,
297,2158,循环程序2,lkpjqbi4hyue,"编程求出[1,n]以内的全部亲密数。",,
298,2158,循环程序2,lx9fozvs6eun,编程求等差数列的整数。,,
299,2158,循环程序2,mq8f7bihy2uv,用循环语句编程输出菱形图案。,,
300,2221,计算机程序设计-——作业三,mftrwyu3sabc,位置交换,,
301,2221,计算机程序设计-——作业三,gwh9zv3kcem2,逆序输出,,
302,2221,计算机程序设计-——作业三,kw3c9sf5r6xz,三角形的另一边,,
303,2221,计算机程序设计-——作业三,bsljkw3o7fvp,圆与直线,,
304,2221,计算机程序设计-——作业三,wy82oamrfzt3,switch,,
305,2189,计算机程序设计——作业二,2epimrwczs38,2.1   数学计算,,
306,2189,计算机程序设计——作业二,er23cjlkuxis,2.2   输出ASCII码,,
307,2189,计算机程序设计——作业二,ocm9h7zej2x6,2.3   求最大数,,
308,2167,计算机程序设计——作业一,j4ewuzm9shyb,1.1   求和,,
309,2167,计算机程序设计——作业一,l9qyfg2eazmr,1.2   字符串,,
310,2167,计算机程序设计——作业一,ire7x2zv6fko,1.3   华氏温度转换成摄氏温度,,
311,2167,计算机程序设计——作业一,muerfbscia29,1.4   求圆的周长与面积,,
312,2167,计算机程序设计——作业一,e4rcwt37u6fp,1.5   医院看病,,
313,1925,数据结构-队列基本运算的实现及其应用,4aymwzp93xnq,顺序队列的实现,3373,"本关任务对应的参考代码实现如下：
```cpp
void SQ_In(SqQueue *Q, ElemType e)
// 将e入队。即：插入元素e为Q的新的队尾元素。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SQ_IsFull(*Q)) return;//队满
	Q->elem[Q->rear]=e;Q->rear=(Q->rear+1)%MAXSIZE;
    /********** End **********/
}

void SQ_Out(SqQueue *Q, ElemType *e)
// 从队列Q出队一个元素，即：删除Q的队头元素，用e返回其值。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SQ_IsEmpty(*Q)) return; //队空
	*e=Q->elem[Q->front];Q->front=(Q->front+1)%MAXSIZE;
    /********** End **********/
}

void SQ_Head(SqQueue Q, ElemType *head)
// 获取队列的队头元素，用head返回其值。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if( SQ_IsEmpty(Q) ) return; //队空
    *head = Q.elem[Q.front];
	/********** End **********/
}
```"
314,1925,数据结构-队列基本运算的实现及其应用,plmjhfic527b,链队列的实现,3374,"本关任务对应的参考代码实现如下：
```cpp
int LQ_Length(LinkQueue Q)
// 求队列的长度
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	QNode *p;int n;	
	p=Q.front->next;n=0;
	while(p)
	{
		n++;p=p->next;
	}
	return n;
    /********** End **********/
}

void LQ_In(LinkQueue *Q, ElemType e)
// 将e入队。即：插入元素e为Q的新的队尾元素。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	QNode* p;
	p=(QNode *)malloc(sizeof(QNode));
	p->data=e;
	p->next=NULL;
	Q->rear->next=p;
	Q->rear=p;
    /********** End **********/
}

void LQ_Out(LinkQueue *Q, ElemType *e)
//从队列Q出队一个元素，即：删除Q的队头元素，用e返回其值。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	QNode *p;
	if(LQ_IsEmpty(*Q)) return;
	p=Q->front->next;
	*e=p->data;
	Q->front->next=p->next;
	if(Q->front->next==NULL)//若只有一个结点，删除后还要修改尾指针
		Q->rear=Q->front;
	free(p);
    /********** End **********/
}

void LQ_Head(LinkQueue Q, ElemType *head)
//获取队列的队头元素，用head返回其值。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(LQ_IsEmpty(Q)) return;
    *head = Q.front->next->data;
    /********** End **********/
}
```"
315,1925,数据结构-队列基本运算的实现及其应用,ytqrfgcua97n,利用循环队列输出杨辉三角形,5070,"本关任务对应的参考代码实现如下：
```cpp
void YangHuiTriangle(int n)//借助循环队列输出n行杨辉三角形
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	SqQueue q;int a,b,i,j;
	SQ_Initiate(&q);
	SQ_In(&q,1);
	for(i=1;i<=n;i++)
	{
		//由第i行产生第i+1行存入队列中，同时将第i行元素依次出队并输出。
		SQ_In(&q,1); //第i+1行的第一个元素1入队
		SQ_Out(&q,&b);printf("" %d"",b); //第i行的一个元素出队并输出
		for(j=1;j<=i-1;j++)
		{
			a=b; //a指向第i行的前一个元素
			SQ_Out(&q,&b);printf("" %d"",b); //第i行的下一个元素b出队并输出
			SQ_In(&q,a+b); //产生第i+1行的一个元素，将其入队
		}
		SQ_In(&q,1); //第i+1行的最后一个元素1入队
		printf(""\n"");
	}
	/********** End **********/
}
```"
316,1920,数据结构-栈基本运算的实现及其应用,nl3j9s2gmu4v,顺序栈的实现,3368,"本关任务对应的参考代码实现如下：
```cpp
void SS_Push(SqStack *S, ElemType e)
// 插入元素e为新的栈顶元素
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SS_IsFull(*S)) return;//栈满
	S->top++; S->elem[S->top]=e;
    /********** End **********/
}

void SS_Pop(SqStack *S, ElemType *e)
// 删除S的栈顶元素，用e返回其值
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SS_IsEmpty(*S)) return; //栈空
	*e=S->elem[S->top]; S->top--;
    /********** End **********/
}

void SS_Top(SqStack S, ElemType *e)
// 获取栈顶元素赋给e
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SS_IsEmpty(S)) return; //栈空	
	*e=S.elem[S.top];	
	/********** End **********/
}
```"
317,1920,数据结构-栈基本运算的实现及其应用,7lts3ekrnumf,链栈的实现,3369,"本关任务对应的参考代码实现如下：
```cpp
//将元素e进栈
void LS_Push(LinkStack *S, ElemType e)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	StackNode *p;
	p=(StackNode *)malloc(sizeof(StackNode));
	p->data=e;
	p->next=*S;
	*S=p;
    /********** End **********/
}

//出栈。出栈元素赋给e
void LS_Pop(LinkStack *S, ElemType *e)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	StackNode *p;
	if(LS_IsEmpty(*S)) return;
	p=*S;
	*e=p->data;
	*S=p->next;
	free(p);
    /********** End **********/
}

//读栈顶元素赋给e。
void LS_Top(LinkStack S, ElemType *e)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(LS_IsEmpty(S)) return;
	*e=S->data;
    /********** End **********/
}
```"
318,1920,数据结构-栈基本运算的实现及其应用,w7bi3jsvrkxz,利用栈实现数制转换,5067,"本关任务对应的参考代码实现如下：
```cpp
void Conversion(int N, int r)
//  利用栈将十进制整数N转换成r进制数（如：二、八、十六进制）
//  输出转换的结果
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	SqStack s;ElemType x;
	SS_Initiate(&s);
    while(N)
    {
		SS_Push(&s,N%r);
        N=N/r;
    }
    while(!SS_IsEmpty(s))
	{
		SS_Pop(&s, &x);
		if(x>=10&&x<=15) printf(""%c"",x+55);
		else printf(""%d"",x);
	}	 
    /********** End **********/
}
```"
319,1918,数据结构-顺序表及其应用,5lvj3okwhm8t,顺序表的实现之查找功能,3365,"本关任务对应的参考代码实现如下：
```cpp
void SL_GetAt(SqList L, int i, ElemType *e)
// 获取顺序表L的第i个元素赋给e，i的有效范围[1,L.length]。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(i<1||i>L.length) {
		printf(""SL_GetAt(): location error when reading elements of the slist!\n"");		
		SL_Free(&L);
		exit(0);
	}
	else 
		*e=L.elem[i-1];
	/********** End **********/
}

int SL_FindValue(SqList L, ElemType x)
// 在顺序表L中查找第一个值为x的元素，找到则返回该元素在表中的位置，否则返回0。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int i;
	for(i=0;i<L.length;i++)
		if(L.elem[i]==x) return i+1;//查找成功，返回位置i+1
	return 0; //查找失败，返回0
	/********** End **********/
}
```"
320,1918,数据结构-顺序表及其应用,ewfis4ytaocg,顺序表的实现之增删功能,3364,"本关任务对应的参考代码实现如下：
```cpp
void SL_InsAt(SqList* L, int i, ElemType e)
// 在顺序表的第i个位置插入新元素e, 即在元素L->elem[i-1]之前插入
// i的有效范围[1,L->length+1]，插入之前要判断表满
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int j;
    if(i<1||i>L->length+1)//i值不合法
	{
		printf(""SL_InsAt(): The value of 'i' is not in the range [1,n+1].\n""); return;
	}
	if(L->length==MAXSIZE)//表满
	{
		printf(""SL_InsAt(): The list is full.\n""); return;
	}
	for(j=L->length-1;j>=i-1;j--)//后移
		L->elem[j+1]=L->elem[j];
	L->elem[i-1]=e;
	L->length++;	
    /********** End **********/
}

void SL_DelAt(SqList* L, int i)
// 删除顺序表L的第i个元素
//i的有效范围[1,L->length]
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int j;
	if(i<1||i>L->length)//i值不合法
	{
		printf(""SL_DelAt(): The value of 'i' is not in the range [1,n].\n""); return;
	}
	for(j=i;j<=L->length-1;j++)//前移
		L->elem[j-1]=L->elem[j];
	L->length--;	
    /********** End **********/
}

void SL_DelValue(SqList* L, ElemType x)
// 删除第一个值为x的元素
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int i;
	for(i=0;i<L->length;i++)
		if(L->elem[i]==x)
		{
			SL_DelAt(L, i+1);break;
		}			
    /********** End **********/
}
```"
321,1918,数据结构-顺序表及其应用,jlkoa7m25srf,顺序表的合并,3650,"本关任务对应的参考代码实现如下：
```cpp
void MergeList_Sq(SqList LA,SqList LB,SqList *LC)
//已知顺序表LA和LB的元素按值非递减排列
//归并LA和LB得到新的顺序表LC，LC的元素也按值非递减排列。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	int i,j,k;
	i=j=k=0; //i,j,k分别存放顺序表LA、LB和LC的元素下标，赋初值为0，
	         //可以理解成i,j,k分别“指向”三个表的第一个元素。
	LC->length=LA.length+LB.length;    //新表长度为待合并两表的长度之和
	while(i<LA.length&&j<LB.length)  //合并
		if(LA.elem[i]<=LB.elem[j]) //选取两表中值较小的元素
			LC->elem[k++]=LA.elem[i++];
		else
			LC->elem[k++]=LB.elem[j++];
	while(i<LA.length)  //将LA的剩余元素赋给LC
		LC->elem[k++]=LA.elem[i++];
	while(j<LB.length)  //将LB的剩余元素赋给LC
		LC->elem[k++]=LB.elem[j++];
	/********** End **********/
} 
```"
322,1915,数据结构-链表及其应用,6b95rsjfuwvy,链表的实现之查找功能,3360,"本关任务对应的参考代码实现如下：
```cpp
void LL_GetAt(LinkList L, int i, ElemType *e)
// 在带头结点的单链表L中获取第i个元素的值赋给e，i的取值范围[1,n]
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LinkList p;int j;
	p=L->next;j=1; //初始化
	while(p&&j<i) //向后扫描，直到p指向第i个元素或p为空
	{	
		p=p->next; ++j;
	}
	if(!p || j>i) //i>n或者i<1，i值不合法
	{
		printf(""LL_GetAt(): The value of 'i' is not in the range [1,n].\n""); return;
	}
	*e=p->data; //取第i个元素
	/********** End **********/
}

LNode *LL_FindValue(LinkList L, ElemType e,int *i)
//在带头结点的单链表L中查找第一个值为e的元素，
//找到则将该元素在链表中的位置赋给i，并返回该结点指针，否则i赋值为0并返回空指针
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LNode *p;
	p=L->next; *i=1; 
	while(p&&p->data!=e)
	{
		p=p->next; (*i)++;
	}
	if(!p) *i=0;
	return p;
	/********** End **********/
}
```"
323,1915,数据结构-链表及其应用,9gaulbv7wm8i,链表的实现之增删功能,3359,"本关任务对应的参考代码实现如下：
```cpp
void LL_InsAt(LinkList L,int i,ElemType e)
// 在带头结点的单链表L中第i个位置插入值为e的新元素，i的取值范围[1,n+1]
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LNode *p,*s; int j;
	p=L;j=0; 
	while(p&&j<i-1)//查找第i-1个结点，p指向该结点
	{
		p=p->next;++j;
	}
	if(!p||j>i-1)	//i>n+1或者i<1，i值不合法
	{
		printf(""LL_InsAt(): The value of 'i' is not in the range [1,n+1].\n""); return;
	}
	s=(LNode *)malloc(sizeof(LNode)); //生成新结点s
	s->data=e; //将结点s的数据域置为e
	s->next=p->next; p->next=s;  //将结点s插入
	/********** End **********/
}

void LL_DelAt(LinkList L,int i)
// 在带头结点的单链表L中，删除第i个元素，i的取值范围[1,n]
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LNode *p,*s; int j;
	p=L;j=0; 
    while(p->next &&j<i-1)//查找第i-1个结点，p指向该结点
	{
		p=p->next; ++j; 
    } 
    if(!(p->next)||j>i-1) //i>n或者i<1，i值不合法
	{
		printf(""LL_DelAt(): The value of 'i' is not in the range [1,n].\n""); return;
	}
	s=p->next; p->next=s->next; free(s); //删除
	/********** End **********/
}

void LL_DelValue(LinkList L, ElemType e)
// 删除第一个值为e的数据元素
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LNode *p,*q;
	p=L->next; q=L; //q指向p所指结点的前驱结点
	while(p&&p->data!=e)
	{
		p=p->next; q=q->next;
	}
	if(p)//找到值为e的元素		
	{
		q->next=p->next; free(p); //删除p所指结点
	}
	/********** End **********/
}
```"
324,1915,数据结构-链表及其应用,bfq4xmwnj3ki,链表的合并,3651,"本关任务对应的参考代码实现如下：
```cpp
void MergeList_L(LinkList LA,LinkList LB,LinkList *LC)
//已知单链表LA和LB的元素按值非递减排列
//归并LA和LB得到新的单链表LC，LC的元素也按值非递减排列。
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LNode *pa,*pb,*pc;
	pa=LA->next;  pb=LB->next;
	pc=(*LC)=LA;  //用LA的头结点作为LC的头结点
	while(pa && pb)
		if(pa->data<=pb->data)
		{
			pc->next=pa;pc=pa;pa=pa->next;
		}
		else
		{
			pc->next=pb; pc=pb; pb=pb->next;
		}
	pc->next=pa?pa:pb;  //插入剩余段
	free(LB);     //释放LB的头结点
	/********** End **********/
}  
```"
325,1953,程序设计实践_C/C++（第一次模拟测试）,i2jz8skb3pfr,106_字符替换,,
326,1953,程序设计实践_C/C++（第一次模拟测试）,6vzsyg25x79t,107_零的个数,,
327,1953,程序设计实践_C/C++（第一次模拟测试）,8huaywojc9fq,108_放硬币,,
328,1953,程序设计实践_C/C++（第一次模拟测试）,l96vqz237nbc,109_可怜的猪,,
329,1953,程序设计实践_C/C++（第一次模拟测试）,xvyue8pl7h56,110_丢鸡蛋,,
330,1953,程序设计实践_C/C++（第一次模拟测试）,8xfgujwer6s2,111_再丢鸡蛋,,
331,1853,程序设计实践_C/C++练习,lb6tz4387f2m,102饮料水,,
332,1853,程序设计实践_C/C++练习,r38aw5fqkiy2,103_搬砖头,,
333,1853,程序设计实践_C/C++练习,qapyrgvt8kix,201_新的数,,
334,1853,程序设计实践_C/C++练习,egw6sratm48q,202_幸运数,,
335,1853,程序设计实践_C/C++练习,49lmgh76rtfs,204_蓄水池,,
336,1853,程序设计实践_C/C++练习,sfgy6r3cepuw,205_背包,,
337,1853,程序设计实践_C/C++练习,7glrmhit9f4j,401_小明抛骰子,,
338,1784,程序设计实践_C/C++,ekgqrxcpi6wf,102饮料水,,
339,1784,程序设计实践_C/C++,wmeth3kgz5vi,103_搬砖头,,
340,1784,程序设计实践_C/C++,jm35tku76qa4,201_新的数,,
341,1784,程序设计实践_C/C++,tkr4couxw7ey,204_蓄水池,,
342,1784,程序设计实践_C/C++,78twxmvp6j9i,205_背包,,
343,1784,程序设计实践_C/C++,c8ib4g2zewut,401_小明抛骰子,,
344,1756,程序设计实践_C/C++,ntq37g5osval,101_求最长的公共字符串,,
345,1756,程序设计实践_C/C++,z62amt7kyoeu,102饮料水,,
346,1756,程序设计实践_C/C++,6fe4ztbao2kf,103_搬砖头,,
347,1756,程序设计实践_C/C++,otvng28plxfr,201_新的数,,
348,1756,程序设计实践_C/C++,jmt6lgz9iny3,202_幸运数,,
349,1756,程序设计实践_C/C++,x7m3nsg4pav2,203 拆开正整数n,,
350,1756,程序设计实践_C/C++,p8ausb7jc6xn,204_蓄水池,,
351,1756,程序设计实践_C/C++,yvpuszogq95m,205_背包,,
352,1756,程序设计实践_C/C++,3raxhstpv9u5,301_粉刷匠的难题,,
353,1756,程序设计实践_C/C++,ntoxawfj8vgi,401_小明抛骰子,,
354,1673,算法与竞赛(第15章) - 矩阵高级运算,w824yqbl9tgc,矩阵（方阵）行列式,2972,"```cpp
    int Determinant_1 (){
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        Matrix D = *this;
        int det = D.val[0][0];
        return det;
        
        /********* End *********/
    }
    int Determinant_2 (){
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        Matrix D = *this;
        int det = D.val[0][0]*D.val[1][1]-D.val[0][1]*D.val[1][0];
        return det;
        
        /********* End *********/
    }
    int Determinant_3 (){
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        Matrix D = *this;
        int det = D.val[0][0]*D.val[1][1]*D.val[2][2]
                    +D.val[1][0]*D.val[2][1]*D.val[0][2]
                    +D.val[2][0]*D.val[0][1]*D.val[1][2]
                    -D.val[0][0]*D.val[2][1]*D.val[1][2]
                    -D.val[1][0]*D.val[0][1]*D.val[2][2]
                    -D.val[2][0]*D.val[1][1]*D.val[0][2];
        return det;
        
        /********* End *********/
    }
    int Inverse_Number(int n, int arr[]){
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        int num = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                if(arr[j]>arr[i]){
                    num++;
                }
            }
        }
        return num;
        
        /********* End *********/
    }
    int Determinant_n (){
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        Matrix D = *this;
        int det = 0;
        int *arr;
        arr = (int*)malloc(sizeof(int)*D.n);
        for(int i=0;i<D.n;i++){
            arr[i] = i;
        }
        
        do{
            int inv = Inverse_Number(D.n, arr);
            int tmp = (inv%2==0)?1:-1;
            for(int i=0;i<D.n;i++){
                tmp *= D.val[i][arr[i]];
            }
            det += tmp;
        }while(next_permutation(arr, arr+D.n));
            
        return det;
        
        /********* End *********/
    }
    
```"
355,1673,算法与竞赛(第15章) - 矩阵高级运算,s4kb3tnif8mg,矩阵逆运算,2973,"```cpp
    double Cofactor (int x, int y) {
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        Matrix C = Matrix(this->n-1,this->n-1);
        for(int i=0;i<x;i++){
            for(int j=0;j<y;j++){
                C.val[i][j] = this->val[i][j];
            }
        }
        for(int i=0;i<x;i++){
            for(int j=y+1;j<this->n;j++){
                C.val[i][j-1] = this->val[i][j];
            }
        }
        for(int i=x+1;i<this->n;i++){
            for(int j=0;j<y;j++){
                C.val[i-1][j] = this->val[i][j];
            }
        }
        for(int i=x+1;i<this->n;i++){
            for(int j=y+1;j<this->n;j++){
                C.val[i-1][j-1] = this->val[i][j];
            }
        }
        
        double det_c = C.Determinant();
        return det_c;
        
        /********* End *********/
    }
    
    Matrix Adjugate_Matrix () {
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        Matrix A = Matrix(this->n, this->n);
        
        for(int i=0;i<A.n;i++){
            for(int j=0;j<A.n;j++){
                int flag = ((i+j)%2==0)?1:-1;
                int M_ij = Cofactor(i, j);
                A.val[j][i] = flag * M_ij;
            }
        }
        
        return A;
        
        /********* End *********/
    }
    
    Matrix Inverse_Matrix (){
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        double det = Determinant();
        if(det == 0){
            printf(""error\n"");
            return Matrix();
        }
        
        Matrix I = Matrix(this->n, this->n);
        Matrix A = Matrix(this->n, this->n);
        A = Adjugate_Matrix();
        I = A * (1./det);
        
        return I;
        
        /********* End *********/
    }
    
    bool Identity_Matrix() {
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        for(int i=0;i<this->n;i++){
            for(int j=0;j<this->n;j++){
                if(i==j){
                    if(sig(this->val[i][j]-1)!=0){
                        return false;
                    }
                }else {
                    if(sig(this->val[i][j]-0)!=0){
                        return false;
                    }
                }
            }
        }
        return true;
        
        /********* End *********/
    }
```"
356,1673,算法与竞赛(第15章) - 矩阵高级运算,rpusf4kebn73,矩阵初等变换,2974,"```cpp
    Matrix Elementary_Row_Transformation (){
        
        Matrix R = Matrix(this->n, this->n*2);
        for(int i=0;i<this->n;i++){
            for(int j=0;j<this->n;j++)
                R.val[i][j] = this->val[i][j];
            for(int j=this->n;j<this->n*2;j++)
                R.val[i][j] = ((j-this->n)==i)?1:0;
        }
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        //R.out();printf(""\n"");
        for(int i=0;i<R.m;i++){
            double flag = R.val[i][i];
            for(int j=i;j<R.n;j++){
                R.val[i][j] /= flag;
            }
            for(int k=i+1;k<R.m;k++){
                flag = R.val[k][i];
                for(int j=i;j<R.n;j++){
                    R.val[k][j] -= flag * R.val[i][j];
                }
            }
        }
        //R.out();printf(""\n"");
        for(int i=R.m-1;i>=0;i--){
            double flag = R.val[i][i];
            for(int j=i;j<R.n;j++){
                R.val[i][j] /= flag;
            }
            for(int k=i-1;k>=0;k--){
                flag = R.val[k][i];
                for(int j=k;j<R.n;j++){
                    R.val[k][j] -= flag * R.val[i][j];
                }
            }
        }
        
        /********* End *********/
        
        return R;
    }
    
    Matrix Elementary_Col_Transformation (){
        
        Matrix C = Matrix(this->n*2, this->n);
        for(int j=0;j<this->n;j++){
            for(int i=0;i<this->n;i++)
                C.val[i][j] = this->val[i][j];
            for(int i=this->n;i<this->n*2;i++)
                C.val[i][j] = ((i-this->n)==j)?1:0;
        }
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        //C.out();printf(""\n"");
        for(int j=0;j<C.n;j++){
            double flag = C.val[j][j];
            for(int i=j;i<C.m;i++){
                C.val[i][j] /= flag;
            }
            for(int k=j+1;k<C.n;k++){
                flag = C.val[j][k];
                for(int i=j;i<C.m;i++){
                    C.val[i][k] -= flag * C.val[i][j];
                }
            }
        }
        //C.out();printf(""\n"");
        for(int j=C.n-1;j>=0;j--){
            double flag = C.val[j][j];
            for(int i=j;i<C.m;i++){
                C.val[i][j] /= flag;
            }
            for(int k=j-1;k>=0;k--){
                double flag = C.val[j][k];
                for(int i=j;i<C.m;i++){
                    C.val[i][k] -= flag * C.val[i][j];
                }
            }
        }
        
        /********* End *********/
        
        return C;
    }
```"
357,1715,算法设计与分析：回溯法算法思想的应用,cz3q6xh9mof5,n位逐位整除数,3056,"```cpp

void backtrack(int *a, int t, int n, int &sum)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    if (t > n) {
        sum++;
        return;
    }
    if (t==1) {
        for (int i=1; i<=9; i++) {
            a[t] = i;
            backtrack(a, t+1, n, sum);
        }
    }
    else {
        for (int i=0; i<=9; i++) {
            a[t] = i;
            int r = 0;
            for (int j=1; j<=t; j++) {
                r = r * 10 + a[j];
                r = r % t;
            }
            if (r == 0) {
                backtrack(a, t+1, n, sum);
            }
        }
    }
    
    /********* End *********/
}

```"
358,1713,算法设计与分析：贪心算法思想的应用,4huoct9a56ny,删除数字问题,3050,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    scanf(""%s"", s);
    scanf(""%d"", &k);
    
    n = (int)strlen(s);
    
    for (int i=0; i<n; i++) {
        a[i] = s[i] - '0';
    }
    
    // 方式一：暴力搜索
    for (int k_=0; k_<k; k_++) {
        for (int i=0; i<n; i++) {
            while (i<n && a[i]==-1) {
                i++;
            }
            int j = i+1;
            while (j<n && a[j]==-1) {
                j++;
            }
            if (i<n && j<n && a[i]<a[j]) {
                a[i] = -1;
                break;
            }
        }
    }

    /*
    // 方式二：维护单调性
    for (int i=0, j=1, x=0; x<k && j<n; ) {
        if (i>=0 && a[i]<a[j]) {
            x++;
            a[i] = -1;
            while (i>=0 && a[i]==-1) {
                i--;
            }
        }
        else {
            i = j;
            j++;
        }
    }
    */
    
    for (int i=0, x=0; x+k<n; i++) {
        if (a[i] != -1) {
            printf(""%d"", a[i]);
            x++;
        }
    }
    printf(""\n"");

    /********* End *********/
```"
359,1706,程序设计一_实训10_文件操作,pklm8oh2af4b,读取文本文件,,
360,1706,程序设计一_实训10_文件操作,fnye7wjo3f6a,写文本文件,,
361,1706,程序设计一_实训10_文件操作,l9bx3fjufmi4,二进制文件的读取,,
362,1709,算法设计与分析：动态规划算法思想的应用,9rvxaugtlyjm,最长非降子序列(非连续)问题,3040,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int n;
    int arr[maxn];
    int dp[maxn];
    int id[maxn];
    int maxl, maxid;
    
    scanf(""%d"", &n);
    for (int i=0; i<n; i++) {
        scanf(""%d"", &arr[i]);
    }
    
    memset(dp, 0, sizeof(dp));
    maxl = 1;
    maxid = n-1;
    dp[n-1] = 1;
    id[n-1] = n-1;
    for (int i=n-2; i>=0; i--) {
        dp[i] = 1;
        id[i] = i;
        for (int j=i+1; j<n; j++) {
            if (arr[i]<=arr[j] && dp[i]<=dp[j]+1) {
                dp[i] = dp[j]+1;
                id[i] = j;
            }
        }
        if (maxl < dp[i]) {
            maxl = dp[i];
            maxid = i;
        }
    }
    
    printf(""%d"", arr[maxid]);
    maxid = id[maxid];
    maxl--;
    while (maxl--) {
        printf("" %d"", arr[maxid]);
        maxid = id[maxid];
    }
    printf(""\n"");
    
    /********* End *********/
```"
363,1708,算法设计与分析：枚举和递推的运用,l67nihf5wcvr,双关系递推数列,3034,"```cpp
// 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for(int i=2;i<=n;i++)
    {
        if(2*m[p2]+1 < 5*m[p5]-1)
        {
            m[i]=2*m[p2]+1;
            p2++;
            
        }
        else if(2*m[p2]+1 > 5*m[p5]-1)
        {
            m[i]=5*m[p5]-1;
            p5++;
        }
        else if(2*m[p2]+1 == 5*m[p5]-1)
        {
            m[i]=5*m[p5]-1;
            p2++;
            p5++;
        }
    }
    
    /********* End *********/
```"
364,1693,算法设计与分析：大整数的加减乘除运算,l7ant63g2isj,大整数的加减乘除运算,3020,"```cpp

int calc(int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int a[N] = {0};
    int c[N] = {0};
    a[N-1] = 1;
    for (int i=2; i<=n; i++) {
        mul1(a, i, c);
        for (int j=0; j<N; j++) {
            a[j] = c[j];
            c[j] = 0;
        }
    }
    int tot = 0;
    /*  方法一
    while (1) {
        bool flag = true;
        for (int i=0; i<N; i++) {
            if (a[i]) {
                flag = false;
                break;
            }
        }
        if (flag) {
            break;
        }
        int r = div(a, 10, c);
        if (r==0) {
            tot++;
        }
        // a = 10 * c + r
        for (int j=0; j<N; j++) {
            a[j] = c[j];
            c[j] = 0;
        }
    }
     */
    // 方法二
    int tmp = 0;
    bool flag = true;
    for (int i=0; i<N; i++) {
        if (flag && a[i]==0) {
            continue;
        }
        if (flag) {
            tmp = a[i];
            flag = false;
        }
        else {
            tmp = a[i] + K;
        }
        while (tmp) {
            if (tmp % 10 == 0) {
                tot++;
            }
            tmp /= 10;
        }
    }
    
    return tot;
    
    /********* End *********/
}

```"
365,1675,C++ 面向对象程序设计 实验一,efs832aqxy7l,最大值函数,10764,"```c++
int Max(int a,int b)
{
    /********* Begin *********/

    //找出两个参数中最大的那个并返回
	return a > b?a : b;
    /********* End *********/
}
int Max(int a,int b,int c)
{
    /********* Begin *********/

    //找出三个参数中最大的那个并返回
	return Max(a,Max(b,c));
    /********* End *********/
}

```"
366,1675,C++ 面向对象程序设计 实验一,uhgtlroi3f6n,计算阶乘,10765,"`fact.h`文件：
```c++
/********* Begin *********/

#ifndef FACT_H_
#define FACT_H_
int Fact(int n);
#endif

/********* End *********/
```

`fact.cpp`文件：
```c++
int Fact(int n)
{
    /********* Begin *********/

    if(n > 0)
        return n * Fact(n - 1);
    return 1;
    /********* End *********/
}
```"
367,1675,C++ 面向对象程序设计 实验一,s5ib8kefwlyg,求矩阵最大元素,10766,"```c++

int MaxEle(int a[3][2],int *r,int *c)
{
    /********* Begin *********/

    //返回最大元素和它所在的行、列号
	int mr = 0,mc = 0;
    for(int dr = 0;dr < 3;dr++)
    {
        for(int dc = 0;dc < 2;dc++)
        {
            if(a[dr][dc] > a[mr][mc])
            {
                mr = dr;
                mc = dc;
            }
        }
    }
    *r = mr + 1;
    *c = mc + 1;
    return a[mr][mc];
    /********* End *********/
}

```"
368,1675,C++ 面向对象程序设计 实验一,h2n7flkbtfw4,使用链表进行学生信息管理,10767,"```c++
#include <iostream>
using namespace std;


struct Linked
{
/********* Begin *********/
	int num;
    float score;
    Linked *next;
/********* End *********/
};

Linked* Create()
{
    /********* Begin *********/

    Linked *head = new Linked;
    head->next = 0; //初始化为0
    return head;

    /********* End *********/
}

void InsertAfter(Linked *node,int num,float sc)
{
    /********* Begin *********/

    Linked *n = new Linked;
    n->num = num;
    n->score = sc;
    n->next = node->next;
    node->next = n;

    /********* End *********/
}

void DeleteAfter(Linked *node)
{
    /********* Begin *********/

    node->next = node->next->next;

    /********* End *********/
}

Linked* GetByIndex(Linked *head,int index)
{
    /********* Begin *********/

    Linked *ptr = head->next;
    while(index)
    {
        ptr = ptr->next;
        index--;
    }
    return ptr;

    /********* End *********/
}

void PrintAll(Linked *head)
{
    /********* Begin *********/

    Linked *ptr = head->next;
    while(ptr)
    {
        cout << ptr->num << "" "" << ptr->score << endl;
        ptr = ptr->next;
    }

    /********* End *********/
}


```"
369,1540,程序设计一_实训9_函数与结构体,kgl3xn2esja7,在一个函数中求取一组数的最大值与最小值并用结构体返回,,
370,1540,程序设计一_实训9_函数与结构体,s3tg7vuy5wc9,在一个函数中求取一组数的最大值与最小值并用引用参数返回,,
371,1540,程序设计一_实训9_函数与结构体,8ugzhti9f42m,函数重载以及输入参数与输出参数,,
372,1621,算法与竞赛(第14章) - 矩阵基本运算,zb8hqg7kpij5,运用矩阵求解A+rX=B,2889,"```cpp
    Matrix operator + (const Matrix B)const{
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        int m_ = this->m;
        int n_ = this->n;
        Matrix A = *this;
        Matrix M(m_, n_);
        if(A.m!=B.m || A.n!=B.n){
            printf(""error\n"");
        }
        for(int i=0;i<m_;i++){
            for(int j=0;j<n_;j++){
                M.val[i][j] = A.val[i][j] + B.val[i][j];
            }
        }
        return M;
        
        /********* End *********/
        
    }

    Matrix operator - (const Matrix B)const{
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        int m_ = this->m;
        int n_ = this->n;
        Matrix A = *this;
        Matrix M(m_, n_);
        if(A.m!=B.m || A.n!=B.n){
            printf(""error\n"");
        }
        for(int i=0;i<m_;i++){
            for(int j=0;j<n_;j++){
                M.val[i][j] = A.val[i][j] - B.val[i][j];
            }
        }
        return M;
        
        /********* End *********/
    }
    Matrix operator * (const double r)const{
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        int m_ = this->m;
        int n_ = this->n;
        Matrix A = *this;
        Matrix M(m_, n_);
        for(int i=0;i<m_;i++){
            for(int j=0;j<n_;j++){
                M.val[i][j] = A.val[i][j] * r;
            }
        }
        return M;
        
        /********* End *********/
    }
```"
373,1621,算法与竞赛(第14章) - 矩阵基本运算,pofvcm5hbitx,矩阵乘法的运用,2891,"```cpp
    Matrix operator * (const Matrix B)const{
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        Matrix A = *this;
        Matrix M(A.m, B.n);
        if(A.n!=B.m){
            printf(""error\n"");
        }
        for(int i=0;i<A.m;i++){
            for(int j=0;j<B.n;j++){
                double sum = 0;
                for(int k=0;k<A.n;k++){
                    sum += A.val[i][k] * B.val[k][j];
                }
                M.val[i][j] = sum;
            }
        }
        return M;
        
        /********* End *********/
        
    }
```"
374,1621,算法与竞赛(第14章) - 矩阵基本运算,of5ptmw34bl2,矩阵转置的运用,2892,"```cpp
    Matrix Transpose ()const{
        // 请在这里补充代码，完成本关任务
        /********* Begin *********/
        int m_ = this->m;
        int n_ = this->n;
        Matrix A = *this;
        Matrix M(n_, m_);
        
        for(int i=0;i<m_;i++){
            for(int j=0;j<n_;j++){
                M.val[j][i] = A.val[i][j];
            }
        }
        
        return M;
        
        /********* End *********/
        
    }
```"
375,1493,算法与竞赛(第13章) - 计数进阶,9p7ehu3wjxa8,约数个数,2794,"```cpp
int Divisor_Count(int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int ans = 1;
    int m = (int)sqrt(n+0.5)+1;
    int cnt = 0;
    for (int i=2; i<=m; i++) {
        if (n%i==0) {
            cnt = 0;
            while (n%i==0) {
                n /= i;
                cnt++;
            }
            ans = ans * (cnt+1);
        }
    }
    if (n!=1) {
        ans = ans * 2;
    }
    return ans;
    
    /********* End *********/
}
```"
376,1493,算法与竞赛(第13章) - 计数进阶,8espun2a53zy,数三角形,2795,"```cpp
void Triangle_Count(int64 C[maxn], int64 n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/

    C[0] = C[1] = C[2] = C[3] = 0;
    for (int64 i = 4; i<=n; i++) {
        C[i] = C[i-1] + ((i-1)*(i-2)/2 - (i-1)/2) / 2;
    }
    
    /********* End *********/
}

```"
377,1493,算法与竞赛(第13章) - 计数进阶,ghx7jvm46knf,单色三角形,2796,"```cpp

int main(int argc, const char * argv[]) {
    
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int n, m;
    vector<int> edge[maxn];
    scanf(""%d %d"", &n, &m);
    for (int i=0; i<m; i++) {
        int u, v;
        scanf(""%d %d"", &u, &v);
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    
    int ans = 0;
    for (int i=1; i<=n; i++) {
        ans += edge[i].size()*(n-1-edge[i].size())/2;
    }
    ans = (n*(n-1)*(n-2))/6-ans;
    printf(""%d\n"", ans);
    
    /********* End *********/
    
    return 0;
}

```"
378,1492,算法与竞赛(第12章) - 计数基础,j3v5po9azblk,组合数学之排列问题,2791,"```cpp
int64 Factorial(int64 n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    /*
    if(n==0){
        return 1;
    }
    else{
        return n*Factorial(n-1);
    }
    */
    int64 ans = 1;
    for (int64 i=n; i>=1; i--) {
        ans *= i;
    }
    return ans;
    
    /********* End *********/
}

int64 Permutation(int64 n, int64 k)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    /*
    int64 n_ = Factorial(n);
    int64 k_ = Factorial(n-k);
    return n_/k_;
    */
    int64 ans = 1;
    for (int64 i=n; i>=n-k+1; i--) {
        ans *= i;
    }
    return ans;
    
    /********* End *********/
}

```"
379,1492,算法与竞赛(第12章) - 计数基础,a6wff4us3hox,组合数学之组合问题,2792,"```cpp
int64 Factorial(int64 n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    /*
     if(n==0){
     return 1;
     }
     else{
     return n*Factorial(n-1);
     }
     */
    int64 ans = 1;
    for (int64 i=n; i>=1; i--) {
        ans *= i;
    }
    return ans;
    
    /********* End *********/
}

int64 Combination(int64 n, int64 k)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int64 n_ = Factorial(n);
    int64 k_ = Factorial(k);
    int64 n_k = Factorial(n-k);
    return n_/k_/n_k;
    
    /********* End *********/
}
```"
380,1492,算法与竞赛(第12章) - 计数基础,n6jut9aoyef8,二项式展开与杨辉三角,2793,"```cpp
void Combination_Table(int64 C[maxn][maxn], int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    C[0][0] = 1;
    C[1][0] = C[1][1] = 1;
    for (int i=2; i<=n; i++) {
        C[i][0] = C[i][i] = 1;
        for (int j=1; j<i; j++) {
            C[i][j] = C[i-1][j-1]+C[i-1][j];
        }
    }
    
    /********* End *********/
}

void Combination_Only(int64 C[maxn], int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    C[0] = 1;
    for (int i=1; i<=n; i++) {
        C[i] = C[i-1] * (n-i+1) / i;
    }
    
    /********* End *********/
}
```"
381,1604,C++ 面向对象程序设计 实验七,m2ws5zfnu68k,病毒复制,10784,"```c++

class Virus
{
/********* Begin *********/

//病毒类的声明
public:
    int Gen;
    Virus(); //增加一个无参的构造函数，用于支持对象数组
    Virus(const Virus &v);

/********* End *********/
};

/********* Begin *********/

//病毒类的定义以及其他内容
Virus::Virus()
:Gen(0)
{}
Virus::Virus(const Virus &v)
:Gen(v.Gen + 1)
{}
bool operator==(const int& g,const Virus &v)
{
    return g == v.Gen;
}
/********* End *********/


```"
382,1604,C++ 面向对象程序设计 实验七,v2b4ofi8er65,动态学生信息管理,10785,"```c++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

/********* Begin *********/

//自定义的类或者其他内容
class Student
{
public:
    string Name;
    int Score;
    Student();
    Student(string name,int sc);
};
Student::Student(){}
Student::Student(string name,int sc)
:Name(name),Score(sc)
{}
bool operator==(const Student &stu,const string &name) //用于支持find函数
{
    return name == stu.Name;
}
bool operator<(const Student &s1,const Student &s2)
{
    return s1.Score > s2.Score; //要求降序排列，所以<运算符的逻辑反着来
}

/********* End *********/

int main()
{
    /********* Begin *********/

    //读取输入，执行动作
vector<Student> list;
    string cmd;
    while(cin >> cmd)
    {
        if(cmd == ""A"")
        {
            string name;
            int sc;
            cin >> name >> sc;
            vector<Student>::iterator it = find(list.begin(),list.end(),name);
            if(it == list.end())
                list.push_back(Student(name,sc));
            else
                it->Score = sc;
        }
        else if(cmd == ""R"")
        {
            string name;
            cin >> name;
            vector<Student>::iterator it = find(list.begin(),list.end(),name);
            if(it != list.end())
                list.erase(it);
        }
        else if(cmd == ""P"")
        {
            if(list.empty())
            {
                cout << ""[空]"" << endl;
            }
            else
            {
                for(vector<Student>::iterator it = list.begin();it != list.end();it++)
                {
                    cout << it->Name << "" "" << it->Score << endl;
                }
            }
        }
        else if(cmd == ""S"")
        {
            sort(list.begin(),list.end());
        }
	}
    /********* End *********/
}



```"
383,1604,C++ 面向对象程序设计 实验七,wfqk6pzo39m7,还原键盘输入,10787,"```c++
#include <iostream>
#include <string>
#include <list>
using namespace std;

int main()
{
    /********* Begin *********/

    //读取输入，解析并输出复原后的输出
 string str;
    while(cin >> str)
    {
        list<char> inputs;
        list<char>::iterator cur = inputs.begin();
        for(int s =0;s < str.length();s++)
        {
            if(str[s] == '<')
            {
                if(cur != inputs.begin())
                    cur--;
            }
            else if(str[s] == '>')
            {
                if(cur != inputs.end())
                    cur++;
            }
            else if(str[s] == '[')
            {
                cur = inputs.begin();
            }
            else if(str[s] == ']')
            {
                cur = inputs.end();
            }
            else
            {
                inputs.insert(cur,str[s]);
            }
        }
        for(list<char>::iterator it = inputs.begin();it != inputs.end();it++)
            cout << *it;
        cout << endl;
    }
    /********* End *********/
}


```"
384,1566,算法竞赛入门经典(第2版)_4_循环练习题,rejqn38hf9ts,韩信点兵,2848,"```cpp
/***begin your code here***/
#include <bits/stdc++.h>
using namespace std;

int main(){
    int a,b,c;
    for(int kase=1;3==scanf(""%d%d%d"",&a,&b,&c);++kase){
        int ans = 10;
        while(ans<=100){
            if(ans%3==a&&ans%5==b&&ans%7==c)break;
            ++ans;
        }
        if(ans<=100)printf(""Case %d: %d\n"",kase,ans);
        else printf(""Case %d: No answer\n"",kase);
    }
    return 0;     
}
```"
385,1566,算法竞赛入门经典(第2版)_4_循环练习题,a89tkwrjflc5,倒三角形,2849,"```cpp
/***begin your code here***/
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n;
    scanf(""%d"",&n);
    for(int i=n;i>=1;--i){
        for(int j=0;j<n-i;++j)printf("" "");
        for(int j=0;j<i+i-1;++j)printf(""#"");
        printf(""\n"");
    }
    return 0;     
}
```"
386,1566,算法竞赛入门经典(第2版)_4_循环练习题,6razunj7feyg,子序列的和,2850,"```cpp
/***begin your code here***/
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m;
    for(int kase=1;scanf(""%d%d"",&n,&m);++kase){
        if(0==n&&0==m) break;
        
        double s = 0.0;
        for(int i=n;i<=m;++i){
            s = s + 1.0 / i / i;
        }
        printf(""Case %d: %.5lf\n"",kase,s);
    }
    return 0;     
}
```"
387,1566,算法竞赛入门经典(第2版)_4_循环练习题,2kyhsjzpwnot,分数化小数,2851,"```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    //freopen(""1.txt"",""r"",stdin);
    int a,b,c;
    for(int kase=1;scanf(""%d%d%d"",&a,&b,&c);++kase){
        if(0==a&&0==b&&0==c) break;
        
        printf(""Case %d: "",kase);
        
        int zheng = a / b;
        printf(""%d."",zheng);
        
        int xiao = a % b;
        for(int i=0;i<c-1;++i){
            zheng = xiao*10/b;
            printf(""%d"",zheng);
            xiao = xiao*10%b;
        }
        //最后一位
        zheng = xiao*100/b;
        if(zheng%10>=5)printf(""%d"",zheng/10+1);
        else printf(""%d"",zheng/10);
        printf(""\n"");
    }
    return 0;     
}
```"
388,1566,算法竞赛入门经典(第2版)_4_循环练习题,gjfcu3fyvtnk,排列,,
389,1522,C++ 面向对象程序设计 实验六,w2rxqpmh6tca,复数运算,10794,"```c++
#include <iostream>
using namespace std;

class Complex
{
/********* Begin *********/

private:
    float real;
    float image;
public:
    Complex(float r,float i);
    void Print();
    Complex operator+(Complex &c2); //成员变量都是私有的，那运算符重载函数也都做成私有的
    Complex operator-(Complex &c2);
    Complex operator*(Complex &c2);

/********* End *********/
};

/********* Begin *********/

Complex::Complex(float r,float i):real(r),image(i)
{}
void Complex::Print()
{
    if(image >= 0)
        cout << real << ""+"" << image << ""i"" << endl; //非负数不带+号，手动添加上去
    else
        cout << real << image << ""i"" << endl;
}
Complex Complex::operator+(Complex &c2)
{
    return Complex(real + c2.real,image + c2.image);
}
Complex Complex::operator-(Complex &c2)
{
    return Complex(real - c2.real,image - c2.image);
}
Complex Complex::operator*(Complex &c2)
{
    return Complex(real * c2.real - image * c2.image,real * c2.image + image * c2.real); //(r1 + v1i)(r2 + v2i) = (r1r2 - v1v2) + (r1v2 + r2v1)i
}

/********* End *********/


```"
390,1522,C++ 面向对象程序设计 实验六,sc7hr8fltmqx,学生信息转换,10796,"```c++
#include <iostream>
#include <string>
using namespace std;

/********* Begin *********/

class Teacher; //前置声明Teacher类

/********* End *********/

class Student
{
/********* Begin *********/

public:
    int number;
    string name;
    string sex;
    friend Teacher Convert(Student st); //访问性随意
public:
    Student(int num,string nam,string se);
    void Print();

/********* End *********/
};
/********* Begin *********/

Student::Student(int num,string nam,string se)
:number(num),name(nam),sex(se)
{}

void Student::Print()
{
    cout << ""学生 "" << number << "" "" << name <<"" "" <<sex<<endl;
}


/********* End *********/


class Teacher
{
/********* Begin *********/

public:
    int number;
    string name;
    string sex;
public:
    Teacher(const Student &t);
    friend Teacher Convert(Student st); //访问性随意
    void Print();

/********* End *********/
};
/********* Begin *********/

Teacher::Teacher(const Student &st)
{
    number = st.number;
    name = st.name;
    sex = st.sex;
}
void Teacher::Print()
{
    cout << ""教师 "" << number << "" "" << name <<"" "" <<sex<<endl;
}

/********* End *********/

```"
391,1522,C++ 面向对象程序设计 实验六,ptbinfjzur92,综合 矩阵运算,10799,"```c++
#include <iostream>
#include <string>
using namespace std;


class Matrix
{
/********* Begin *********/

private:
    int row,col; //行，列
    int **data; //存放数据
public:
    Matrix(int r,int c);
    ~Matrix(); //新增一个析构函数，用于释放data所占空间
    void Fill(int value);
    void Set(int r,int c,int value);
    int Get(int r,int c);
    void Print();
    friend Matrix operator+(Matrix&,Matrix&);
    friend Matrix operator-(Matrix&,Matrix&);
    friend Matrix operator*(Matrix&,Matrix&);

/********* End *********/
};
/********* Begin *********/

Matrix::Matrix(int r,int c)
:row(r),col(c)
{
    data = new int*[r]; //指针的数组
    for(int s = 0;s < r;s++)
        data[s] = new int[c]; //每一个元素各指向一个长度为c的数组
}
Matrix::~Matrix()
{
    for(int s =0;s < row;s++) //对象销毁的时候释放动态分配的资源
        delete[] data[s];
    delete[] data;
}
void Matrix::Fill(int value)
{
    for(int r = 0;r < row;r++)
        for(int c = 0;c < col;c++)
            data[r][c] = value;
}
void Matrix::Set(int r,int c,int value)
{
    data[r][c] = value;
}
int Matrix::Get(int r,int c)
{
    return data[r][c];
}
void Matrix::Print()
{
    for(int r = 0;r < row;r++)
    {
        for(int c = 0;c < col;c++)
            cout << data[r][c] << "" "";
        cout << endl;
    }
}

/********* End *********/

Matrix operator+(Matrix& m1,Matrix &m2)
{
    /********* Begin *********/

    Matrix ma(m1.row,m1.col);
    for(int r = 0;r < m1.row;r++)
    {
        for(int c = 0;c < m1.col;c++)
        {
            ma.data[r][c] = m1.data[r][c] + m2.data[r][c];
        }
    }
    return ma;
}

    /********* End *********/

Matrix operator-(Matrix& m1,Matrix &m2)
{
    /********* Begin *********/

    Matrix ma(m1.row,m1.col);
    for(int r = 0;r < m1.row;r++)
    {
        for(int c = 0;c < m1.col;c++)
        {
            ma.data[r][c] = m1.data[r][c] - m2.data[r][c];
        }
    }
    return ma;

    /********* End *********/
}

Matrix operator*(Matrix& m1,Matrix &m2)
{
    /********* Begin *********/

    Matrix ma(m1.row,m2.col);
    for(int r = 0;r < m1.row;r++)
    {
        for(int c = 0;c < m2.col;c++)
        {
            int sum = 0;
            for(int d = 0;d < m1.col;d++)
                sum += m1.data[r][d] * m2.data[d][c];
            ma.data[r][c] = sum;
        }
    }
    return ma;

    /********* End *********/
}
```"
392,1500,程序设计一_实训8_函数参数训练,7yxhuitprjew,第二大的数,,
393,1500,程序设计一_实训8_函数参数训练,5rn9zuqew2y6,第二大的数again,,
394,1500,程序设计一_实训8_函数参数训练,fymurfioavxq,小规模伪随机数列的众数,,
395,1500,程序设计一_实训8_函数参数训练,6hzrtpsc7fvg,交换,,
396,1500,程序设计一_实训8_函数参数训练,emaskvpt6f35,字符串查找以及使用const修饰参数,,
397,1500,程序设计一_实训8_函数参数训练,5grofnahqxcl,最长回文子串,,
398,1480,算法竞赛入门经典(第2版)_3_输入输出,48ge5khmztbi,已知数量的输入和基本输出,2772,"```cpp
#include <bits/stdc++.h>

int main(){
    int nofkase;
    scanf(""%d"",&nofkase);
    for(int kase=1;kase<=nofkase;++kase){
        int a,b;
        scanf(""%d%d"",&a,&b);
        printf(""%d\n"",a+b);
    }
    return 0;
}

```"
399,1480,算法竞赛入门经典(第2版)_3_输入输出,m84c9ht3fieu,未知数量的输入与输出之间间隔一行,2773,"```cpp
#include <bits/stdc++.h>

int main(){
    int a,b;
    int flag = 0;
    while(scanf(""%d%d"",&a,&b),(a||b)){
        if(flag) printf(""\n"");
        flag = 1;
        printf(""%d\n"",a+b);
    }
    return 0;
}

```"
400,1480,算法竞赛入门经典(第2版)_3_输入输出,giancyu2hovt,判断输入的结束以及输出案例序号,2781,"```cpp
#include <bits/stdc++.h>

int main(){
    int a,b;
    for(int kase=1;2==scanf(""%d%d"",&a,&b);++kase){
        printf(""Case %d:%d\n"",kase,a+b);
    }
    return 0;
}

```"
401,1480,算法竞赛入门经典(第2版)_3_输入输出,rzft8vac4lkj,好多输入和好多输出,2803,"```cpp
#include <bits/stdc++.h>

int main(){
    int n;    
    for(int kase=1;scanf(""%d"",&n);++kase){
        if(-1==n) break;
        int mmax = -10000000;
        int tta,ttb;
        for(int i=0;i<n;++i){
        	int a,b;
            scanf(""%d%d"",&a,&b);
            if(mmax<a+b||(mmax==a+b&&a<tta)){
                mmax = a + b;
                tta = a;
                ttb = b;
            }
        }
        if(kase>1) printf(""\n"");
        printf(""Case: %d\n%d %d\n"",kase,tta,ttb);
    }
    return 0;
}

```"
402,1406,算法与竞赛(第11章) - 数论进阶,8uag2ejxfm7b,模算术,2687,"```cpp

int64 mul_mod(int64 a, int64 b, int64 n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    return a * b % n;
    
    /********* End *********/
}

int64 pow_mod(int64 a, int64 p, int64 n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    /*
    if (p==0) {
        return 1;
    }
    int64 ans = pow_mod(a, p/2, n);
    //ans = ans * ans % n;
    ans = mul_mod(ans, ans, n);
    if (p%2 == 1) {
        //ans = ans * a % n;
        ans = mul_mod(ans, a, n);
    }
    return ans;
     */
    //*
    int64 ans = 1;
    while (p) {
        if (p%2 == 1) {
            ans = ans * a % n;
        }
        a = a * a % n;
        p = p / 2;
    }
    return ans % n;
    //*/
    
    /********* End *********/
}

```"
403,1406,算法与竞赛(第11章) - 数论进阶,ai6sqxlpfczb,欧拉函数,2688,"```cpp
const int maxn = 1007;
int phi[maxn+1];

int euler_phi(int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int m = (int)sqrt(n+0.5)+1;
    int ans = n;
    for (int i=2; i<=m; i++) {
        if (n%i == 0) {
            ans = ans * (i-1) / i;
            while (n%i==0) {
                n /= i;
            }
        }
    }
    if (n>1) {
        ans = ans * (n-1) / n;
    }
    return ans;
    
    /********* End *********/
}

void phi_tabel(int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for (int i=0; i<=n; i++) {
        phi[i] = 0;
    }
    phi[1] = 1;
    for (int i=2; i<=n; i++) {
        if (!phi[i]) {
            for (int j=i; j<=n; j+=i) {
                if (!phi[j]) {
                    phi[j] = j;
                }
                phi[j] = phi[j] * (i-1) / i;
            }
        }
    }
    
    /********* End *********/
}

```"
404,1406,算法与竞赛(第11章) - 数论进阶,mt9eackzjlyv,模逆元,2690,"```cpp
LL inv_mod(LL a, LL n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    LL d, x, y;
    exgcd(a, n, d, x, y);
    return d==1?(x+n)%n:-1;
    
    /********* End *********/
}

LL inv_euler(LL a, LL n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    LL phi = euler_phi(n);
    LL ans = pow_mod(a, phi-1, n);
    return ans;
    
    /********* End *********/
}

```"
405,1405,算法与竞赛(第10章) - 数论基础,ixuqbrhfp8cj,素数筛法,2684,"```cpp

const int maxN=1000007;
bool mark[maxN+1];
int prime[maxN/2+1];

bool judge_prime(int x)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    if (x%2==0) {
        return false;
    }
    int sqrt_x = (int)sqrt(x + 0.5) + 1;
    for (int i=2; i<=sqrt_x; i++) {
        if(x%i==0){
            return false;
        }
    }
    return true;
    
    /********* End *********/
}

int select_prime(int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for (int i=0; i<=n; i++) {
        mark[i] = false;
    }
    int m = (int)sqrt(n + 0.5) + 1;
    for (int i=2; i<=m; i++) {
        if (mark[i]==true) {
            continue;
        }
        for (int j=i*i; j<=n; j+=i) {
            mark[j] = true;
        }
    }
    int tot = 0;
    for (int i=2; i<=n; i++) {
        if (mark[i]==false) {
            prime[tot++] = i;
        }
    }
    return tot;
    
    /********* End *********/
}

```"
406,1405,算法与竞赛(第10章) - 数论基础,njzfrv9t25qi,欧几里得算法,2685,"```cpp
int gcd_div(int a, int b)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    if (b==0) {
        return a;
    }
    else{
        return gcd_div(b, a%b);
    }
    
    /********* End *********/
}

int gcd_sub(int a, int b)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    if (a < b) {
        int c = a;
        a = b;
        b = c;
    }
    if (b==a) {
        return a;
    }
    else{
        return gcd_sub(b, a-b);
    }
    
    /********* End *********/
}

```"
407,1405,算法与竞赛(第10章) - 数论基础,rj5kipew4yml,扩展欧几里得算法,2686,"```cpp

void exgcd(int a, int b, int &d, int &x, int &y)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    if (b==0) {
        d = a;
        x = 1;
        y = 0;
    }
    else{
        exgcd(b, a%b, d, y, x);
        y -= x*(a/b);
    }
    
    /********* End *********/
}

```"
408,1481,C++ 面向对象程序设计 实验五,o3pfari7u8qj,人与复读机,10791,"```c++
#include <iostream>
using namespace std;

class Chinese
{
/********* Begin *********/

public:
    virtual void NiHao();

/********* End *********/
};

/********* Begin *********/

void Chinese::NiHao()
{
    cout << ""你好"" <<endl;
}

/********* End *********/

class EnglishLearner : public Chinese
{
/********* Begin *********/

public:
    void NiHao() override;

/********* End *********/
};

/********* Begin *********/

void EnglishLearner::NiHao()
{
    cout << ""Hello"" << endl;
}

/********* End *********/


class Repeater : public Chinese
{
/********* Begin *********/
public:
    void NiHao() override;

/********* End *********/
};

/********* Begin *********/

void Repeater::NiHao()
{
    Chinese::NiHao();
}

/********* End *********/


```"
409,1481,C++ 面向对象程序设计 实验五,o3qma72wi5z6,复读机的毁灭,10792,"```c++
#include <iostream>
using namespace std;

class Repeater
{
/********* Begin *********/

public:
    virtual void Play();
     virtual ~Repeater(); // 析构函数声明为虚函数

/********* End *********/
};
/********* Begin *********/
void Repeater::Play()
{} //不需要实现
Repeater::~Repeater()
{
    cout << ""砰！""<<endl;
}

/********* End *********/

class ForRepeater : public Repeater
{
/********* Begin *********/

public:
    void Play() override;
    ~ForRepeater() override; //重写析构函数

/********* End *********/
};
/********* Begin *********/

void ForRepeater::Play()
{
    cout << ""没想到你也是一个复读机"" << endl;
}
ForRepeater::~ForRepeater()
{
    cout << ""正·复读机 炸了"" <<endl;
}

/********* End *********/

class RevRepeater : public Repeater
{
/********* Begin *********/

public:
    void Play() override;
    ~RevRepeater() override; //重写析构函数

/********* End *********/
};
/********* Begin *********/

void RevRepeater::Play()
{
    cout << ""机读复个一是也你到想没"" << endl;
}
RevRepeater::~RevRepeater()
{
    cout << ""机读复·反 炸了"" <<endl;
}

/********* End *********/


Repeater* CreateRepeater(int type)
{
    /********* Begin *********/

    if(type == 0)
        return new ForRepeater();
    if(type == 1)
        return new RevRepeater();
    return 0;

    /********* End *********/
}


```"
410,1481,C++ 面向对象程序设计 实验五,tlh3jrnqys78,计算图像面积,10793,"```c++
#include <iostream>
using namespace std;

class Shape
{
/********* Begin *********/

public:
    virtual void PrintArea() = 0;

/********* End *********/
};

class Rectangle : public Shape
{
/********* Begin *********/

private:
    float width,height;
public:
    Rectangle(float w,float h);
    void PrintArea() override;
/********* End *********/
};
/********* Begin *********/

Rectangle::Rectangle(float w,float h)
    :width(w),height(h)
{}
void Rectangle::PrintArea()
{
    cout << width * height << endl;
}

/********* End *********/


class Circle : public Shape
{
/********* Begin *********/
private:
    float radio;
public:
    Circle(float r);
    void PrintArea() override;
/********* End *********/
};

/********* Begin *********/

Circle::Circle(float r)
    :radio(r)
{}
void Circle::PrintArea()
{
    cout << radio * radio * 3.14 << endl;
}


/********* End *********/


```"
411,1473,第一届全国高校绿色计算大赛 决赛第三阶段（C++）,hicjuwfyamgo,客户购买房屋保险概率预测,,
412,1453,全国高校绿色计算大赛 决赛第二阶段（C++）,4wohij3x8kmg,花园浇水,,
413,1453,全国高校绿色计算大赛 决赛第二阶段（C++）,pqbivfhony6z,数列操作,,
414,1453,全国高校绿色计算大赛 决赛第二阶段（C++）,eyb5gko3fwp7,消息传递,,
415,1373,第一届全国高校绿色计算大赛 决赛第一阶段（C++）,t5qw7peljroa,数组排序,,
416,1373,第一届全国高校绿色计算大赛 决赛第一阶段（C++）,8jubio7zf52m,病毒区域的个数,,
417,1373,第一届全国高校绿色计算大赛 决赛第一阶段（C++）,hurga3lwmjkx,最长凹谷,,
418,1373,第一届全国高校绿色计算大赛 决赛第一阶段（C++）,xvur8oe7p5fg,进击的程序猿——脱单双十一！,,
419,1285,程序设计一_实训7_函数,a9svieknuopg,质数的数量,2787,"```cpp
int isPrime(int n){
    if(1==n) return 0;
    for(int i=2;i*i<=n;++i){
        if(0==n%i){
            return 0;
        }
    }
    return 1;
}
```"
420,1285,程序设计一_实训7_函数,5fuyltasonkj,哥德巴赫猜想,2788,"```cpp
int isPrime(int n){
    if(1==n) return 0;
    for(int i=2;i*i<=n;++i){
        if(0==n%i){
            return 0;
        }
    }
    return 1;
}
```"
421,1285,程序设计一_实训7_函数,yis6kczxvwet,求指定区间内的质数和,2577,"```cpp
int isPrime(int n){
    if(1==n) return 0;
    for(int i=2;i*i<=n;++i){
        if(0==n%i){
            return 0;
        }
    }
    return 1;
}
```"
422,1285,程序设计一_实训7_函数,fg4nqk98twbi,求指定区间内回文质数的和,2583,"```cpp
int isPrime(int n){
    if(1==n) return 0;
    for(int i=2;i*i<=n;++i){
        if(0==n%i){
            return 0;
        }
    }
    return 1;
}
int isHuiwen(int n){
    int nn = n;
	int sum = 0;
	while(nn){
		sum = sum * 10 + nn%10;
		nn = nn / 10;
	}
	return n == sum;
}
```"
423,1285,程序设计一_实训7_函数,be26ompyjcg8,剥离粘合之只保留偶数数字返回,2789,"```cpp
int f(int n){
    int a[22],k=0;
    while(n){
        int t = n % 10;
        if(0==t%2) a[k++] = t;
        n = n / 10;
    }
    int ret = 0;
    for(int i=k-1;i>=0;--i)ret=ret*10+a[i];
    return ret;
}
```
"
424,1395,算法与竞赛(第9章) - 数学基础进阶：期望与概率,f8pjtm3s2w5i,数学期望,2677,"```cpp
double expectation(int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    double prob = 0;
    for (int i=1; i<=n; i++) {
        prob += 1. * i * 1 / n;
    }
    return prob;
    
    /********* End *********/
}

double expectation2(int n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int tot = 0;
    for (int i=1; i<=n; i++) {
        tot += i;
    }
    double prob = 0;
    for (int i=1; i<=n; i++) {
        prob += 1. * i * i / tot;
    }
    return prob;
    
    /********* End *********/
}
```"
425,1395,算法与竞赛(第9章) - 数学基础进阶：期望与概率,2v9iwjkefbp5,离散概率,2678,"```cpp
void calc_prob(int A, int B)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    double P_A = 1. * A / (A + B);
    double P_B = 1. * P_A * (A-1)/(A-1+B) + (1-P_A)*(A)/(A+B-1);
    
    printf(""%.2lf\n"", P_A);
    printf(""%.2lf\n"", P_B);
    
    /********* End *********/
}

void calc_back(int A, int B)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    double P_A = 1. * A / (A + B);
    double P_B = 1. * P_A * (A-1)/(A-1+B) + (1-P_A)*(A)/(A+B-1);
    double P_BA = 1. * (A-1)/(A-1+B);
    double P_AB = 1. * P_A * P_BA / P_B;

    printf(""%.2lf\n"", P_AB);
    
    /********* End *********/
}
```"
426,1395,算法与竞赛(第9章) - 数学基础进阶：期望与概率,bicyvomup6j5,连续概率,2679,"```cpp
double calc_prob(double a, double b, double S)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    double M = a * b;
    if (sig(S)==0) {
        return 1;
    }
    if (M < S) {
        return 0;
    }
    double S_ = S * log(M/S);
    double prob = (M-S-S_)/M;
    return prob;
    
    /********* End *********/
}
```"
427,1448,算法竞赛入门经典(第2版)_2_循环结构程序设计,w7ffiopab6rv,指定循环次数的循环,,
428,1448,算法竞赛入门经典(第2版)_2_循环结构程序设计,sujo9vi7z8hq,水仙花数,,
429,1448,算法竞赛入门经典(第2版)_2_循环结构程序设计,yf3rmb7s6fco,7744问题,,
430,1448,算法竞赛入门经典(第2版)_2_循环结构程序设计,cnvsqltai4fu,3n+1问题,,
431,1448,算法竞赛入门经典(第2版)_2_循环结构程序设计,x6rqp2fbushj,计算阶乘的后3位,,
432,1448,算法竞赛入门经典(第2版)_2_循环结构程序设计,kqz38f45tcur,计算阶乘和的后三位,,
433,1454,C++ 面向对象程序设计 实验四,k3v4bgs7xni8,学生信息类1,10778,"```c++

#include ""people.h"" //People类定义在这里面
#include <string>
#include <iostream>
using namespace std;

class Student : public People // **不要改动这里的访问性**
{

public:
    int SID;
    void PrintSID();
	//没有什么需要改动的

};

void Student::PrintSID()
{
    /********* Begin *********/

    cout << SID << endl;

    /********* End *********/
}

void Set(string name,int sid,Student *ptr)
{
    /********* Begin *********/

    ptr->Name = name; //直接访问父类成员
    ptr->SID = sid;

    /********* End *********/
}




```"
434,1454,C++ 面向对象程序设计 实验四,on2b4iqeuamw,学生信息类2,10780,"```c++
#include ""people.h"" //People类定义在这里面
#include <string>
#include <iostream>
using namespace std;

class Student : protected People // **不要改动这里的访问性**
{

public:
    int SID;
    void PrintSID();
/********* Begin *********/

	void SetName(string name); //需要一个Set函数来设置父类的Name成员		

/********* End *********/

};

void Student::PrintSID()
{
    /********* Begin *********/

    cout << SID << endl;

    /********* End *********/
}

/********* Begin *********/
void Student::SetName(string name)
{
    Name = name;
}
/********* End *********/

void Set(string name,int sid,Student *ptr)
{
    /********* Begin *********/

    ptr->SetName(name); //只能通过调用函数来给People类的Name成员赋值了
    ptr->SID = sid;

    /********* End *********/
}




```"
435,1454,C++ 面向对象程序设计 实验四,b4ekuoxn6f3m,研究生信息类,10789,"```c++
#include ""people.h"" //People类定义在这里面
#include <string>
#include <iostream>
using namespace std;

class Student : private People // **不要改动这里的访问性**
{

public:
    int SID;
    void PrintSID();
/********* Begin *********/

	void SetName(string name); //需要一个Set函数来设置父类的Name成员

/********* End *********/

};
void Student::PrintSID()
{
    /********* Begin *********/

    cout << SID << endl;

    /********* End *********/
}

/********* Begin *********/
void Student::SetName(string name)
{
    Name = name;
}

/********* End *********/

class Graduate : public Student // **不要改动这里的访问性**
{
public:
    int ResearchID;
    void PrintResearchID();
/********* Begin *********/

	void SetSID(int sid);  //需要一个Set函数来设置父类的SID成员
    void CallSetName(string name); //还需要增加一个函数来调用父类的SetName函数

/********* End *********/
};

void Graduate::PrintResearchID()
{
    /********* Begin *********/

    cout << ResearchID << endl;

    /********* End *********/
}

/********* Begin *********/
void Graduate::SetSID(int sid)
{
    SID = sid;
}
void Graduate::CallSetName(string name)
{
    SetName(name); //调用Student类的SetName函数
}
/********* End *********/


void Set(string name,int sid,int rid,Graduate *ptr)
{
    /********* Begin *********/

    ptr->CallSetName(name); //通过CallSetName间接调用SetName函数来给People类的Name变量赋值
    ptr->SetSID(sid); //通过SetSID函数来给Student类的SID变量赋值
    ptr->ResearchID = rid;

    /********* End *********/
}


```"
436,1454,C++ 面向对象程序设计 实验四,fht68vspog7l,狼人类,10790,"```c++
#include <string>
#include <iostream>

using namespace std;

class Wolf
{
/********* Begin *********/
public:
    string Name;
    int Shape;
    void PrintState();

/********* End *********/
};
/********* Begin *********/

void Wolf::PrintState()
{
    cout << Name << "" "" << Shape << endl;
}

/********* End *********/


class Human
{
/********* Begin *********/

public:
    string Name;
    int Intell;
    void PrintState();

/********* End *********/
};
/********* Begin *********/

void Human::PrintState()
{
    cout << Name << "" "" << Intell << endl;
}

/********* End *********/



/********* Begin *********/
class Werewolf : public Wolf, public Human //继承的可见性可以随便选择
{
public:
    void SetName(string name);
    void SetState(int shape,int intell);
    void PrintAllState();
};
/********* End *********/

/********* Begin *********/

void Werewolf::SetName(string name)
{
    Wolf::Name = name; //使用作用域运算符分别给两个基类的Name变量赋值
    Human::Name = name;
}
void Werewolf::SetState(int shape,int intell)
{
    Shape = shape; //名字没有冲突，就可以不用作用域运算符了
    Intell = intell;
}
void Werewolf::PrintAllState()
{
    Wolf::PrintState(); //使用作用域运算符分别调用两个基类的PrintState函数
    Human::PrintState();
}

/********* End *********/




```"
437,1423,C++ 面向对象程序设计 实验三,mb9netokips6,学生信息类,10774,"```c++
#include<iostream>
#include<string>
using namespace std;

class Student
{
/********* Begin *********/
public:
    int SID;
    string Name;
    Student();
    Student(int sid,string name);
    ~Student();
/********* End *********/
};

/********* Begin *********/

Student::Student()
:SID(0),Name(""王小明"")
{
}
Student::Student(int sid,string name)
:SID(sid),Name(name)
{
}
Student::~Student()
{
    cout << SID << "" "" <<Name << "" 的信息失效""<<endl;
}

/********* End *********/

```"
438,1423,C++ 面向对象程序设计 实验三,ikenfhpm3o5w,学生信息表,10775,"```c++
#include <string>
#include <iostream>
using namespace std;

class Student
{
/********* Begin *********/
public:
    int SID;
    string Name;
    float Score;
    Student();
    Student(int sid,string name,float sco);

/********* End *********/
};

/********* Begin *********/
Student::Student() //可以不对成员进行初始化，只是用于确保能够创建对象数组
{
}
Student::Student(int sid,string name,float sco)
:SID(sid),Name(name),Score(sco)
{
}
Student list[5]; //全局对象数组模拟的学生表
int listCount; //学生表中的记录的条数

/********* End *********/


void Add(int sid,string name,float sco)
{
    /********* Begin *********/

    list[listCount] = Student(sid,name,sco);
    listCount++; //记得添加一条数据后数据条数就要+1

    /********* End *********/
}

void PrintAll()
{
    /********* Begin *********/

    for(int s = 0;s < listCount;s++)
    {
        cout<<list[s].SID << "" "" <<list[s].Name << "" "" <<list[s].Score <<endl;
    }

    /********* End *********/
}

void Average()
{
    /********* Begin *********/
    float sum = 0;
    for(int s = 0;s < listCount;s++)
        sum += list[s].Score;
    cout<<""平均成绩 "" << sum / listCount << endl;

    /********* End *********/
}



```"
439,1423,C++ 面向对象程序设计 实验三,8n5vm3byftij,模拟共享书店,10777,"```c++
#include <string>
#include <iostream>
using namespace std;

class User
{
/********* Begin *********/
public:
    string Name;
    int Books;
    User(string name,int books);
    ~User();
    static void GetState();
private:
    static int userCount; //增加两个静态成员变量
    static int bookCount;

/********* End *********/
};

/********* Begin *********/
int User::userCount = 0; //都初始化为0
int User::bookCount = 0;
User::User(string name,int bks)
:Name(name),Books(bks)
{
    cout << name << "" "" << bks << "" 加入""<<endl;
    userCount++; //更新用户总数
    bookCount+=bks; //更新书籍总数
}
User::~User()
{
    userCount--; //更新用户总数
    bookCount-=Books; //更新书籍总数
    cout << Name << "" "" << Books << "" 退出""<<endl;
}

void User::GetState()
{
    cout << userCount << "" "" << bookCount << "" "" << bookCount / userCount <<endl;
}


/********* End *********/



```"
440,1426,日期判断,qfwyjavunrsg,日期判断,11749,"# include <stdio.h>
int DayExit(int leap, int month, int day)
{
    int tab[2][13] = {
		 { 0, 31, 28, 31, 30,31,30,31,31,30,31, 30,31},
        {0, 31, 29, 31, 30,31,30,31,31,30,31, 30,31 }
     };
	if(day<=tab[leap][month])
     return 1;
	else return 0;
}
int main(void)
{
    int year,month, day,leap,result;
   scanf(""%d%d%d"",&year,&month,&day);
   leap = (year%4==0 && year%100!=0) || year %400==0;
   result=DayExit(leap,month,day);
   if (result) printf(""True"");
   else printf(""False"");
   return 0;
}"
441,1426,日期判断,el3a4s6mio2b,完数函数和调用,2718,"#include  <stdio.h>
int complete(int n)
{
    int j,s=1; 
for(j=2;j<=n/2;j++)
    if(n%j==0)
      s=s+j;
     if(s==n)
	 {
        printf(""%d=1"",n);
         for(j=2;j<=n/2;j++)
            if(n%j==0)
		printf(""+%d"",j);
         printf(""\n"");
     }
}
int main()
{  
   int m,n,k;
   scanf(""%d%d"",&m,&n);
    for(k=m;k<=n;k++)
    {
  		complete(k);
    }
     return 0;
}"
442,1407,算法竞赛入门经典(第2版)_1_程序设计入门,9jbqfkost5e4,计算1+2的值,,
443,1407,算法竞赛入门经典(第2版)_1_程序设计入门,izsfka7bq3oj,变量及其输入,,
444,1407,算法竞赛入门经典(第2版)_1_程序设计入门,obikmznewpvf,三位数反转,,
445,1407,算法竞赛入门经典(第2版)_1_程序设计入门,yuc5ltfaobv6,交换,,
446,1407,算法竞赛入门经典(第2版)_1_程序设计入门,jfcyt28zbekn,鸡兔同笼,,
447,1407,算法竞赛入门经典(第2版)_1_程序设计入门,umfs4ev3jhcr,三整数排序,,
448,1407,算法竞赛入门经典(第2版)_1_程序设计入门,x5qmlnr48kez,三角形,,
449,1255,全国高校绿色计算大赛 预赛第三阶段（C++）,295ksixfcr6n,客户满意度预测,,
450,1210,全国高校绿色计算大赛 预赛第二阶段（C++）,7nuxfwlmavge,统计分数的麻烦,,
451,1210,全国高校绿色计算大赛 预赛第二阶段（C++）,t5kax9hv3oi4,最强战队,,
452,1210,全国高校绿色计算大赛 预赛第二阶段（C++）,iczh395sxoel,完美的团建活动,,
453,1197,全国高校绿色计算大赛 预赛第一阶段（C++）,i9zormv5ngbj,将字符串反转,,
454,1197,全国高校绿色计算大赛 预赛第一阶段（C++）,gutslcokqwnr,扔桃子,,
455,1197,全国高校绿色计算大赛 预赛第一阶段（C++）,ryztacfp9wim,旋转数组,,
456,1197,全国高校绿色计算大赛 预赛第一阶段（C++）,rcufgqmb786h,计算日期,,
457,1377,C&C++实验：阶乘累加，测试编程语言的数值类型表示,me7uxa65rigj,Hello,2658,"```
#include <stdio.h>
int main()
{
	/********* Begin *********/
	printf(""Hello\n"");
	/********* End *********/
	return 0;
}
```"
458,1377,C&C++实验：阶乘累加，测试编程语言的数值类型表示,f869iv7ym5ot,简单阶乘累加和出错提示,2659,"`答案仅供参考`
```
#include<stdio.h>
int main()
{
	/********* Begin *********/
	int a,b,c,i,n,s=1,sum=0;
	//printf(""请输入一个整数:n="");
	scanf(""%d"",&n);
    if(n<0)
    {
        printf(""输入不正确！你的输入n不为正整数，不能进行阶乘计算，请重新输入！\n"");
    }
    else if(n>=13)
    {
        printf(""超出了程序的数值计算范围\n"");
    }
    else
    {
        for(i=1;i<n+1;i++)
        {
            s=s*i;
        }
        for(a=1;a<=n;a++)
        {
            for(b=1,c=1;b<=a;b++)//控制每个数的阶乘
            {
                c=b*c;
            }
            sum+=c;
        }
        printf(""%d\n"",sum);
    
    }
	/********* End *********/
	return 0;
}
```"
459,1377,C&C++实验：阶乘累加，测试编程语言的数值类型表示,c4yz6bkinfas,用数组解决大数进位问题,2660,"`答案仅供参考：`
```
#include<stdio.h>
#include<string.h>
#include<malloc.h>
long t=2,a,m;
long long b;
int main()
{
    /********** Begin *********/
    long num = 0;

    scanf(""%ld"",&num);
    if(num <0)
    {
        printf(""输入不正确！你的输入n不为正整数，不能进行阶乘计算，请重新输入！\n"");
    }
	else
    {
        long n = 1000000000; //如果b，s不使用long long数据类型，n&num应不大于10^9，否则出错。
        // 按sizeof(long)==4，sizeof(long long)==8算，
        //最大可计算(10^9 -1)! 要求内存够大
        long long *s = (long long*) malloc(sizeof(long long)*num);
        if(NULL == s)
        {
            perror(""malloc"");
            return -1;
        }
        memset(s,0,sizeof(long long)*num);
        s[0] = 1;

        for(t=2;t<=num;t++){
            for(a=0;a<=m;a++){
                s[a]=(b+=s[a]*t)%n,b/=n;
                if( (m==a) && b)m++;
            }
        }
        for(printf(""%lld"",s[m]);m--;)printf(""%09lld"",s[m]);
        printf(""\n"");
    }
    /********** End *********/
    return 0;
}
```
"
460,1377,C&C++实验：阶乘累加，测试编程语言的数值类型表示,zim59lo7svx8,程序结构化与函数化,,
461,1381,C++ 面向对象程序设计 实验二,xtalrfq9yizh,设计一个学生信息类,10768,"```c++
#include <iostream>
class StInfo
{
    /********* Begin *********/
	public:
		int SID;
		char *Name;
		char *Class;
		char *Phone;
		void SetInfo(int sid,char *name,char *cla,char *pho);
		void PrintInfo();

    /********* End *********/
};

/********* Begin *********/

//在此处定义StInfo类
void StInfo::SetInfo(int sid,char *name,char *cla,char *pho)
{
    SID = sid;
    Name = name;
    Class = cla;
    Phone = pho;
}
void StInfo::PrintInfo()
{
    std::cout << SID << "" "" << Name << "" "" << Class << "" "" << Phone << std::endl;
}
/********* End *********/


```"
462,1381,C++ 面向对象程序设计 实验二,2nghaxe6fm3y,设计一个长方形类,10769,"```c++
class Rectangle
{
    /********* Begin *********/

    //在此处实现Rectangle类
	private:
		int height;
		int width;
	public:
		void Set(int h,int w);
		int GetArea();
    /********* End *********/
};

/********* Begin *********/
void Rectangle::Set(int h,int w)
{
    height = h;
    width = w;
}
int Rectangle::GetArea()
{
    return height * width;
}
/********* End *********/

Rectangle GetRect(int h,int w)
{
    /********* Begin *********/

    //按要求返回一个h*w的Rectangle对象
	Rectangle rect;
    rect.Set(h,w);
    return rect;
    /********* End *********/
}

int GetRectArea(Rectangle rect)
{
    /********* Begin *********/

    //按要求返回rect对象的面积
	return rect.GetArea();
    /********* End *********/
}


```"
463,1381,C++ 面向对象程序设计 实验二,ic6k7fbveyhq,综合 设计汽车类,10770,"```c++
#include <iostream>
using namespace std;

/********* Begin *********/

//在此处实现一个汽车类
class Car
{
public:
    void Init();
    void OpenDoor();
    void CloseDoor();
    void LightOn();
    void LightOff();
    void Acc();
    void Dec();
    void State();
    //为了能访问类的私有成员变量，增加一个State函数用于打印汽车的状态
private:
    bool door;
    bool light;
    int speed;
};
void Car::Init()
{
    //初始化，否则结果会出错
    door = false;
    light = false;
    speed = 0;
}
void Car::OpenDoor()
{
    door = true;
}
void Car::CloseDoor()
{
    door = false;
}
void Car::LightOn()
{
    light = true;
}
void Car::LightOff()
{
    light = false;
}
void Car::Acc()
{
    speed += 10;
}
void Car::Dec()
{
    speed -= 10;
}
void Car::State()
{
    if(door) 
        cout<<""车门 ON""<<endl;
    else 
        cout<<""车门 OFF""<<endl;
    if(light) 
        cout<<""车灯 ON""<<endl;
    else 
        cout<<""车灯 OFF""<<endl;
    cout<<""速度 ""<<speed<<endl;
}
/********* End *********/

int main()
{
    /********* Begin *********/

    //在此处读取输入的命令序列，并解析执行
	char cmds[25];
    cin>>cmds;
    Car c;
    c.Init();
    for(int s = 0;cmds[s] != '\0';s++)
    {
        switch(cmds[s])
        {
            case '1': c.OpenDoor(); break;
            case '2': c.CloseDoor(); break;
            case '3': c.LightOn(); break;
            case '4': c.LightOff(); break;
            case '5': c.Acc(); break;
            case '6': c.Dec(); break;
            case '7': c.State();break;
        }
    }
    /********* End *********/
}
```"
464,1386,C&C++表达式语句实训,a2ew7noftcli,整型数据的运算：剩下的苹果哪去了,2668,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    // 定义变量，m-苹果数，n-人数，x-人均苹果数
    int m, n, x;

    // 请在此添加代码，输入苹果数、人数，并计算人均苹果数
    /********** Begin *********/
    scanf(""%d%d"",&m,&n);
    x = m / n;
    /********** End **********/

    // 输出人均苹果数
    printf(""人均苹果数为：%d"",x);
    return 0;
}
```"
465,1386,C&C++表达式语句实训,3mrx6kfiypn2,浮点型数据的运算：你的身材标准吗,2669,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    float up, low;
    // 请在此添加代码，输入身高，计算标准身材的体重上下限
    /********** Begin *********/
    float h, w;
    scanf(""%f"",&h);
    w = (h - 100) * 0.9;
    low = w * 0.9;
    up = w * 1.1;
    /********** End **********/

    // 输出标准身材的体重上下限
    printf(""体重范围为：%.2f -- %.2f\n"",low,up);
    return 0;
}
```"
466,1386,C&C++表达式语句实训,jug82vepxska,字符型数据的运算：循环加密是怎么实现的,2670,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // c-存储输入的大写字母,d-存储加密后的大写字母
    char c, d;

    // step-秘钥，往前走的步数，大于等于，小于
    int step;

    // 请在此添加代码，输入明文、秘钥，计算密文存入d中
    /********** Begin *********/
    cin >> c >> step;
    d = c + step;
    d = (d > 'Z') ? (d - 26) : d;
    /********** End **********/

    // 输出密文
    cout << d;
    return 0;
}
```"
467,1386,C&C++表达式语句实训,xps27irnvbql,二进制数据的位运算：字符是怎么存储的,2671,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // c是存储输入的字符
    char c;

    // 输入字符
    cin >> c;

    // 请在此添加代码，输出c的位二进制表示
    /********** Begin *********/
    cout << (int)(bool)(c & 0x80);
    cout << (int)(bool)(c & 0x40);
    cout << (int)(bool)(c & 0x20);
    cout << (int)(bool)(c & 0x10);
    cout << (int)(bool)(c & 0x08);
    cout << (int)(bool)(c & 0x04);
    cout << (int)(bool)(c & 0x02);
    cout << (int)(bool)(c & 0x01);
    /********** End **********/

    return 0;
}
```"
468,1315,《信息系统安全》课程实验指导,rpjuws7fy9fm,实验一：古典密码算法---代换技术,2617,"```cpp
void Encrypt(int K, char* clearText, char* cipherText)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for (int i=0; i<int(strlen(clearText)); i++)
    {
        cipherText[i] = ((clearText[i]-'a')+K)%N+'a';
    }
	cipherText[int(strlen(clearText))] = '\0';
    
    /********* End *********/
}

void Dencrypt(int K, char* clearText, char* cipherText)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for (int i=0; i<int(strlen(cipherText)); i++)
    {
        clearText[i] = ((cipherText[i]-'a')-K+N)%N+'a';
    }
	clearText[int(strlen(cipherText))] = '\0';
    
    /********* End *********/
}

```"
469,1315,《信息系统安全》课程实验指导,yz49sobiecfx,实验二：古典密码算法---置换技术,2618,"```cpp

void Encrypt(int* cipherTab, int len, char* clearText, char* cipherText)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for (int i=0; i<len; i++)
    {
        cipherText[i] = clearText[cipherTab[i]];
    }
	cipherText[len] = '\0';
    
    /********* End *********/
}

void Dencrypt(int* cipherTab, int len, char* clearText, char* cipherText)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for (int i=0; i<len; i++)
    {
        clearText[cipherTab[i]] = cipherText[i];
    }
	clearText[len] = '\0';
    
    /********* End *********/
}

```"
470,1315,《信息系统安全》课程实验指导,p4zb8hn9icfr,实验三：DES加解密算法的实现,2619,"```cpp

void SETKEY(const char Key_C[8], bool Key_B[64])
// Key_C: 2018helo
// ascii: 0x32 0x30 0x31 0x38 0x68 0x65 0x6c 0x6f
// 8bits: 00110010 00110000 00110001 00111000 01101000 01100101 01101100 01101111
// Key_B: 0011001000110000001100010011100001101000011001010110110001101111
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for(int i=0; i<8; i++)
        for(int j=0; j<8; ++j)
            //Key_B[63-i*8-j] = ((Key_C[i]>>j) & 1);
            Key_B[i*8+7-j] = ((Key_C[i]>>j) & 1);
    
    /********* End *********/
}

void ByteToBit(bool *Outs, const char *In, int bits)
// In:    password
// ascii: 0x70 0x61 0x73 0x73 0x77 0x6f 0x72 0x64
// 8bits: 01110000 01100001 01110011 01110011 01110111 01101111 01110010 01100100
// Outs:  0111000001100001011100110111001101110111011011110111001001100100
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for(int i=0; i<bits; i++)
        for(int j=0; j<bits; ++j)
            //Outs[63-i*bits-j] = ((In[i]>>j) & 1);
            Outs[i*bits+bits-1-j] = ((In[i]>>j) & 1);
    
    /********* End *********/
}

void BitToByte(char *Outs, const bool *In, int bits)
// In:    0111000001100001011100110111001101110111011011110111001001100100
// 8bits: 01110000 01100001 01110011 01110011 01110111 01101111 01110010 01100100
// ascii: 0x70 0x61 0x73 0x73 0x77 0x6f 0x72 0x64
// Outs:  password
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for(int i=0; i<bits; i++){
        int val = 0;
        for (int j=0; j<bits; j++) {
            //val = (val<<1) | In[63-i*bits-(bits-1-j)];
            val = (val<<1) | In[i*bits+j];
        }
        Outs[i] = val;
    }
    Outs[bits] = '\0';
    
    /********* End *********/
}


void CYCLELEFT(bool *In, int len, int loop)                         // 循环左移函数
// before: 0000000011110000111111110000
// loop:   1
// after:  0000000111100001111111100000
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    bool tmp[28];
    memcpy(tmp, In, sizeof(tmp));
    for (int i=0; i<len; i++) {
        In[i] = tmp[(i+loop)%len];
    }

    /********* End *********/
}

void Set_SubKey(bool subKey[16][48], bool Key[64])                  // 设置子密钥
// Key:    0011001000110000001100010011100001101000011001010110110001101111
// SubKey: 011000000011110001100100010111000101100101000100
// SubKey: 010000001011010001110100010111001000100011100100
// SubKey: 110001001100010001110110110000001110110011011001
// SubKey: 111001101100001100100010001010111011011000011001
// SubKey: 101010101001001100100011101110110101010100100010
// SubKey: 101010010001001001011011000011000100101100100110
// SubKey: 001001010101001011011000110101000110100011010100
// SubKey: 000101100101100111010000111000011000001011011001
// SubKey: 000101100100100101010001111000111010011010011000
// SubKey: 000011110110100100010101001110010001011100001111
// SubKey: 000011110010010110001101000111100101000010100110
// SubKey: 010110110000010010101001010001000110100111100101
// SubKey: 110110011000100010101000101000101010100011011001
// SubKey: 100100001010101010001110111000111001011100010011
// SubKey: 001100000011111000000110000111110000011100101010
// SubKey: 011100000011111000000100000101000101011101100110
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    bool realKey[56];
    bool left[28];
    bool right[28];
    bool compressKey[48];   // 去掉奇偶标记位，将64位密钥变成56位
    
    for (int i=0; i<56; i++){
        realKey[i] = Key[TRANS_64to56[i]-1];
    }
    // 生成子密钥，保存在 subKeys[16] 中
    for(int round=0; round<16; round++)
    {
        // 前28位与后28位
        for(int i=0; i<28; i++)
            left[i] = realKey[i];
        for(int i=28; i<56; i++)
            right[i-28] = realKey[i];
        // 左移
        CYCLELEFT(left, 28, SHIFT_TAB[round]);
        CYCLELEFT(right, 28, SHIFT_TAB[round]);
    
        for(int i=0; i<28; i++)
            realKey[i] = left[i];
        for(int i=28; i<56; i++)
            realKey[i] = right[i-28];
        // 压缩置换，由56位得到48位子密钥
        for(int i=0; i<48; i++)
            compressKey[i] = realKey[TRANS_56to48[i]-1];
        for (int i=0; i<48; i++) {
            subKey[round][i] = compressKey[i];
        }
    }
    
    /********* End *********/
}

void XOR(bool *InA, const bool *InB, int len)                       // 异或函数
// Before InA: 000000000001011111111110100100000000001111111000
// Before InB: 011000000011110001100100010111000101100101000100
// Before InA: 011000000010101110011010110011000101101010111100
// Before InB: 011000000011110001100100010111000101100101000100
{

    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    for (int i=0; i<len; i++) {
        InA[i] = InA[i] ^ InB[i];
    }
    
    /********* End *********/
}

void S_BOXF(bool Out[32], const bool In[48])// S-盒代替函数
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int x = 0;
    for(int i=0; i<48; i=i+6)
    {
        int row = In[i+0]*2 + In[i+5];
        int col = In[i+1]*8 + In[i+2]*4 + In[i+3]*2 + In[i+4];
        int num = S_BOX[i/6][row][col];
        for (int k=3; k>=0; k--) {
            Out[x+k] = num%2;
            num /= 2;
        }
        x += 4;
    }
    
    /********* End *********/
}

void F_FUNCTION(bool In[32], const bool Ki[48]) // f 函数完成扩展置换、S-盒代替和P盒置换
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    // 第一步：扩展置换，32 -> 48
    bool expandR[48];
    for(int i=0; i<48; i++)
        //expandR[47-i] = In[32-EXPAND_32to48[i]]; // 0x8c 0x22 0xe2 0x86 0x48 0x5a 0x4b 0xae
        expandR[i] = In[EXPAND_32to48[i]-1];   // 0x8c 0x22 0xe2 0x86 0x48 0x5a 0x4b 0xae
    // 第二步：异或
    XOR(expandR, Ki, 48);
    // 第三步：查找S_BOX置换表
    bool output[32];
    S_BOXF(output, expandR);
    // 第四步：P-置换，32 -> 32
    for(int i=0; i<32; i++){
        In[i] = output[TRANS_32to32[i]-1];
    }
    
    /********* End *********/
}

void DES(char Out[8], char In[8], const bool subKey[16][48], bool Type)  // 标准DES Type: True加密/False解密
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    bool plain[64];
    bool left[32];
    bool right[32];
    bool newLeft[32];
    bool cipher[64];
    bool currentBits[64];
    
    ByteToBit(plain, In, 8);
    // 第一步：初始置换IP
    for(int i=0; i<64; i++)
        currentBits[i] = plain[TRANS_INIT[i]-1];
    // 第二步：获取 Li 和 Ri
    for(int i=0; i<32; i++)
        left[i] = currentBits[i];
    for(int i=32; i<64; i++)
        right[i-32] = currentBits[i];
    // 第三步：共16轮迭代
    if (Type == true) { // 加密
        for(int round=0; round<16; round++)
        {
            memcpy(newLeft, right, sizeof(newLeft));
            F_FUNCTION(right,subKey[round]);
            XOR(right, left, 32);
            memcpy(left, newLeft, sizeof(left));
        }
    }
    if (Type == false) { // 解密
        for(int round=15; round>=0; round--)
        {
            memcpy(newLeft, right, sizeof(newLeft));
            F_FUNCTION(right,subKey[round]);
            XOR(right, left, 32);
            memcpy(left, newLeft, sizeof(left));
        }
    }
    // 第四步：合并L16和R16，注意合并为 R16L16
    for(int i=0; i<32; i++)
        //cipher[63-i] = left[31-i];
        cipher[i] = right[i];
    for(int i=32; i<64; i++)
        //cipher[63-i] = right[31-(i-32)];
        cipher[i] = left[(i-32)];
    // 第五步：结尾置换IP-1
    for(int i=0; i<64; i++)
        currentBits[i] = cipher[i];
    for(int i=0; i<64; i++)
        cipher[i] = currentBits[TRANS_END[i]-1];
    BitToByte(Out, cipher, 8);
    
    /********* End *********/
}

```"
471,1315,《信息系统安全》课程实验指导,8atfxbgh6jip,实验四：RSA加解密算法的实现,2620,"```cpp

int prime[2001];    //存放素数
int p[10001];       //用筛选法求素数
void PRIME()
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int i,i2,k;
    for(i=0;i<=10000;i+=2)
        p[i]=0;
    for(i=1;i<=10000;i+=2)
        p[i]=1;
    p[2]=1;p[1]=0;
    for(i=3;i<=100;i+=2)
    {
        if(p[i]==1)
        {
            i2=i+i;
            k=i2+i;
            while(k<=10000)
            {
                p[k]=0;
                k+=i2;
            }
        }
    }
    int t = 0;
    prime[t++]=2;
    for(i=3;i<=10000;i+=2)
        if(p[i])
            prime[t++]=i;
    
    /********* End *********/
    
}

int64 mod(int64 a,int64 n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    return (a%n+n)%n;
    
    /********* End *********/
}

void exgcd(int64 a,int64 b,int64 &d,int64 &x,int64 &y)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    if(b==0)
    {
        d=a;
        x=1;
        y=0;
        return;
    }
    exgcd(b,a%b,d,y,x);
    y-=x*(a/b);
    
    /********* End *********/
}

//a-1 mod n
int64 Inv(int64 a,int64 n) // 计算逆元素
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int64 d,x,y;
    exgcd(a,n,d,x,y);
    if(d==1)
        return mod(x,n);
    else
        return -1;
    
    /********* End *********/
}

//求两个数的最大公约数
int64 GCD(int64 n,int64 m)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int64 t,r;
    if(n<m)
    {
        t=n;
        n=m;
        m=t;
    }
    while((r=n%m)!=0)
    {
        n=m;
        m=r;
    }
    return m;
    
    /********* End *********/
}

//x=a^b(mod n)
int64 ModPow(int64 a,int64 b,int64 n)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    int64 d=1,i=0;
    while(b>=(1<<i)) i++;
    for(--i;i>=0;--i)
    {
        d=d*d%n;
        if(b&(1<<i))
            d=d*a%n;
    }
    return d;
    
    /********* End *********/
}

```"
472,1203,算法与竞赛(第7章) - C++与STL基础三：队列以及优先队列的应用,yk2fmio57qtu,STL模板之queue实例一：最少个数,2447,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int n;
    int s;
    queue<int> que;
    int ans = 0;
    int sum = 0;
    int x;
    scanf(""%d %d"", &n, &s);
    while (n--) {
        scanf(""%d"", &x);
        que.push(x);
        sum += x;
        while (!que.empty() && sum>=s) {
            if (ans == 0) {
                ans = int(que.size());
            }else{
                ans = min(ans, int(que.size()));
            }
            sum -= que.front();
            que.pop();
        }
    }
    cout<<ans<<endl;
    
    /********* End *********/
```"
473,1203,算法与竞赛(第7章) - C++与STL基础三：队列以及优先队列的应用,tp2fbx6f7vya,STL模板之queue实例二：迷宫问题,2448,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    int n, m;
    char mapt[20][20];
    int sx, sy, ex, ey;
    int dist[20][20] = {0};
    int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};
    queue<int> que;
    
    scanf(""%d %d"",&n ,&m);
    for (int i=0; i<n; i++) {
        scanf(""%s"", mapt[i]);
    }
    scanf(""%d %d %d %d"", &sx, &sy, &ex, &ey);

    que.push(sx*m+sy);
    while (!que.empty()) {
        int p = que.front();
        que.pop();
        int x = p / m;
        int y = p % m;
        if (x==ex && y==ey) {
            break;
        }
        for (int i=0; i<4; i++) {
            int dx = x + dir[i][0];
            int dy = y + dir[i][1];
            if(0<=dx&&dx<n && 0<=dy&&dy<m && mapt[dx][dy]=='*' && dist[dx][dy]==0){
                que.push(dx*m+dy);
                dist[dx][dy] = dist[x][y] + 1;
            }
        }
    }
    cout<<dist[ex][ey]<<endl;
    
    /********* End *********/
```"
474,1203,算法与竞赛(第7章) - C++与STL基础三：队列以及优先队列的应用,pubnxzhr5gcv,STL模板之queue实例三：合并果子,2449,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    /* 方法一，从大到小的默认优先队列
    int n;
    int ans = 0;
    priority_queue<int> que;
    scanf(""%d"", &n);
    for (int i=0; i<n; i++) {
        int x;
        scanf(""%d"", &x);
        que.push(-x);   // 技巧：取反，等价于“从小到大的优先队列”
    }
    while (!que.empty()) {
        int q1 = que.top();
        que.pop();
        if (que.empty()) {
            break;
        }
        int q2 = que.top();
        que.pop();
        ans = ans - q1 - q2;
        que.push(q1+q2);
    }
    cout<<ans<<endl;
    */
    
    // 方法二，从小到大的自定义优先队列
    struct comp{
        bool operator()(int x,int y){
            return x>y;   ///从小到大排序。即x小的优先级高。
        }
    };
    priority_queue<int, vector<int>, comp> que; // 从小到大的优先队列
    int n;
    int ans = 0;
    scanf(""%d"", &n);
    for (int i=0; i<n; i++) {
        int x;
        scanf(""%d"", &x);
        que.push(x);  
    }
    while (!que.empty()) {
        int q1 = que.top();
        que.pop();
        if (que.empty()) {
            break;
        }
        int q2 = que.top();
        que.pop();
        ans = ans + q1 + q2;
        que.push(q1+q2);
    }
    cout<<ans<<endl;
    
    /********* End *********/
    
```"
475,1301,算法与竞赛(第8章) - 数学基础之数值计算,olbfvmnuq6k3,数值计算之二分答案,2601,"```cpp
#define eps 1e-8
int sig(double x){ return (x>eps)-(x<-eps);}

double funx(double a, double b, double x)//ax+b=0方程系数
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    return a * x + b;
    
    /********* End *********/
}

double zero_val(double a, double b)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    double l = -100;
    double r = 100;
    while (1) {
        double m = (l+r)*0.5;
        double val = funx(a, b, m);
        if (sig(val)==0)
        {
            return m;
        }
        if (funx(a, b, l)*funx(a, b, m)>0)
        {
            l = m;
        }
        else
        {
            r = m;
        }
    }
    /********* End *********/
}

```"
476,1301,算法与竞赛(第8章) - 数学基础之数值计算,b76hlpeku5f9,数值计算之三分答案,2602,"```cpp

#define eps 1e-8
int sig(double x){ return (x>eps)-(x<-eps);}

double funx(double a, double b, double c, double x)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    return a * x * x + b * x + c;
    
    /********* End *********/
}

double min_val(double a, double b, double c)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    double l = -100;
    double r = 100;
    while (1) {
        double m1 = (l+r)*0.5;
        double val1 = funx(a, b, c, m1);
        double m2 = (m1+r)*0.5;
        double val2 = funx(a, b, c, m2);
        if (sig(val1-val2)==0)
        {
            return m1;
        }
        if (val1 > val2)
        {
            l = m1;
        }
        else
        {
            r = m2;
        }
    }
    
    /********* End *********/
}

```"
477,1301,算法与竞赛(第8章) - 数学基础之数值计算,cvkf4a926whx,数值计算之辛普森积分,2603,"```cpp
double r; // 圆半径r（全局变量）
double funx(double x)
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    // (x-r)^2+(y-r)^2=r^2 --> y = r - sqrt(2*x*r-x*x)
    return r-sqrt(2*x*r-x*x);
    
    /********* End *********/
}

double simpson(double a,double b)//辛普森公式
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    double c=(a+b)/2.;
    return (funx(a)+funx(b)+4.*funx(c))*(b-a)/6.;
    
    /********* End *********/
}
double ars(double a,double b,double eps)//递归积分
{
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    double c=(a+b)/2.;
    double mid=simpson(a,b),l=simpson(a,c),r=simpson(c,b);
    if(fabs(l+r-mid)<=15*eps)
        return l+r+(l+r-mid)/15.;
    return ars(a,c,eps/2.)+ars(c,b,eps/2.);
    
    /********* End *********/
}
```"
478,1310,循环语句while,v4rpxmfsl6f7,使用while循环语句完成1+2+3+…+100的计算。,2613,"```
#include<stdio.h>
int main()
{ 
   int i=1,sum=0;
   while(i<=100)
  {
     sum=sum+i;
	 i=i+1;
  }
  printf(""%d"",sum);
  return 0;
}
```"
479,1276,程序设计一_实训6_字符串,vhzmaubpi7jt,字符串查找,2550,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    string target,pattern;
    cin>>target>>pattern;

    int pos = target.find(pattern);
    if(0<=pos&&pos<target.length()) cout<<""Yes""<<endl;
    else cout<<""No""<<endl;
    /***end your code***/
    return 0;
}
```"
480,1276,程序设计一_实训6_字符串,henoq29783xc,最长回文子串,2551,"```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main(){
    /***begin your code here***/
    string s;
    cin>>s;
    int ans,n = s.length();
    for(ans=n;ans>1;--ans){
        for(int i=0;i<=n-ans;++i){
            string a = s.substr(i,ans);
            string b(a.rbegin(),a.rend());
            if(a==b) goto L;
        }
    }
L:
    printf(""%d\n"",ans);
    
    /***end your code***/
    return 0;
}
```"
481,1276,程序设计一_实训6_字符串,u7hwgnbrm6ok,可重复最长子串,2552,"```cpp
#include <iostream>
using namespace std;
int main(){
    /***begin your code here***/
    string s;
    cin>>s;
    int ans,n = s.length();
    for(ans=n-1;ans>0;--ans){
        for(int i=0;i<=n-ans;++i){
            string a = s.substr(i,ans);
            for(int j=i+1;j<=n-ans;++j){
                if(a==s.substr(j,ans)){
                    goto L;
                }
            }
        }
    }
    L:
    printf(""%d\n"",ans);
    /***end your code***/
    return 0;
}

```"
482,1276,程序设计一_实训6_字符串,rnmol27pz3g4,首单词首字母大写,,
483,1277,Hello World!,6mwlrb3zvich,C 之 Hello world!,,
484,1277,Hello World!,paq8ffe3gymo,在屏幕上输出多行信息,,
485,1277,Hello World!,zoif7962bynf,数据类型初探,,
486,1267,程序设计一_实训5_一维数组,egy9h83a5izj,剥离粘合之只保留偶数数字,,
487,1267,程序设计一_实训5_一维数组,6q8hocu9fp5s,Fibonacci数列,,
488,1267,程序设计一_实训5_一维数组,fwljoe3ri9as,小规模伪随机数列的众数,,
489,1267,程序设计一_实训5_一维数组,hc4frty3vxmo,第二大的数,,
490,1262,程序设计一_实训3_循环语句基础,q6tinvm7b48y,剥离数字,2521,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int n;
    cin>>n;
    if(0==n){
        cout<<0<<endl;
        return 0;
    }
    
    while(n){
        cout<<n%10<<endl;
        n=n/10;
    }

    /***end your code***/
    return 0;
}
```"
491,1262,程序设计一_实训3_循环语句基础,xcp5fjze9rln,粘合数字,2522,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int n;
    cin>>n;
    int s = 0;
    for(int i=0;i<n;++i){
        int a;
        cin>>a;
        s = s*10+a;
    }
    int m;
    cin>>m;
    cout<<s%m<<endl;
    /***end your code***/
    return 0;
}
```"
492,1262,程序设计一_实训3_循环语句基础,g2yju593hw4f,剥离粘合之只保留偶数数字,,
493,1262,程序设计一_实训3_循环语句基础,598czr64ljpk,剥离粘合之只保留偶数位上的数字,2523,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int n;
    cin>>n;
    int s = 0;
    n = n / 10;
    while(n){
        s = s * 10 + n % 10;
        n = n / 100;
    }
    cout<<s/2;
    if(1==s%2) cout<<"" 1"";
    cout<<endl;
    /***end your code***/
    return 0;
}
```"
494,1263,程序设计一_实训4_循环语句训练,7e53sriqgfup,质数,2524,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int n;
    cin>>n;    
    int flag = 1;
    for(int i=2;i<n;++i){
        if(0==n%i){
            flag = 0;
            break;     
        }
    }    
    if(flag)cout<<""Prime""<<endl;
    else cout<<""Heshu""<<endl;
    /***end your code***/
    return 0;
}
```"
495,1263,程序设计一_实训4_循环语句训练,o7rfujlnwgba,最大公约数,2525,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int a,b;
    cin>>a>>b;
    
    int r = a;
    if(r>b) r = b;
    
    for(;r>1;--r){
        if(0==a%r&&0==b%r){
            break;
        }    
    }

    cout<<r<<endl;
    /***end your code***/
    return 0;
}
```"
496,1263,程序设计一_实训4_循环语句训练,o7hx8fj26sgb,质数的数量,2526,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int a,b;
    cin>>a>>b;
    if(1==a)++a;
    int sum = 0;
    for(int i=a;i<=b;++i){
        int flag = 1;
        for(int j=2;j<i;++j){
            if(i%j==0){
                flag = 0;
                break;
            }
        }
        if(flag) ++sum;
    }
    cout<<sum<<endl;
    /***end your code***/
    return 0;
}
```"
497,1263,程序设计一_实训4_循环语句训练,cng53emlp8rf,哥德巴赫猜想,2527,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int n;
    cin>>n;
    int a,b;
    
    for(int i=2;i<=n/2;++i){
        a = i;
        b = n - a;
        
        int flaga = 1,flagb = 1;
        
        for(int j=2;j<a;++j){
            if(0==a%j){
                flaga = 0;
                break;
            }
        }
        
        for(int j=2;j<b;++j){
            if(0==b%j){
                flagb = 0;
                break;
            }
        }
        
        if(flaga&&flagb){
            break;
        }
    }
    
    cout<<a<<"" ""<<b<<endl;
    /***end your code***/
    return 0;
}
```"
498,1260,程序设计一_实训2_关系运算符与选择语句,ye8pc56lnsvw,关系运算符与单分支选择语句,,
499,1260,程序设计一_实训2_关系运算符与选择语句,zq7milcsojy6,3个int按从大到小依次输出,2519,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int a,b,c;
    cin>>a>>b>>c;
    
    int mmax = a;
    if(mmax<b) mmax = b;
    if(mmax<c) mmax = c;
    
    int mmin = a;
    if(mmin>b) mmin = b;
    if(mmin>c) mmin = c;
    
    cout<<mmax<<"" ""<<a+b+c-mmax-mmin<<"" ""<<mmin<<endl;
    /***end your code***/
    return 0;
}
```"
500,1260,程序设计一_实训2_关系运算符与选择语句,bqf2gk7ionym,水仙花数与四叶玫瑰数,2520,"```cpp
#include <iostream>
using namespace std;

int main(){
    /***begin your code here***/
    int n;
    cin>>n;
    if(153==n||370==n||371==n||407==n)cout<<""narcissistic""<<endl;
    else if(1634==n||8208==n||9474==n)cout<<""rose""<<endl;
    else cout<<""neither""<<endl;
    /***end your code***/
    return 0;
}
```"
501,1259,程序设计一_实训1_基本输入输出与算术运算符,mbo85yix6pue,字符串常量的输出,,
502,1259,程序设计一_实训1_基本输入输出与算术运算符,a35whynubjrk,输入及输出,,
503,1259,程序设计一_实训1_基本输入输出与算术运算符,qh7sk2xb8npt,书写一个完整的C++程序,2516,"```cpp
/***begin your code here***/
#include <iostream>
using namespace std;

int main(){
    int a,b,c;
    cin>>a>>b>>c;
    cout<<a+b+c<<endl;
    return 0;
}
/***end your code***/
```"
504,1186,算法与竞赛(第6章) - C++与STL基础二：栈stack与前中后缀表达式的应用,2zlfjtax7suh,STL模板之栈stack实例：中缀表达式转前缀表达式,2406,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    char str[100];
    scanf(""%s"", str);
    stack<char> s1;
    stack<char> s2;
    for(int i=int(strlen(str))-1;i>=0;i--){
        if(isdigit(str[i])){
            s2.push(str[i]);
        }
        else if(str[i]=='+' || str[i]=='-' || str[i]=='*'){
                while(true){
                if(s1.empty() || s1.top()==')'){
                    s1.push(str[i]);
                    break;
                }
                else if(str[i]=='*' || s1.top()=='+' || s1.top()=='-'){
                    s1.push(str[i]);
                    break;
                }
                else {
                    s2.push(s1.top());
                    s1.pop();
                }
            }
        }
        else if(str[i]=='('){
            while (s1.top()!=')') {
                s2.push(s1.top());
                s1.pop();
            }
            s1.pop();
        }
        else if(str[i]==')'){
            s1.push(str[i]);
        }
    }
    while (!s1.empty()) {
        s2.push(s1.top());
        s1.pop();
    }
    while (!s2.empty()) {
        printf(""%c"", s2.top());
        s2.pop();
    }
    printf(""\n"");
    /********* End *********/
```"
505,1186,算法与竞赛(第6章) - C++与STL基础二：栈stack与前中后缀表达式的应用,ic4lv7z6wb2n,STL模板之栈stack实例：中缀表达式转后缀表达式,2407,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    char str[100];
    scanf(""%s"", str);
    stack<char> s1;
    stack<char> s2;
    for(int i=0;i<int(strlen(str));i++){
        if(isdigit(str[i])){
            s2.push(str[i]);
        }
        else if(str[i]=='+' || str[i]=='-' || str[i]=='*'){
            while(true){
                if(s1.empty() || s1.top()=='('){
                    s1.push(str[i]);
                    break;
                }
                else if(str[i]=='*' && (s1.top()=='+' || s1.top()=='-')){
                    s1.push(str[i]);
                    break;
                }
                else {
                    s2.push(s1.top());
                    s1.pop();
                }
            }
        }
        else if(str[i]=='('){
            s1.push(str[i]);
        }
        else if(str[i]==')'){
            while (s1.top()!='(') {
                s2.push(s1.top());
                s1.pop();
            }
            s1.pop();
        }
    }
    while (!s1.empty()) {
        s2.push(s1.top());
        s1.pop();
    }
    int n = 0;
    while (!s2.empty()) {
        str[n++] = s2.top();
        s2.pop();
    }
    for(int i=n-1;i>=0;i--){
        printf(""%c"", str[i]);
    }
    printf(""\n"");

    /********* End *********/
```"
506,1186,算法与竞赛(第6章) - C++与STL基础二：栈stack与前中后缀表达式的应用,y796fsuhlgwa,STL模板之栈stack实例：计算机求解前缀表达式,2408,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    char str[100];
    scanf(""%s"", str);
    stack<int> s;
    for(int i=int(strlen(str))-1;i>=0;i--){
        if(isdigit(str[i])){
            s.push(str[i]-'0');
        }
        else{
            int res = 0;
            int a = s.top(); s.pop();
            int b = s.top(); s.pop();
            switch (str[i]) {
                case '+': res = a + b; break;
                case '-': res = a - b; break;
                case '*': res = a * b; break;
                default: printf(""error\n"");
            }
            s.push(res);
        }
    }
    while (!s.empty()) {
        printf(""%d\n"", s.top());
        s.pop();
    }
    /********* End *********/
```"
507,1186,算法与竞赛(第6章) - C++与STL基础二：栈stack与前中后缀表达式的应用,xp594ebqfugk,STL模板之栈stack实例：计算机求解后缀表达式,2409,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    char str[100];
    scanf(""%s"", str);
    stack<int> s;
    for(int i=0;i<int(strlen(str));i++){
        if(isdigit(str[i])){
            s.push(str[i]-'0');
        }
        else{
            int res = 0;
            int b = s.top(); s.pop();
            int a = s.top(); s.pop();
            switch (str[i]) {
                case '+': res = a + b; break;
                case '-': res = a - b; break;
                case '*': res = a * b; break;
                default: printf(""error\n"");
            }
            s.push(res);
        }
    }
    while (!s.empty()) {
        printf(""%d\n"", s.top());
        s.pop();
    }

    /********* End *********/
```"
508,1140,算法与竞赛(第5章) - C++与STL基础一,6qzx3pneyb92,STL模板之动态数组：向量vector的操作,2274,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    // 1.构建整型向量vec
    vector<int> vec;
    
    // 2.读取数据：序列个数n，以及n个整数并存入向量vec
    int n;
    scanf(""%d"", &n);
    while (n--) {
        int x;
        scanf(""%d"", &x);
        vec.push_back(x);
    }
    
    // 3.删除向量vec中的重复元素
    for(int i=0;i<vec.size();i++){
        for (vector<int>::iterator it=vec.begin()+i+1; it!=vec.end();) {
            if (*it==vec[i]) {
                vec.erase(it);
            }else{
                it++;
            }
        }
    }
    
    // 4.使用Algorithm模板函数sort排序：从小到大
    sort(vec.begin(), vec.end());

    // 5.遍历向量vec并输出，元素中间空格隔开，末尾加换行符'\n'
    printf(""%d"", vec[0]);
    for(int i=1;i<vec.size();i++){
        printf("" %d"", vec[i]);
    }
    printf(""\n"");
    
    // 6.清空向量vec
    vec.clear();

    
    /********* End *********/
```"
509,1140,算法与竞赛(第5章) - C++与STL基础一,i36cx2svjozt,STL模板之动态数组：向量vector的应用,2275,"```cpp
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    vector<vector<int> > vec;
    
    int n;
    scanf(""%d"", &n);
    while (n--) {
        vector<int> tmp;
        int m;
        scanf(""%d"", &m);
        while (m--) {
            int x;
            scanf(""%d"", &x);
            tmp.push_back(x);
        }
        vec.push_back(tmp);
    }
    int q;
    scanf(""%d"", &q);
    while (q--) {
        char str[20];
        int a, b;
        scanf(""%s %d %d"", str, &a, &b);
        if(!vec[a].empty()){
            vec[b].push_back(vec[a].back());
            vec[a].erase(vec[a].end()-1);
        }
    }
    
    for (int i=0; i<vec.size(); i++) {
        int tot = 0;
        printf(""%d "", i);
        if (vec[i].empty()) {
            printf(""0 "");
        }
        else{
            for (int j=0; j<vec[i].size(); j++) {
                printf(""%d "",vec[i][j]);
                tot += vec[i][j];
            }
        }
        printf(""%d\n"", tot);
    }
    
    /********* End *********/
```"
510,1140,算法与竞赛(第5章) - C++与STL基础一,rtzkp3fs4lcn,STL模板之关联容器：集合set的操作详解,2276,"```cpp

    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    // 1.创建一个空的集合st，数据类型为int
    set<int> st;
    
    // 2.读取数据：第一行整数n，后面n行插入或擦除操作，按指定要求输出相应信息
    int n;
    int x;
    char str[20];
    scanf(""%d"", &n);
    while (n--) {
        scanf(""%s %d"", str, &x);
        if (strcmp(str, ""insert"")==0) {
            if (st.find(x)==st.end()) {
                st.insert(x);
            }else{
                printf(""%d in set\n"", x);
            }
        }else if(strcmp(str, ""erase"")==0){
            if (st.find(x)!=st.end()) {
                st.erase(x);
            }else{
                printf(""%d not in set\n"", x);
            }
        }
    }
    
    // 3.遍历集合st，在一行输出集合所有元素，中间空格隔开，末尾'\n'
    printf(""print set: %d\n"", int(st.size()));
    for (set<int>::iterator it=st.begin(); it!=st.end(); it++) {
        if (it==st.begin()) {
            printf(""%d"", *it);
        }else{
            printf("" %d"", *it);
        }
    }
    printf(""\n"");
    
    // 4.读取数据：整数m以及m次查找操作，并按指定要求输出相应信息
    int m;
    scanf(""%d"", &m);
    while (m--) {
        scanf(""%s %d"", str, &x);
        if (st.find(x)!=st.end()) {
            printf(""find %d in set\n"", x);
        }else{
            printf(""find %d not in set\n"", x);
        }
    }
    
    // 5.情况集合st
    st.clear();
    
    /********* End *********/
```"
511,1140,算法与竞赛(第5章) - C++与STL基础一,mtfx43ol6r7f,STL模板之关联容器：集合set的应用实例,7900,"```cpp

    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    // 1.创建一个空的集合st，数据类型为char
    set<char> st;
    
    // 2.读取和处理数据：一行英文句子，长度不超过100
    char str[100];
    while (scanf(""%s"", str)!=EOF) {
        for (int i=0; i<strlen(str); i++) {
            if ('a'<=str[i] && str[i]<='z') {
                st.insert(str[i]);
            }
            if ('A'<=str[i] && str[i]<='Z') {
                st.insert(str[i]);
            }
        }
    }
    
    // 3.遍历集合st
    printf(""print set: %d\n"", int(st.size()));
    for (set<char>::iterator it=st.begin(); it!=st.end(); it++) {
        if (it==st.begin()) {
            printf(""%c"", *it);
        }else{
            printf("" %c"", *it);
        }
    }
    printf(""\n"");
    
    // 4.情况集合
    st.clear();
    
    /********* End *********/
```"
512,1140,算法与竞赛(第5章) - C++与STL基础一,wbf8cla4evuk,STL模板之键值对容器：映射map的操作详解,2278,"```cpp
  
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    // 1.创建一个空的映射mp: string->int
    map<string, int> mp;
    
    // 2.读取和处理数据：插入n个学生信息（姓名 成绩）
    int n;
    scanf(""%d"", &n);
    //printf(""%d\n"", n);
    char oper[20];
    char name[40];
    int score;
    while (n--) {
        scanf(""%s %s %d"", oper, name, &score);
        //printf(""%s %s %d\n"", oper, name, score);
        if (mp.find(name)!=mp.end()) {
            printf(""%s has been recorded\n"", name);
        }else{
            mp[name] = score;
        }
    }
    
    // 3.读取和处理数据：删除m个学生信息（姓名）
    int m;
    scanf(""%d"", &m);
    while (m--) {
        scanf(""%s %s"", oper, name);
        if (mp.find(name)==mp.end()) {
            printf(""%s has not been recorded\n"", name);
        }else{
            mp.erase(name);
        }
    }
            
    // 4.遍历映射mp
    printf(""print map: %d\n"", int(mp.size()));
    for (map<string, int>::iterator it=mp.begin(); it!=mp.end(); it++) {
        //printf(""%s %d\n"", it->first, it->second);
        cout<<it->first<<"" ""<<it->second<<endl;
    }
    
    // 5.查找k个学生信息
    int k;
    scanf(""%d"", &k);
    while (k--) {
        scanf(""%s %s"", oper, name);
        if (mp.find(name)==mp.end()) {
            printf(""%s cannot been found\n"", name);
        }else{
            printf(""%s score %d\n"", name, mp[name]);
        }
    }
    
    // 6.情况集合
    mp.clear();
    
    /********* End *********/
    printf(""%d\n"", int(mp.size()));
    
    return 0;
}

```"
513,1140,算法与竞赛(第5章) - C++与STL基础一,pmjon9uvwlz2,STL模板之键值对容器实例：基于map统计26个字母出现频率,2279,"```cpp
    
    // 请在这里补充代码，完成本关任务
    /********* Begin *********/
    
    // 1.创建一个空的映射mp: char->int
    map<char, int> mp;
    
    // 2.读取和处理数据：一行英文句子，长度不超过100，
    char str[100];
    while (scanf(""%s"", str)!=EOF) {
        for (int i=0; i<strlen(str); i++) {
            if ('a'<=str[i] && str[i]<='z') {
                if (mp.find(str[i])==mp.end()) {
                    mp[str[i]] = 1;
                }else{
                    mp[str[i]] += 1;
                }
            }
            if ('A'<=str[i] && str[i]<='Z') {
                if (mp.find(str[i])==mp.end()) {
                    mp[str[i]] = 1;
                }else{
                    mp[str[i]] += 1;
                }
            }
        }
    }
    
    // 3.遍历映射mp
    printf(""print map: %d\n"", int(mp.size()));
    for (map<char, int>::iterator it=mp.begin(); it!=mp.end(); it++) {
        printf(""%c %d\n"", it->first, it->second);
    }
    
    // 4.情况集合
    mp.clear();
    
    /********* End *********/
```"
514,1124,算法与竞赛(第4章) - C++与算法基础三,7ihfxzlw6ocb,序列合并,2234,"```cpp

int* Merge_Array(int *arr1, int n1, int *arr2, int n2)
// 函数功能：合并两个数组arr1和arr2，完成升序排序，返回排序后的合并数组
// 参数介绍：arr1数组一的首地址，n1数组一的个数，arr2数组二的首地址，n2数组二的个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int n3 = n1+n2;
    int *arr3;
    arr3 = (int*)malloc(sizeof(int)*n3);
    
    // 方法一
    for (int i=0; i<n1; i++) {
        arr3[i] = arr1[i];
    }
    for (int i=0; i<n2; i++) {
        arr3[n1+i] = arr2[i];
    }
    sort(arr3, arr3+n3);
    
    // 方法二
    sort(arr1, arr1+n1);
    sort(arr2, arr2+n2);
    merge(arr1, arr1+n1, arr2, arr2+n2, arr3);
    
    return arr3;
    /********** End **********/
}

```"
515,1124,算法与竞赛(第4章) - C++与算法基础三,t4vlm3cqufho,序列包含,2236,"```cpp

bool Include_Array(int *arr1, int n1, int *arr2, int n2)
// 函数功能：输入两个升序数组，判断数组arr2是否被包含在数组arr1中（arr2不要求连续，但顺序不能乱）
// 参数介绍：arr1数组一的首地址，n1数组一的个数，arr2数组二的首地址，n2数组二的个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    bool judge = true;
    
    // 方法一
    int p1 = 0;
    int p2 = 0;
    while (p2<n2 && p1<n1) {
        if (arr2[p2] == arr1[p1]) {
            p1++;
            p2++;
        }else{
            p1++;
        }
    }
    if (p2==n2 && p1<=n1) {
        judge = true;
    }else{
        judge = false;
    }
    
    // 方法二
    //judge = includes(arr1, arr1+n1, arr2, arr2+n2);
    
    return judge;
    /********** End **********/
}

```"
516,1124,算法与竞赛(第4章) - C++与算法基础三,kog8fu4h637a,集合并与交,2237,"```cpp

int Set_Union(int *arr1, int n1, int *arr2, int n2, int *arr3)
// 函数功能：给定两个数组arr1和arr2，计算他们的并集，然后存在数组arr3中，并返回并集大小
// 参数介绍：arr1数组一的首地址，n1数组一的个数，arr2数组二的首地址，n2数组二的个数，数组arr3
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    sort(arr1, arr1+n1);
    sort(arr2, arr2+n2);
    
    int n3;
    
    n3 = 0;
    for (int i=0; i<n1; i++) {
        arr3[n3++] = arr1[i];
    }
    for (int i=0; i<n2; i++) {
        bool flag = true;
        for (int j=0; j<n1; j++) {
            if (arr2[i]==arr1[j]) {
                flag = false;
            }
        }
        if (flag)
            arr3[n3++] = arr2[i];
    }
    
    n3 = set_union(arr1, arr1+n1, arr2, arr2+n2, arr3)-arr3;
    
    return n3;
    /********** End **********/
}


int Set_Intersection(int *arr1, int n1, int *arr2, int n2, int *arr3)
// 函数功能：给定两个数组arr1和arr2，计算他们的交集，然后存在数组arr3中，并返回交集大小
// 参数介绍：arr1数组一的首地址，n1数组一的个数，arr2数组二的首地址，n2数组二的个数，数组arr3
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    sort(arr1, arr1+n1);
    sort(arr2, arr2+n2);
    
    int n3;
    
    n3 = n1;
    for (int i=0; i<n1; i++) {
        arr3[i] = arr1[i];
    }
    for (int i=0; i<n2; i++) {
        bool flag = true;
        for (int j=0; j<n1; j++) {
            if (arr2[i]==arr1[j]) {
                flag = false;
            }
        }
        if (flag)
            arr3[n3++] = arr2[i];
    }
    
    n3 = set_intersection(arr1, arr1+n1, arr2, arr2+n2, arr3)-arr3;
    
    return n3;
    /********** End **********/
}


```"
517,1124,算法与竞赛(第4章) - C++与算法基础三,teliz87vqu6y,集合“差集”与“对称差集”,2238,"```cpp

int Set_Difference(int *arr1, int n1, int *arr2, int n2, int *arr3)
// 函数功能：给定两个数组arr1和arr2，计算arr1-arr2的差集，然后存在数组arr3中，并返回差集大小
// 参数介绍：arr1数组一的首地址，n1数组一的个数，arr2数组二的首地址，n2数组二的个数，数组arr3
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    sort(arr1, arr1+n1);
    sort(arr2, arr2+n2);
    
    int n3;
    
    n3 = set_difference(arr1, arr1+n1, arr2, arr2+n2, arr3)-arr3;
    
    return n3;
    /********** End **********/
}


int Set_Symmetric_Difference(int *arr1, int n1, int *arr2, int n2, int *arr3)
// 函数功能：给定两个数组arr1和arr2，计算（arr1-arr2）U（arr2-arr1），然后存在数组arr3中，最后数组大小
// 参数介绍：arr1数组一的首地址，n1数组一的个数，arr2数组二的首地址，n2数组二的个数，数组arr3
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    sort(arr1, arr1+n1);
    sort(arr2, arr2+n2);
    
    int n3;
    
    n3 = set_symmetric_difference(arr1, arr1+n1, arr2, arr2+n2, arr3)-arr3;
    
    return n3;
    /********** End **********/
}

```"
518,1124,算法与竞赛(第4章) - C++与算法基础三,e5i3pu86avb2,序列排列问题,2239,"```cpp

void Next_Permutation(int *arr, int n, int m)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    while (m--) {
        cout<<arr[0];
        for (int i=1; i<n; i++) {
            cout<<"" ""<<arr[i];
        }
        cout<<endl;
        next_permutation(arr, arr+n);
    }
    
    /********** End **********/
}

void Prev_Permutation(int *arr, int n, int m)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    while (m--) {
        cout<<arr[0];
        for (int i=1; i<n; i++) {
            cout<<"" ""<<arr[i];
        }
        cout<<endl;
        prev_permutation(arr, arr+n);
    }
    
    /********** End **********/
}

```"
519,1106,算法与竞赛(第3章) - C++与算法基础二,7wtr2hclm6bv,二分查找：在N个无序整数里面查找M个指定整数,2204,"```cpp
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int n, m;
    scanf(""%d"", &n);
    
    int *arr;
    arr = (int*)malloc(sizeof(int)*n);

    for (int i=0; i<n; i++) {
        scanf(""%d"", arr+i);
    }
    
    sort(arr, arr+n);
    
    scanf(""%d"", &m);
    while (m--) {
        int x;
        scanf(""%d"", &x);
        if (binary_search(arr, arr+n, x))
        {
            cout<<x<<"" in array""<<endl;
        }
        else{
            cout<<x<<"" not in array""<<endl;
        }
    }
    /********** End **********/
```"
520,1106,算法与竞赛(第3章) - C++与算法基础二,ero8bzguq7j6,二分查找：在N个有序整数里面查找M个指定整数的闭区间位置,2205,"```cpp
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/

    int n, m;
    scanf(""%d"", &n);
   
    int *arr;
    arr = (int*)malloc(sizeof(int)*n);
    
    for (int i=0; i<n; i++) {
        scanf(""%d"", arr+i);
    }
    
    scanf(""%d"", &m);
    while (m--) {
        int x;
        scanf(""%d"", &x);
        int a = lower_bound(arr, arr+n, x) - arr;
        int b = upper_bound(arr, arr+n, x) - arr;
        cout << x << "" at order array position ["" << a << "","" << b-1 << ""]\n"";
		
		//auto bounds = equal_range(arr, arr+n, x);
        //cout << x << "" at order array position ["" << bounds.first-arr << "","" << bounds.second-arr-1 << ""]\n"";
    }
	
    /********** End **********/
```"
521,1106,算法与竞赛(第3章) - C++与算法基础二,2eow3gy7pxft,修改序列（数组）操作的应用,2219,"```cpp

int* Copy_N(int *arr, int n)
// 函数功能：复制数组arr中前n个元素并作为函数返回值
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int *new_arr;
    new_arr = (int*)malloc(sizeof(int)*n);
    //copy(arr, arr+n, new_arr);    //方法一
    //copy_n(arr, n, new_arr);      //方法二
    for (int i=0; i<n; i++)         //方法三
    {
        new_arr[i] = arr[i];
    }
    return new_arr;
    /********** End **********/
}

void Swap(int &a, int &b)
// 函数功能：交换参数x和参数y
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //int c = a;    //方法一
    //a = b;
    //b = c;
    //a = a + b;    //方法二
    //b = a - b;
    //a = a - b;
    //a = a * b;    //方法三
    //b = a / b;
    //a = a / b;
    //a = a ^ b;    //方法四
    //b = a ^ b;
    //a = a ^ b;
    //a <<= 16;     //方法五
    //a |= b;
    //b = a >> 16;
    //a = a & 0xffff;
    swap(a, b);   //方法六
    /********** End **********/
}

void Replace(int *arr, int n, int x, int y)
// 函数功能：在数组arr中将元素x替换为y，其中n为数组个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //replace(arr, arr+n, x, y);    //方法一
    for (int i=0; i<n; i++) {       //方法二
        arr[i] = (arr[i]==x)?y:arr[i];
    }
    /********** End **********/
}

void Fill(int *arr, int n, int z)
// 函数功能：将大小为n的数组的所有元素填充为元素z
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //fill(arr, arr+n, z);    //方法一
    for (int i=0; i<n; i++) {       //方法二
        arr[i] = z;
    }
    /********** End **********/
}

void Reverse(int *arr, int n)
// 函数功能：倒置数组arr的元素，比如1 2 3，变为3 2 1，其中n为数组个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //reverse(arr, arr+n);           //方法一
    for (int i=0; i<n/2; i++) {       //方法二
        Swap(arr[i], arr[n-1-i]);
    }
    /********** End **********/
}

void Rotate(int *arr, int n, int m)
// 函数功能：向左边滚动m个元素，并补到数组右边，比如 1 2 3 4，滚动m=2个元素，结果为3 4 1 2，其中n=4是数组个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //rotate(arr, arr+m, arr+n);    //方法一
    for (int i=0; i<m; i++) {       //方法二
        int tmp = arr[0];
        for (int j=1; j<n; j++) {
            arr[j-1] = arr[j];
        }
        arr[n-1] = tmp;
    }
    /********** End **********/
}

```"
522,1106,算法与竞赛(第3章) - C++与算法基础二,hjib7yxgm52z,非修改序列（数组）操作的应用,2220,"```cpp

int* Find(int *first, int *last, int x)
// 函数功能：给定数组首地址和尾地址，若x在数组中，然后第一个x所在的地址，否则返回尾地址
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //return find(first, last, x);           //方法一
    //*
    int *p = first;
    while (p!=last) {                       //方法二
        if (*p == x) {
            return p;
        }
        p++;
    }
    return last;
    //*/
    /********** End **********/
}

int* Find_End(int *arr1, int n1, int *arr2, int n2)
// 函数功能：给定数组arr1，个数n1，数组arr2，个数n2，
//         若数组arr2在数组arr1中出现（连续），则返回数组arr2[0]在arr1中最后一次出现的地址
//         否则，返回数组arr1尾地址，即arr1+n1
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //return find_end(arr1, arr1+n1, arr2, arr2+n2);           //方法一
    int res = -1;
    for(int i=0;i<n1-n2+1;i++){                                //方法二
        int id = i;
        for (int j=0; j<n2; j++) {
            if (arr1[id] == arr2[j]) {
                id++;
            }else{
                break;
            }
        }
        if (id == i+n2) {
            res = i;
        }
    }
    if(res!=-1){
        return arr1+res;
    }else{
        return arr1+n1;
    }
    /********** End **********/
}

int Count(int *first, int *last, int x)
// 函数功能：给定数组首地址和尾地址，统计数组中元素x的个数，并返回
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //return count(first, last, x);           //方法一
    int cnt = 0;
    int *p = first;
    while (p!=last) {
        if (*p==x) {
            cnt++;
        }
        p++;
    }
    return cnt;
    /********** End **********/
}

bool Equal(int *arr1, int n1, int *arr2)
// 函数功能：给定数组arr1，个数n1，数组arr2，(两个数组个数相同)，判断两个数组是否相等
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //return equal(arr1, arr1+n1, arr2);           //方法一
    for (int i=0; i<n1; i++) {
        if (arr1[i]!=arr2[i]) {
            return false;
        }
    }
    return true;
    /********** End **********/
}

```"
523,1092,“绿盟杯”决赛第二阶段（C++）,qof53iwyxzbt,生日蜡烛,,
524,1092,“绿盟杯”决赛第二阶段（C++）,k3txachlv9gi,背包问题,,
525,1092,“绿盟杯”决赛第二阶段（C++）,2oce6r3qvhbg,页岩气勘探,,
526,1079,“绿盟杯”决赛第一阶段（C++）,g745eziwcmas,简单排序,,
527,1079,“绿盟杯”决赛第一阶段（C++）,3qo8f57wgb42,停电时间计算,,
528,1079,“绿盟杯”决赛第一阶段（C++）,t3e5a6cybjnw,停电日期判断,,
529,1080,算法与竞赛(第2章) - C++与算法基础一,a5uwlxofyien,Algorithm模板中的Min/Max应用,2184,"```cpp

    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    int    int_1,   int_2;
    float  float_1, float_2;
    char   char_1,  char_2;
    string str_1,   str_2;
    
    cin >> int_1   >> int_2;
    cin >> float_1 >> float_2;
    cin >> char_1  >> char_2;
    cin >> str_1   >> str_2;
    
    /*
    // algorithm 1 : min/max
    cout << ""min(""<<int_1   <<"","" <<int_2   <<"")=="" << min(int_1,   int_2)   << '\n';
    cout << ""max(""<<int_1   <<"","" <<int_2   <<"")=="" << max(int_1,   int_2)   << '\n';
    cout << ""min(""<<float_1 <<"","" <<float_2 <<"")=="" << min(float_1, float_2) << '\n';
    cout << ""max(""<<float_1 <<"","" <<float_2 <<"")=="" << max(float_1, float_2) << '\n';
    cout << ""min(""<<char_1  <<"","" <<char_2  <<"")=="" << min(char_1,  char_2)  << '\n';
    cout << ""max(""<<char_1  <<"","" <<char_2  <<"")=="" << max(char_1,  char_2)  << '\n';
    cout << ""min(""<<str_1   <<"","" <<str_2   <<"")=="" << min(str_1,   str_2)   << '\n';
    cout << ""max(""<<str_1   <<"","" <<str_2   <<"")=="" << max(str_1,   str_2)   << '\n';
     */
    
    // algorithm 2 : minmax
    cout << ""min(""<<int_1   <<"","" <<int_2   <<"")=="" << minmax(int_1,   int_2).first   << '\n';
    cout << ""max(""<<int_1   <<"","" <<int_2   <<"")=="" << minmax(int_1,   int_2).second   << '\n';
    cout << ""min(""<<float_1 <<"","" <<float_2 <<"")=="" << minmax(float_1, float_2).first << '\n';
    cout << ""max(""<<float_1 <<"","" <<float_2 <<"")=="" << minmax(float_1, float_2).second << '\n';
    cout << ""min(""<<char_1  <<"","" <<char_2  <<"")=="" << minmax(char_1,  char_2).first  << '\n';
    cout << ""max(""<<char_1  <<"","" <<char_2  <<"")=="" << minmax(char_1,  char_2).second  << '\n';
    cout << ""min(""<<str_1   <<"","" <<str_2   <<"")=="" << minmax(str_1,   str_2).first   << '\n';
    cout << ""max(""<<str_1   <<"","" <<str_2   <<"")=="" << minmax(str_1,   str_2).second   << '\n';
    
    /********** End **********/

```"
530,1080,算法与竞赛(第2章) - C++与算法基础一,eixa8vbf36sk,min函数在自定义数据类型下的应用,2187,"```cpp
bool min_cmp(Student S1, Student S2){
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (S1.score == S2.score) {
        return S1.numberID < S2.numberID;
    }
    else{
        return S1.score < S2.score;
    }
    /********** End **********/
}

int main(int argc, const char * argv[]) {
    
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Student S1, S2;
    S1.in();
    S2.in();
    
    Student S3 = min(S1, S2, min_cmp);
    S3.out();
    
    /********** End **********/

    return 0;
}
```"
531,1080,算法与竞赛(第2章) - C++与算法基础一,lnxrzifqw6oa,使用模板函数sort对学生成绩进行排序,2193,"```cpp
bool operator < (const Student &S)const{
	// 请在这里补充代码，完成本关任务
	/********** Begin *********/
	if (score == S.score) {
		return numberID < S.numberID;
	}
	else{
		return score > S.score;
	}
	/********** End **********/
}

bool max_cmp(Student S1, Student S2){
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (S1.score == S2.score) {
        return S1.numberID < S2.numberID;
    }
    else{
        return S1.score > S2.score;
    }
    /********** End **********/
}


    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int N;
    scanf(""%d"", &N);
    Student *S;
    S = (Student*)malloc(sizeof(Student)*N);
    for (int i=0; i<N; i++) {
        S[i].in();
    }
    
    //sort(S, S+N, max_cmp);
    sort(S, S+N);
    
    for (int i=0; i<N; i++) {
        S[i].out();
    }
    
    /********** End **********/
    
```"
532,1061,算法与竞赛(第1章) - 入门指南,g7mrz3wlh65o,程序三步曲,2152,"```cpp
    
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    // 1.读取数据
    int a, b;
    scanf(""%d %d"", &a, &b);
    
    // 2.运算分析，
    if (a < b)
    {
        // 3.输出结果
        printf(""%d %d\n"", a, b);
    }
    else
    {
        printf(""%d %d\n"", b, a);
    }
    
    /********** End **********/
    

```"
533,1061,算法与竞赛(第1章) - 入门指南,cpke9vahs6bf,牛刀小试,2153,"```cpp
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    // 1.读取数据
    int a, b, c;
    scanf(""%d %d %d"", &a, &b, &c);
    
    // 2.运算分析，
    if (a < b && a < c){
        if (b < c) {
            // 3.输出结果
            printf(""%d %d %d\n"", a, b, c);
        }
        else {
            printf(""%d %d %d\n"", a, c, b);
        }
    }
    else if (b < a && b < c){
        if (a < c) {
            printf(""%d %d %d\n"", b, a, c);
        }
        else {
            printf(""%d %d %d\n"", b, c, a);
        }
    }
    else if (c < a && c < b){
        if (a < b) {
            printf(""%d %d %d\n"", c, a, b);
        }
        else {
            printf(""%d %d %d\n"", c, b, a);
        }
    }
    
    /********** End **********/
```"
534,1061,算法与竞赛(第1章) - 入门指南,7upljavkcit6,崭露头角,2154,"```cpp
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    // 1.读取数据
    int n;
    scanf(""%d"", &n);
    int *arr;
    arr = (int*)malloc(sizeof(int)*n);
    for (int i=0; i<n; i++) {
        scanf(""%d"", arr+i);
    }
    
    // 2.运算分析
    for (int i=0; i<n; i++) {
        for (int j=0; j<n-1-i; j++) {
            if (arr[j] > arr[j+1]) {
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            }
        }
    }
    
    // 3.输出结果
    printf(""%d"", arr[0]);
    for (int i=1; i<n; i++) {
        printf("" %d"", arr[i]);
    }
    printf(""\n"");
    
    /********** End **********/
```"
535,1061,算法与竞赛(第1章) - 入门指南,yf38owtkgjzb,结构体运用,2155,"```cpp

// 计算面积
double area(Point p1, Point p2)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Point p = p1 - p2;
    double w = (p.x > 0) ? p.x : -p.x;
    double h = (p.y > 0) ? p.y : -p.y;
    double s = w * h;
    return s;
    /********** End **********/
}

// 计算周长
double perimeter(Point p1, Point p2)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Point p = p1 - p2;
    double w = (p.x > 0) ? p.x : -p.x;
    double h = (p.y > 0) ? p.y : -p.y;
    double c = 2 * (w + h);
    return c;
    /********** End **********/
}

// 计算中心点
Point center(Point p1, Point p2)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Point pc = (p1 + p2) * 0.5;
    return pc;
    /********** End **********/
}

```"
536,1035,全国绿色计算大赛 模拟赛第三阶段（C++）,p8ojgtqh65bi,标签推荐,2104,"标准csv文件为：
```
id,recommand_tags
1,""<html>,<objective-c>,<java>,<ios>,<ruby>,<nginx>,<mysql>,<shell>,<javascript>,<redis>""
2,""<ehcache>,<jfinal>,<jboot>,<mysql>,<shell>,<nginx>,<html>,<database>,<django>,<websocket>""
3,""<jfinal>,<echarts>,<数据库>,<weixin>,<hibernate>,<shiro>,<redis>,<zookeeper>,<lua>,<druid>""
4,""<jquery>,<react>,<nodejs>,<python>,<angular>,<php>,<shell>,<nginx>,<java>,<redis>""
5,""<redis>,<mysql>,<shell>,<oracle>,<ios>,<android>,<objective-c>,<python>,<ruby>,<php>""
6,""<spring>,<hibernate>,<sql>,<mysql>,<大数据>,<ios>,<人工智能>,<zookeeper>,<lucene>,<redis>""
7,""<spring>,<database>,<shiro>,<bootstrap>,<jetty>,<redis>,<mybatis>,<mongodb>,<wechat>,<android>""
8,""<java>,<docker>,<maven>,<redis>,<beetl>,<echarts>,<angularjs>,<nodejs>,<druid>,<echarts>""
9,""<cocoapods>,<php>,<database>,<ruby>,<uikit>,<xcode>,<swift>,<xhtextfield>,<xhshockhud>,<xhscrollmenu>""
10,""<pyqt>,<c++>,<前端开发>,<webkit>,<nodejs>,<游戏>,<android>,<css>,<shell>,<jquery>""
11,""<sqlite>,<php>,<sql>,<php框架>,<html>,<mysql>,<javascript>,<chrome>,<管理系统>,<go>""
12,""<数据库>,<mybatis>,<hibernate>,<bootstrap>,<jquery>,<oracle>,<redis>,<云计算>,<ehcache>,<微服务框架>""
13,""<mysql>,<网络爬虫>,<java>,<redis>,<html>,<php>,<sql>,<postgresql>,<linux内核>,<oracle>""
14,""<zookeeper>,<大数据>,<druid>,<hdfs>,<ribbon>,<spring>,<bootstrap>,<jquery>,<kafka>,<mariadb>""
15,""<python>,<perl>,<java>,<objective-c>,<asp>,<maven>,<html>,<android>,<ios>,<go>,<lua>""
16,""<javascript>,<wechat>,<docker>,<nginx>,<redis>,<android>,<weui>,<游戏>,<hack>,<nodejs>""
17,""<mysql>,<linux内核>,<c++>,<bash>,<lua>,<cmake>,<rust>,<swift>,<图像处理>,<qt>""
18,""<chrome>,<css框架>,<html>,<前端开发>,<quickcss>,<qux>,<app>,<safari>,<网页组件>,<opera>""
19,""<javascript>,<jquery>,<ajax>,<regex>,<c++>,<nodejs>,<数据库>,<bootstrap>,<go>,<java>""
20,""<mongodb>,<mysql>,<nginx>,<shiro>,<zookeeper>,<bootstrap>,<solr>,<nosql>,<ajax>,<jquery>""

```"
537,1016,全国绿色计算大赛 模拟赛第二阶段（C++）,ei7hxy8qgrp3,气温预测,2077,"```
int* dailyTemps(int temps[], int size)
{
	int *result = new int[size];
	/********** BEGIN **********/
	for(int i = 0; i < size; i++)
    {
        bool point = true;
        for(int j = i + 1; j < size; j++)
        {
            if(temps[i] < temps[j])
            {
                result[i] = j - i;
                point = false;
                break;
            }
        }
        
        if(point)
            result[i] = 0;
        
    }
	
	/********** END **********/
	return result;
}
```"
538,1016,全国绿色计算大赛 模拟赛第二阶段（C++）,jnv32w7qfecs,折纸小游戏,2078,"```
void Square(int m, int n, int &j, int &k)
{
	/********** BEGIN **********/
    int max = m > n? m : n;
    int min = m > n? n : m;
    
    while(max % min != 0)
    {
        int tmp = max % min;
        max = min;
        min = tmp;
    }
    
    j = min;
    k = (m*n)/(j*j);
	
	/********** END **********/
}
```"
539,1016,全国绿色计算大赛 模拟赛第二阶段（C++）,ueo89caxpkmn,渡口与船,2079,"```
int countOfShips(char **ferry, int m, int n)
{
	/********** BEGIN **********/
    int ret = 0;
    if(m == 0 || n == 0)
        return ret;
    
    for(int i = 0; i < m; i++)
    {
        for(int j = 0; j < n; j++)
        {
            if(ferry[i][j] == '+')
            {
                if(i == 0 && j == 0)
                    ret++;
                else if(i == 0 && ferry[i][j-1] == 'o')
                    ret++;
                else if(j == 0 && ferry[i-1][j] == 'o')
                    ret++;
                else if(j != 0 && i != 0 && ferry[i-1][j] == 'o' && ferry[i][j-1] == 'o')
                    ret++;
            }
        }
    }
    
    return ret;
	
	/********** END **********/
}
```"
540,1030,全国绿色计算大赛 模拟赛第一阶段（C++）,r7mj46zkub5v,求和,2082,"```
int getSum(int num1, int num2)
{
	/********** BEGIN **********/
	int sum = 0;
    for(int i = num1; i <= num2; i++)
    {
        int tmp = i;
        while(tmp >= 10)
        {
            sum += (tmp % 10);
            tmp /= 10;
        }
        
        sum += tmp;
    }
    
    return sum;
	
	/********** END **********/
}
```"
541,1030,全国绿色计算大赛 模拟赛第一阶段（C++）,83hanrei2xkj,文件查看器,2083,"```
int level = 0; //记录文件夹层数

/***************************
 * func: 遍历文件夹
 * return: void
 * @para folderPath: 文件夹路径
***************************/
void showDirStructure(char *folderPath)
{
	/********** BEGIN **********/
    level++;   
    DIR *fd = opendir(folderPath);
    if(fd == NULL)
    {
        cout << ""open folder failure!"" << endl;
        return ;
    }
    
    //只打印目录名
    int index = 0;
    for(int i = 0; i < strlen(folderPath); i++)
    {
        if(folderPath[i] == '/')
            index = i+1;
    }
    for(int i = 1; i < level; i++)
        cout << ""  "";
    cout << ""+--"" << &folderPath[index] << endl;
    
    struct dirent *dir;
    struct stat statbuf;
    while((dir = readdir(fd)) != NULL)
    {
        if(strcmp(dir->d_name, ""."") == 0 || strcmp(dir->d_name, "".."") == 0)
            continue;
        
        char tmp_name[1024];
        sprintf(tmp_name, ""%s/%s"", folderPath, dir->d_name);
        stat(tmp_name, &statbuf);
        
        //判断是目录则递归调用打开函数
        if(S_ISDIR(statbuf.st_mode))
            showDirStructure(tmp_name);
        else if(S_ISREG(statbuf.st_mode))
        {
            for(int i = 0; i < level; i++)
                cout << ""  "";
            cout << ""--"" << dir->d_name << endl;
        }
    }
    
    level--;
    closedir(fd);
	
	/********** END **********/
}
```"
542,1030,全国绿色计算大赛 模拟赛第一阶段（C++）,magtsp7ybunc,图片查看器,2084,"```
int level = 0; //记录文件夹层数

/***************************
 * func: 遍历文件夹
 * return: void
 * @para folderPath: 文件夹路径
***************************/
void showDirStructure(char *folderPath)
{
	/********** BEGIN **********/
    level++;   
    DIR *fd = opendir(folderPath);
    if(fd == NULL)
    {
        cout << ""open folder failure!"" << endl;
        return ;
    }
    
    //只打印目录名
    int index = 0;
    for(int i = 0; i < strlen(folderPath); i++)
    {
        if(folderPath[i] == '/')
            index = i+1;
    }
    for(int i = 1; i < level; i++)
        cout << ""  "";
    cout << ""+--"" << &folderPath[index] << endl;
    
    struct dirent *dir;
    struct stat statbuf;
    while((dir = readdir(fd)) != NULL)
    {
        if(strcmp(dir->d_name, ""."") == 0 || strcmp(dir->d_name, "".."") == 0)
            continue;
        
        char tmp_name[1024];
        sprintf(tmp_name, ""%s/%s"", folderPath, dir->d_name);
        stat(tmp_name, &statbuf);
        
        //判断是目录则递归调用打开函数
        if(S_ISDIR(statbuf.st_mode))
            showDirStructure(tmp_name);
        else if(S_ISREG(statbuf.st_mode))
        {
            //判断是否为图片格式文件
            int length = strlen(dir->d_name);
            if(length > 4)
            {
                char *type = &dir->d_name[length-4];
                if(strcmp(type, "".bmp"") == 0 || strcmp(type, "".png"") == 0 || strcmp(type, "".jpg"") == 0)
                {
                    for(int i = 0; i < level; i++)
                        cout << ""  "";
                    cout << ""--"" << dir->d_name << endl;
                }
            }
        }
    }
    
    level--;
    closedir(fd);
	
	/********** END **********/
}
```"
543,885,数据结构-十大经典排序算法,z6kybw2ipguq,冒泡排序,1765,"```cpp
void sort_array(int *arr, int n)
//  编程实现《冒泡排序算法》：将乱序序列arr转化为升序序列
//  函数参数：乱序整数数组arr 数组长度
//  要求输出：调用print_array(int *arr, int n)输出前三次冒泡操作后的序列，以及最终的升序序列
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    for (int i=0; i<n; i++) {
        for (int j=0; j<n-1-i; j++) {
            if(arr[j]>arr[j+1]){
                swap(arr[j], arr[j+1]);
            }
        }
        if (i<3) {
            print_array(arr, n);
        }
    }
    print_array(arr, n);
    
    /********** End **********/
}
```"
544,885,数据结构-十大经典排序算法,n2a5jl34yufe,选择排序,1766,"```cpp
void sort_array(int *arr, int n)
//  编程实现《选择排序算法》：将乱序序列arr转化为升序序列
//  函数参数：乱序整数数组 数组长度
//  要求输出：调用print_array(int *arr, int n)输出前三次冒泡操作后的序列，以及最终的升序序列
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    for (int i=0; i<n-1; i++) {
        int minIdx = i;
        for (int j=i+1; j<n; j++) {
            if(arr[minIdx]>arr[j]){
                minIdx = j;
            }
        }
        swap(arr[i], arr[minIdx]);
        // 交换arr[i]和arr[minIdx]
        
        if (i<3) {
            print_array(arr, n);
        }
    }
    print_array(arr, n);
    
    /********** End **********/
}
```"
545,885,数据结构-十大经典排序算法,68lbfmogxuys,插入排序,1767,"```cpp

void sort_array(int *arr, int n)
//  编程实现《插入排序算法》：将乱序序列arr转化为升序序列
//  函数参数：乱序整数数组（无重复元素） 数组长度
//  要求输出：调用print_array(int *arr, int n)输出前三次插入操作后的序列，以及最终的升序序列
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    for (int i=1; i<n; i++) {
        int val = arr[i];
        for (int j=i-1; j>=0; j--) {
            if(val<arr[j]){
                arr[j+1] = arr[j];
                arr[j] = val;
            }else{
                break;
            }
        }
        if(i<=3){
            print_array(arr, n);
        }
    }
    print_array(arr, n);
    
    /********** End **********/
}

```"
546,885,数据结构-十大经典排序算法,rw53vqo8txfa,希尔排序,1768,"```cpp
void sort_array(int *arr, int n)
//  编程实现《希尔排序算法》
//  函数参数：乱序整数数组 数组长度
//  函数返回值：返回从小到大排序后的数组
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int gap_arr[3] = {5, 2, 1};
    for(int g=0; g<3; g++) {
        int gap = gap_arr[g];
        // 缩小增量
        for(int i = gap; i < n; i++) {
            //插入排序简洁写法
            int val = arr[i];
            for(int j = i-gap; j>=0; j-=gap){
                if(arr[j]>val){
                    arr[j+gap] = arr[j];
                    arr[j] = val;
                }else{
                    break;
                }
            }
        }
        print_array(arr, n);
    }
    print_array(arr, n);
    /********** End **********/
}
```"
547,885,数据结构-十大经典排序算法,ronai82w3qsf,归并排序,1769,"```cpp
int* merge_array(int *arr1, int n1, int* arr2, int n2)
//  编程实现两个有序数组arr1和arr2合并
//  函数参数：有序数组arr1 数组arr1长度 有序数组arr2 数组arr2长度
//  函数返回值：返回从小到大排序后的合并数组
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/

    int* arr = (int*)malloc(sizeof(int)*(n1+n2));
    int p = 0;
    int p1 = 0;
    int p2 = 0;
    while (p1<n1 || p2<n2) {
        if(p1<n1 && p2<n2){
            // 自上而下的递归方法使得这两个数组各自是有序的
            // 选择两个数组较小的给arr
            if (arr1[p1]<arr2[p2]) {
                arr[p++] = arr1[p1++];
            }else{
                arr[p++] = arr2[p2++];
            }
        }else if(p1<n1){
            // arr2排完了，余下arr1
            arr[p++] = arr1[p1++];
        }else if(p2<n2){
            // arr1排完了，余下arr2
            arr[p++] = arr2[p2++];
        }
    }
    return arr;

    /********** End **********/
}

int* merge_sort(int *arr, int n)
//  编程实现归并排序：自上而下的递归方法
//  函数参数：有序数组arr 数组arr长度
//  函数返回值：返回从小到大排序后的数组
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(n==1){
        return arr;
    }
    int m = n/2;
    int* arr1 = (int*)malloc(sizeof(int)*(m));
    int* arr2 = (int*)malloc(sizeof(int)*(n-m));

    for (int i=0, j=0; i<m; i++, j++) {
        // 左半边数组给arr1
        arr1[j] = arr[i];
    }
    for (int i=m, j=0; i<n; i++, j++) {
        // 右半边数组给arr2
        arr2[j] = arr[i];
    }

    // 递归子数组
    arr1 = merge_sort(arr1, m);
    arr2 = merge_sort(arr2, n-m);

    // 合并子数组
    return merge_array(arr1, m, arr2, n-m);

    /********** End **********/
}

```"
548,885,数据结构-十大经典排序算法,plvwokjm8zrf,快速排序,1770,"```cpp
int partition_array(int *arr ,int l,int r)
// 编程实现arr[l, r]分区：选定一个基准，左边比基准小，右边比基准大
// 返回基准所处位置
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int pivot = l;
    // 设定基准值
    int index = pivot + 1;
    for (int i = index; i <= r; i++) {
        if (arr[i] < arr[pivot]) {
            swap(arr[i], arr[index]);
            index++;
        }
    }
    swap(arr[pivot], arr[index-1]);
    return index-1;
    /********** End **********/
}

int* quick_sort(int *arr, int l, int r)
//  编程实现快速排序：自上而下的递归方法
//  函数参数：有序数组arr 初始l=0，r=n-1
//  函数返回值：返回从小到大排序后的数组
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (l<r)
    {
        int m = partition_array(arr, l, r);
        // 递归子数组
        quick_sort(arr, l, m-1);
        quick_sort(arr, m+1, r);

        return arr;
    }
    else
    {
        return arr;
    }
    /********** End **********/
}

```"
549,885,数据结构-十大经典排序算法,8hqbkfuvf679,堆排序,1771,"```cpp
void adjustHeap(int *arr, int param1, int j)
// 编程实现堆的调整
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int temp=arr[param1];
    for (int k=param1*2+1;k<j;k=k*2+1)
    {
        //如果右边值大于左边值，指向右边
        if (k+1<j && arr[k]< arr[k+1])
        {
            k++;
        }
        //如果子节点大于父节点，将子节点值赋给父节点,并以新的子节点作为父节点（不用进行交换）
        if (arr[k]>temp)
        {
            arr[param1]=arr[k];
            param1=k;
        }
        else
            break;
    }
    arr[param1]=temp;

    /********** End **********/
}


int* heap_sort(int *arr, int n)
//  编程实现堆排序
//  函数参数：有序数组arr 数组长度n
//  函数返回值：返回从小到大排序后的数组
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    //1.构建大顶堆
    for (int i=n/2-1;i>=0;i--)
    {
        adjustHeap(arr, i, n);
    }
    //2.调整堆结构+交换堆顶元素与末尾元素
    for (int j=n-1;j>0;j--)
    {
        //堆顶元素和末尾元素进行交换
        swap(arr[0], arr[j]);

        adjustHeap(arr, 0, j);//重新对堆进行调整
    }
    return arr;
    /********** End **********/
}

```"
550,885,数据结构-十大经典排序算法,r3wtpkuoaf7n,计数排序,1772,"```cpp
void sort_array(int *arr, int n)
//  编程实现《计数排序算法》
//  函数参数：乱序整数数组 数组长度
//  函数返回值：返回从小到大排序后的数组
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    // 数组最大值
    int maxVal = arr[0];
    for (int i=1; i<n; i++) {
        if(maxVal<arr[i]){
            maxVal = arr[i];
        }
    }
    // 申请计数数组，并初始化为0
    int* cnt = (int*)malloc(sizeof(int)*(maxVal+1));
    for (int i=0; i<=maxVal; i++) {
        cnt[i] = 0;
    }
    // 对arr数组元素计数
    for (int i=0; i<n; i++) {
        cnt[arr[i]]++;
    }
    // 顺序输出计数结果
    for (int i=0, k=0; i<=maxVal; i++){
        if (cnt[i]) {
            printf(""%d %d\n"", i, cnt[i]);
        }
        for (int j=0; j<cnt[i]; j++) {
            arr[k++] = i;
        }
    }

    print_array(arr, n);
    
    /********** End **********/
}

```"
551,885,数据结构-十大经典排序算法,vg8qtrcw9ej3,桶排序,1773,"```cpp
int* sort_array(int *arr, int n)
//  编程实现《桶排序算法》
//  函数参数：乱序整数数组 数组长度
//  函数返回值：返回从小到大排序后的数组
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/

    int i;
    int maxValue = arr[0];
    for (i = 1; i < n; i++) {
        if (arr[i] > maxValue) {
            maxValue = arr[i];
            // 输入数据的最大值
        }
    }

    // 设置10个桶，依次0，1，，，9
    const int bucketCnt = 10;
    vector<int> buckets[bucketCnt];

    // 桶的大小bucketSize根据数组最大值确定：比如最大值99， 桶大小10
    //                                    最大值999，桶大小100
    // 根据最高位数字映射到相应的桶，映射函数为 arr[i]/bucketSize
    int bucketSize = 1;
    while (maxValue) {
        maxValue /= 10;
        bucketSize *= 10;
    }
    bucketSize /= 10;

    // 入桶
    for (int i=0; i<n; i++) {
        int idx = arr[i]/bucketSize;
        buckets[idx].push_back(arr[i]);
        // 对该桶使用插入排序，维持该桶的有序性
        for (int j=int(buckets[idx].size())-1; j>0; j--) {
            if (buckets[idx][j]<buckets[idx][j-1]) {
                swap(buckets[idx][j], buckets[idx][j-1]);
            }
        }
    }

    // 顺序访问桶，得到有序数组
    for (int i=0, k=0; i<bucketCnt; i++) {
        for (int j=0; j<int(buckets[i].size()); j++) {
            arr[k++] = buckets[i][j];
        }
    }

    return arr;

    /********** End **********/
}


```"
552,885,数据结构-十大经典排序算法,67b5jpuarhoz,基数排序,1774,"```cpp

int* sort_array(int *arr, int n)
//  编程实现《基数排序算法》
//  函数参数：乱序整数数组 数组长度
//  函数返回值：返回从小到大排序后的数组
{   
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    int i;
    int maxValue = arr[0];
    for (i = 1; i < n; i++) {
        if (arr[i] > maxValue) {
            maxValue = arr[i]; 
            // 输入数据的最大值
        }
    }
    
    const int radixCnt = 10;
    vector<int> radixs[radixCnt];
    
    int maxDigit = 0;
    while (maxValue) {
        maxValue /= 10;
        maxDigit++;
    }
    
    for (int i=0, dev=1; i<maxDigit; i++, dev*=10) {
        for (int j=0; j<radixCnt; j++) {
            radixs[j].clear();
        }   
        for (int j=0; j<n; j++) {
            int digit = (arr[j]/dev)%10;
            radixs[digit].push_back(arr[j]);
        }   
        for (int j=0, t=0; j<radixCnt; j++) {
            for (int k=0; k<int(radixs[j].size()); k++) {
                arr[t++] = radixs[j][k];
            }   
        }   
    }   
    

    return arr;
    
    /********** End **********/
}   

```"
553,969,程序设计二（面向对象）_实训13_虚函数,l2xpbvier59q,设计和使用虚函数,,
554,969,程序设计二（面向对象）_实训13_虚函数,ci2qzm75f4lg,普通非成员函数的动态绑定,,
555,969,程序设计二（面向对象）_实训13_虚函数,hrfksjyacm7i,接口继承,,
556,1022,数据结构-二叉查找树的应用,pct2e6hfvxrg,二叉排序树应用一,2072,"```cpp

BiTreeNode* insertBiSortTree(BiTreeNode* root, int key)
// 功能：实现向升序二叉排序树插入元素
// 输入：待插入元素key
// 返回：升序二叉排序树根节点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(root==NULL){
        root = new BiTreeNode(key);
    }
    else{
        if(key < root->data){
            root->left = insertBiSortTree(root->left, key);
        }
        else{
            root->right = insertBiSortTree(root->right, key);
        }
    }
    return root;
	 /********** End **********/
}

BiTreeNode* creatBiSortTree(int* arr, int n)
// 功能：实现创建升序二叉排序树
// 输入：无序整数数列arr，数列个数n
// 返回：升序二叉排序树根节点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    BiTreeNode* root = NULL;
    for (int i=0; i<n; i++) {
        root = insertBiSortTree(root, arr[i]);
    }
    return root;
    /********** End **********/
}


```"
557,1022,数据结构-二叉查找树的应用,4r23uigecsq5,二叉排序树应用二,2074,"```cpp

int* InOrder(BiTreeNode* root, int* arr, int &i)
// 功能：实现升序二叉排序树的中序遍历
// 参数：二叉树根节点root，整数数列arr，起始下标i=0
// 返回：中序遍历数列arr
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (root==NULL) {
        return arr;
    }
    InOrder(root->left, arr, i);
    arr[i++] = root->data;
    InOrder(root->right, arr, i);
    return arr;
	/********** End **********/
}

bool isOrder(int* arr, int n)
// 功能：判断数列arr是否升序
// 参数：数列arr，数列个数n
// 返回：若升序返回true，否则返回false
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    for(int i=0; i<n-1; i++){
        if(arr[i]>arr[i+1]){
            return false;
        }
    }
    return true;
	/********** End **********/
}



```"
558,1025,数据结构-队列的应用,tg5ora67ybef,循环队列,2062,"```cpp
bool isFull(Queue* que)
//  判断队列que是否为满
//  若满返回 true 并在一行打印 The queue is Full 末尾换行！！！
//  否则返回 false

{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if((que->rear+1) % que->maxSize == que->front)
    {
        printf(""The queue is Full\n"");
        return true;
    }else{
        return false;
    }
    /********** End **********/
}

bool isEmpty(Queue* que)
//  判断队列que是否为空
//  若空返回 true 并在一行打印 The queue is Empty 末尾换行！！！
//  否则返回 false
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(que->front == que->rear)
    {
        printf(""The queue is Empty\n"");
        return true;
    }else{
        return false;
    }
    /********** End **********/
}

int enQueue(Queue* que, int item)
//  实现入队操作：将元素item加入队列que尾部
//  若队列没满，编写加入操作，返回 1
//  若队列满了，不做任何操作，返回 -1
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(isFull(que)==true){
        return -1;
    }else{
        que->data[que->rear] = item;
        que->rear = (que->rear + 1) % que->maxSize;
        return 1;
    }
    /********** End **********/
}

int deQueue(Queue* que)
//  实现出队操作：移除队列que首部元素，并返回元素值
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(isEmpty(que)==true){
        return -1;
    }else{
        int item = que->data[que->front];
        que->front = (que->front + 1) % que->maxSize;
        return item;
    }
    /********** End **********/
}

```"
559,1025,数据结构-队列的应用,tylfp5h86qnx,链队列,2063,"```cpp

bool isEmpty(LinkQueue* que)
//  判断队列que是否为空
//  若空返回 true 并在一行打印 The queue is Empty 末尾换行！！！
//  否则返回 false
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if( que->front == que->rear){
        printf(""The queue is Empty\n"");
        return true;
    }
    else
        return false;
    /********** End **********/
}

void enQueue(LinkQueue* que, int item)
//  实现入队操作：将元素item加入队列que尾部
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Node *node = (Node*)malloc(sizeof(Node));
    node->data = item;
    node->next = NULL;
    que->rear->next = node;
    que->rear = node;
    /********** End **********/
}

int deQueue(LinkQueue* que)
//  实现出队操作：移除队列que首部元素，并返回元素值
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if( isEmpty(que) == true)
    {
        return -1;
    }
    
    Node *node = que->front->next;
    //从队头出队，front指向的结点不出队，这个结点没有实际意义。
    //队首结点是front->next指向的结点。
    
    int item = node->data;          //获取对首元素
    que->front->next = node->next;  //修改front->next来移除对首元素
    //que->front->next = que->front->next->next;
    delete node;	//删除节点，清空内存
    if( que->front->next == NULL ){
        que->rear = que->front;
        //当队列最后一个元素被删除后，队列尾指针也丢失了，因此需对队尾指针重新赋值，即指向头结点。
    }
    
    return item;
    /********** End **********/
}

```"
560,1025,数据结构-队列的应用,t5kalofxzje3,单链表循环队列,2064,"```cpp

bool isEmpty(CycleQueue* que)
//  判断队列que是否为空
//  若空返回 true 并在一行打印 The queue is Empty 末尾换行！！！
//  否则返回 false
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if( que->size_ == 0){
        printf(""The queue is Empty\n"");
        return true;
    }
    else
        return false;
	
	/********** End **********/
}

void enQueue(CycleQueue* que, int item)
//  实现入队操作：将元素item加入队列que尾部
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Node *node = (Node*)malloc(sizeof(Node));
    node->data = item;
    if (que->size_ == 0)
    {
        que->rear = node;
        que->rear->next = node;
    }
    else
    {
        Node *temp = que->rear->next;
        que->rear->next = node;
        node->next = temp;
        que->rear = node;
        que->rear->next = temp;
    }
    que->size_++;
	
	/********** End **********/
}

int deQueue(CycleQueue* que)
//  实现出队操作：移除队列que首部元素，并返回元素值
{
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Node *node = que->rear->next;
    que->rear->next = node->next;
    que->size_--;
    return node->data;
	
	/********** End **********/
}

```"
561,946,程序设计二（面向对象）_实训12_公有继承,6jphngmrfo4y,父类和子类,,
562,946,程序设计二（面向对象）_实训12_公有继承,a5z76ujlwco3,子类的对象可以作为父类类型使用,,
563,946,程序设计二（面向对象）_实训12_公有继承,wezvsgn96a4c,利用父类的构造函数实现子类的构造函数,,
564,987,“绿盟杯”模拟赛第一阶段（C++）,fj9nh8ruzgsb,简单排序,2014,"```c
/*************************************************************************
    > File Name: sort.cpp
    > Author: ma6174
    > Mail: ma6174@163.com 
    > Created Time: Mon 21 May 2018 10:19:01 PM CST
 ************************************************************************/

#include<iostream>
#include <string.h>
#include ""sort.h""
using namespace std;

int sortArray(int *arr, int number, char *sort)
{
	/********************begin***************/
	
	
	cin>>number;
    for(int i=0;i<number;i++)
    {
        cin>>arr[i];
    }
    cin>>sort;
    for(int i=0;i<number-1;i++)
    {
        for(int j=i+1;j<number;j++)
        {
            if(sort[0]=='a')
            {
                if(arr[i]>arr[j])
                {
                    int t=arr[i];
                    arr[i]=arr[j];
                    arr[j]=t;
                }
            }
            else
            {
                if(arr[i]<arr[j])
                {
                    int t=arr[i];
                    arr[i]=arr[j];
                    arr[j]=t;
                }
            }
        }
    }
    for(int i=0;i<number;i++)
        cout<<arr[i]<<endl;
	
	
	/*********************end****************/
}


```"
565,987,“绿盟杯”模拟赛第一阶段（C++）,kf8mxvb93ej7,奇偶数判断与求和,2016,"```c
/*************************************************************************
    > File Name: sum.cpp
    > Author: ma6174
    > Mail: ma6174@163.com 
    > Created Time: Tue 22 May 2018 10:12:27 PM CST
 ************************************************************************/

#include<iostream>
using namespace std;

int main(int argc, char *argv[])
{
	int number = 0;
	cin>>number;

	/***************begin******************/
	
	
	double sum=0;
    int k,i;
    if(number%2==0)
    {
        k=3;i=2;
    }
    else k=4,i=1;
    for(;i<=number;i+=2)
    {
        sum+=k*1.0/i;
    }
	cout<<sum<<endl;
	
	/****************end*******************/
}

```"
566,987,“绿盟杯”模拟赛第一阶段（C++）,ubk6vnt2afxz,矩阵求和,2017,"```c
/*************************************************************************
    > File Name: Matrix.cpp
    > Author: ma6174
    > Mail: ma6174@163.com 
    > Created Time: Tue 22 May 2018 10:40:58 PM CST
 ************************************************************************/

#include<iostream>
#include <malloc.h>

using namespace std;

int main(int argc, char *argv[])
{
	int width = 0;
	cin>>width;
	int **arr = NULL;//二维数组
	int sum = 0;
	arr = (int **)malloc(sizeof(int*) * width);
	for (int i = 0; i < width; ++i)
	{
		arr[i] = (int*)malloc(sizeof(int)*width);
	}

	for(int i = 0;i < width;i++)
		for(int j = 0;j < width;j++)
		{
			int value = 0;
			cin>>value;
			arr[i][j] = value;
		}

	/***************begin******************/
	
	
	for(int i=0;i<width;i++)
    {
        sum+=arr[i][i];
    }
	cout<<sum<<endl;
	
	/****************end*******************/

	for (int i = 0; i < width; ++i)
	{
		free(arr[i]);
		arr[i] = NULL;
	}
	free(arr);
	arr = NULL;

	return sum;
}

```"
567,987,“绿盟杯”模拟赛第一阶段（C++）,wemokynf4icx,二维数组排序,2018,"```c
/*************************************************************************
    > File Name: dim_array.cpp
    > Author: ma6174
    > Mail: ma6174@163.com 
    > Created Time: Mon 21 May 2018 10:19:12 PM CST
 ************************************************************************/

#include<iostream>
#include <malloc.h>
#include<algorithm>
#include <string.h>

using namespace std;
struct kk
{
    int flag;
    int x;
}a[1000];
int cmp(struct kk b,struct kk c)
{
    return b.flag>c.flag;
}
int main (int argc, char *argv[])
{
	int width = 0;
	cin>>width;
	int **arr = (int **)malloc(sizeof(int*) * width);//二维数组
	for (int i = 0; i < width; ++i)
	{
		arr[i] = (int*)malloc(sizeof(int)*width);
	}

	for(int i = 0;i < width;i++)
		for(int j = 0;j < width;j++)
		{
			int value = 0;
			cin>>value;
			arr[i][j] = value;
		}

	/***************begin******************/
	
	
	int sum;
    for(int i=0;i<width;i++)
    {
        sum=0;
        for(int j=0;j<width;j++)
            sum+=arr[i][j];
        for(int j=0;j<width-1;j++)
        {
            for(int k=j+1;k<width;k++)
            {
                if(arr[i][j]<arr[i][k])
                {
                    int t=arr[i][j];
                    arr[i][j]=arr[i][k];
                    arr[i][k]=t;
                }
            }
        }
        a[i].flag=sum;
        a[i].x=i;
    }
    sort(a,a+width,cmp);
    for(int i=0;i<width;i++)
    {
        int r;
        cout<<""["";
        for(r=0;r<width-1;r++)
        {
            cout<<arr[a[i].x][r]<<"", "";
        }
        cout<<arr[a[i].x][r]<<""]""<<endl;
    }
	
	/****************end*******************/

	for (int i = 0; i < width; ++i)
	{
		free(arr[i]);
		arr[i] = NULL;
	}
	free(arr);
	arr = NULL;

	return 0;
}


```"
568,987,“绿盟杯”模拟赛第一阶段（C++）,zs85exhcbr79,二叉树最大深度计算,2019,"```c
/*************************************************************************
    > File Name: tree.cpp
    > Author: ma6174
    > Mail: ma6174@163.com 
    > Created Time: Tue 22 May 2018 11:59:21 PM CST
 ************************************************************************/

#include<iostream>
#include ""tree.h""

using namespace std;

int maxDepth(TreeNode *root)
{
	/*****************begin***************/
	
	
	if(root == NULL)
            return 0;
    int leftDepth = maxDepth(root->left);
    int rightDepth = maxDepth(root->right);
    return leftDepth > rightDepth ? (leftDepth + 1) : (rightDepth + 1);
	
	/******************end****************/
}


```"
569,1005,“绿盟杯”模拟赛第二阶段（C++）,xngqukjw8tir,"""绿盟杯""模拟赛第二阶段-集装箱运货问题",2027,"采用的是王飞龙同学的答案：
```c
#include <malloc.h>
#include <string.h>
#include ""algorithm.h""
using namespace std;

int done(int remains[]){
	int i,sum=0;
    for(i=0;i<GOODS_TYPE;i++)
        sum+=remains[i];
    if(sum==0)
        return 1;
    else
        return 0;
}
int loadable(int remains[]){
	int i;
	for(i=0;i<GOODS_TYPE;i++)
		if(remains[i]!=0)
			break;
	return i;
}
int put_goods(const box_info s_boxinfo,const goods_require s_greq, goods_require **result)
{
	/*************begin*************/

    int i,pos=-1;					//pos=i代表正在往第i+1个集装箱装物品
    int box_v,box_w;				//表示此集装箱剩余体积及重量
    int v[GOODS_TYPE]={2,2,4,8,16,16,16};			//各物品体积
    int w[GOODS_TYPE]={2,8,16,32,16,32,64};			//各物品重量
    int remains[GOODS_TYPE];		//表示剩余各物品的数量
    for(i=0;i<GOODS_TYPE;i++)
        remains[i]=s_greq.number[i];
    *result=(goods_require *)malloc(256*sizeof(goods_require));
    while(!done(remains)){		//只要没装完，就循环
        pos++;					//pos从0开始，意味正在装第pos+1个集装箱
        for(i=0;i<GOODS_TYPE;i++){								//初始化集装箱信息
        	(*result+pos)->type[i]=i;
            (*result+pos)->number[i]=0;
        }
        box_v=s_boxinfo.volume;									//初始化集装箱体积						
        box_w=s_boxinfo.weight;									//初始化集装箱重量
        while(box_v>=v[loadable(remains)]&&box_w>=w[loadable(remains)]){
            //此集装箱若还能装剩余的体积以及重量最小的物品，则接着装
        	for(i=GOODS_TYPE-1;i>=0;i--){						//每次装箱都从大物品开始扫描
            	if(box_v>=v[i]&&box_w>=w[i]&&remains[i]>0){		
                    //若装得下，且物品存在，则装
                	(*result+pos)->number[i]++;					//装箱
                    box_v-=v[i];								//更新集装箱剩余空间
                    box_w-=w[i];
                    remains[i]--;								//物品剩余数量-1
                }
            }
        }//内层while循环结束则表示已装完一个集装箱
      //  printf(""集装箱%d号已装箱成功"",pos+1);
    }//外层while循环结束则代表货物已全部装箱
	return pos+1;
	/**************end**************/
}

```"
570,1001,“绿盟杯”模拟赛第三阶段（C++）,rcqosx638b4n,红酒分类,2030,"```c
#include <iostream>
#include<fstream>
using namespace std;

// ########################数据说明####################
// 训练数据：src/step1/train.csv
// 测试数据：src/step1/test.csv
// 结果文件：src/step1/test_prediction.csv
//#####################################################

void userFunc()
{
/*********************** BEGIN **********************/
    
    string m;//无关变量，读取文件的第一行
    int id;
    char c;//无关变量，读取逗号
    double property[12];//测试所用的属性
    double w[12]={0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1};//权值
    double bias = 0.5;//阈值
    double g = 0.1;//学习因子
    int i=0,j;
    ifstream fin2(""src/step1/train.csv"");
    fin2>>m;
    double prop[3500][12];
    int type[3500];
    while(i<3500)
    {
        fin2>>id>>c;
        for(j=0;j<12;j++)
            fin2>>prop[i][j]>>c;
        fin2>>type[i];
        i++;
    }
    
    int cnt=50001;//训练次数50000次
    double x;
    int d;
    int y;
    int e;
    while(cnt--)
    {
        for(i=0;i<3500;i++)
        {
            x=0;
            for(j=0;j<12;j++)
                x+=w[j]*prop[i][j];
            x-=bias;
            if(x>0) y=1;
            else y=-1;
            if(type[i]==1) d=1;
            else d=-1;
            e=d-y;
            while(e!=0)
            {
                for(j=0;j<12;j++)
                    w[j] = w[j] + g*prop[i][j]*e;
                x=0;
                for(j=0;j<12;j++)
                    x+=w[j]*prop[i][j];
                x-=bias;
                if(x>0) y=1;
                else y=-1;
                e = d - y;
            }
        }
    }
    ifstream fin(""src/step1/test.csv"");
    fin>>m;
    ofstream fout(""src/step1/test_prediction.csv"");
    i=0;
    
    fout<<""id,type""<<endl;
    while(i<1500)
    {
        x=0;
        fin>>id>>c;
        for(j=0;j<12;j++)
        {
            fin>>property[j]>>c;
            x+=w[j]*property[j];
        }
        x-=bias;
        fout<<id<<"","";
        if(x>0) fout<<1<<endl;
        else fout<<0<<endl;
        i++;
    }

/*********************** END **********************/
}


```"
571,929,程序设计二（面向对象）_实训11_复杂类的实现_LinkedList类的实现,cn97ki4aj2yf,构造函数与析构函数的实现,,
572,929,程序设计二（面向对象）_实训11_复杂类的实现_LinkedList类的实现,9zky3p27fvxj,成员函数的实现,,
573,929,程序设计二（面向对象）_实训11_复杂类的实现_LinkedList类的实现,4g9zi8ab5p6u,运算符重载,,
574,929,程序设计二（面向对象）_实训11_复杂类的实现_LinkedList类的实现,mukrqgpyt58b,友元函数实现运算符重载,,
575,929,程序设计二（面向对象）_实训11_复杂类的实现_LinkedList类的实现,n5ctf6xoikvp,设计成员函数来实现非成员函数形式的运算符重载,,
576,926,数据结构-二叉树及其应用,joiur48fw7lk,实现二叉树的创建,1876,"```cpp

BiTreeNode* CreatBiTree(char* s, int &i, int len)
// 利用先序遍历创建二叉树
// 参数：先序遍历字符串s，字符串初始下标i=0，字符串长度len。
// 返回：二叉树
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    BiTreeNode* root;
    char item = s[i++];
    if(i>=len || item=='#')
    {
        root=NULL;
    }
    else
    {
        root = new BiTreeNode(item);
        root->left = CreatBiTree(s, i, len);
        root->right = CreatBiTree(s, i, len);
    }
    return root;
    
    /********** End **********/
}

void InOrder(BiTreeNode* root)
// 二叉树的中序遍历
// 参数：二叉树根节点root
// 输出：中间没有空格，末尾不换行。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if (root==NULL) {
        return;
    }
    InOrder(root->left);
    printf(""%c"", root->data);
    InOrder(root->right);
    
    /********** End **********/

}

```"
577,926,数据结构-二叉树及其应用,xvnmfcqs623z,计算二叉树的深度和节点个数,1877,"```cpp

int GetTreeDepth(BiTreeNode* root)
// 计算该二叉树的深度
// 参数：二叉树根节点root
// 返回：二叉树的深度
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if(root==NULL){
        return 0;
    }
    else{
        return 1+max(GetTreeDepth(root->left), GetTreeDepth(root->right));
    }

    /********** End **********/
}

int GetNodeNumber(BiTreeNode* root)
// 计算该二叉树的总节点个数
// 参数：二叉树根节点root
// 返回：二叉树的节点个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if(root==NULL){
        return 0;
    }
    else{
        return 1+GetNodeNumber(root->left)+GetNodeNumber(root->right);
    }
    
    /********** End **********/
}

int GetLeafNodeNumber(BiTreeNode* root)
// 计算该二叉树的叶子节点个数
// 参数：二叉树根节点root
// 返回：二叉树的叶子节点个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if(root==NULL){
        return 0;
    }
    else if(root->left==NULL && root->right==NULL){
        return 1;
    }
    else{
        return GetLeafNodeNumber(root->left)+GetLeafNodeNumber(root->right);
    }
    
    /********** End **********/
}


```"
578,926,数据结构-二叉树及其应用,hbkrcny4ox98,递归实现二叉树左右子树交换,1878,"```cpp

BiTreeNode* BiTreeChange(BiTreeNode* root)
// 实现二叉树左右子树的交换（递归法）
// 参数：二叉树根节点root
// 返回：二叉树
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if(root==NULL){
        return NULL;
    }
    else if(root->left!=NULL || root->right!=NULL){
        BiTreeNode* node_left = BiTreeChange(root->left);
        BiTreeNode* node_right = BiTreeChange(root->right);
        root->left = node_right;
        root->right = node_left;
    }
    return root;
    
    /********** End **********/
}


void PreOrder(BiTreeNode* root)
// 二叉树的前序遍历
// 参数：二叉树根节点root
// 输出：二叉树的前序遍历，中间没有空格，末尾不换行。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if (root==NULL) {
        return;
    }
    printf(""%c"", root->data);
    PreOrder(root->left);
    PreOrder(root->right);
    
    /********** End **********/
}

```"
579,926,数据结构-二叉树及其应用,4xwrhetly8uo,非递归实现二叉树左右子树交换,1879,"```cpp


BiTreeNode* BiTreeChangeStack(BiTreeNode* root)
// 实现二叉树左右子树的交换（栈实现）
// 参数：二叉树根节点root
// 返回：二叉树
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if (root==NULL) {
        return NULL;
    }
    stack<BiTreeNode*> S;
    S.push(root);
    while(!S.empty())
    {
        BiTreeNode* node_p = S.top();
        S.pop();
        
        BiTreeNode* tmp_p = node_p->left;
        node_p->left = node_p->right;
        node_p->right = tmp_p;
        
        if(node_p->left)
            S.push(node_p->left);
        if(node_p->right)
            S.push(node_p->right);
        
    }
    return root;
    
    /********** End **********/
}


void PostOrder(BiTreeNode* root)
// 二叉树的后序遍历
// 参数：二叉树根节点root
// 输出：二叉树的后序遍历，中间没有空格，末尾不换行。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if (root==NULL) {
        return;
    }
    PostOrder(root->left);
    PostOrder(root->right);
    printf(""%c"", root->data);
    
    /********** End **********/
}

```"
580,926,数据结构-二叉树及其应用,2ehxlfak3fwv,层次遍历二叉树,1880,"```cpp

void HierarchyOrder(BiTreeNode* root)
// 二叉树的层次遍历（队列实现）
// 参数：二叉树根节点root
// 输出：二叉树的中序遍历，中间没有空格，末尾不换行。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/

    queue<BiTreeNode*> que;
    que.push(root);
    while (!que.empty()) {
        BiTreeNode* node_p = que.front();
        que.pop();
        printf(""%c"", node_p->data);
        if(node_p->left){
            que.push(node_p->left);
        }
        if (node_p->right) {
            que.push(node_p->right);
        }
    }

    /********** End **********/
}

```"
581,909,C++之链表练习题,j24gtlqmhenf,链表的创建与遍历,1838,"```cpp
#include <iostream>
using namespace std;
struct student
{
	int number;
	char *name;
	float englishScore;
	float mathScore;
	student *nextStudent;
};
 	// 请在此添加你的代码
    /********** Begin ********/
//创建链表，参数分别对应学生数量，学生学号，学生名字，学生英语成绩，学生数学成绩 
student *createList(int stuCount,int *number, char **name,float englishScore[],float mathScore[]);
//找到成绩最好的学生并返回
student * findHighestScore(student *);
//找到成绩最差的学生并返回
student * findLowestScore(student *);

int main()
{
	student *head;
	student *stuh,*stul;
	int num;
	cin>>num;
	head = new student;
	int *number;
	float *englishScore, *mathScore;
	char **name;
	number = new int[num];
	name = new char*[num];
	englishScore = new float[num];
	mathScore = new float[num];

	for(int i = 0; i < num; i++)
	{
		name[i] = new char[30];
		cin>>number[i];
		cin>>name[i];
		cin>>englishScore[i];
		cin>>mathScore[i];
	}

	head = createList(num,number,name,englishScore,mathScore);
    stuh = findHighestScore(head);
    stul = findLowestScore(head);

    cout<<stuh->name<<"" ""<<stuh->number<<"" ""
    <<(stuh->englishScore + stuh->mathScore)/2<<endl;

    cout<<stul->name<<"" ""<<stul->number<<"" ""
    <<(stul->englishScore + stul->mathScore)/2<<endl;

	return 0;
}
student *createList(int stuCount,int *number, char **name,float englishScore[],float mathScore[])
{
	student *head, *p0, *p1;
	int i;
	head = p0 = p1 = new student;
	p0->name = *name;
	p0->number = *number;
	p0->mathScore = *mathScore;
	p0->englishScore = *englishScore;
	for (i=2;i<=stuCount;i++)
	{
		p0 = new student;
		p0->name = name[i-1];
		p0->number = number[i-1];
    	p0->mathScore = mathScore[i-1];
    	p0->englishScore = englishScore[i-1];
		p1->nextStudent = p0;
		p1 = p0;
	}
	p1->nextStudent = NULL;
	return head;
}
student * findHighestScore(student *head)
{
	student *p, *p0, *p1;
	p = head;
	p0 = p->nextStudent;
	p1 = p;
	while (p0!=NULL)
	{
		if ((p1->mathScore+p1->englishScore)<(p0->mathScore+p0->englishScore))
			p1 = p0;
		p0 = p0->nextStudent;
	}
	return (p1);
}
student * findLowestScore(student *head)
{
	student *p, *p0, *p1;
	p = head;
	p0 = p->nextStudent;
	p1 = p;
	while (p0!=NULL)
	{
		if ((p1->mathScore+p1->englishScore)>(p0->mathScore+p0->englishScore))
			p1 = p0;
		p0 = p0->nextStudent;
	}
	return (p1);
}
	/********** End **********/

```"
582,909,C++之链表练习题,ob7rcfxzwqn6,链表创建与排序,1839,"```cpp
#include <iostream>
using namespace std;

struct data
{
	int i;
	char c;
	data *next;
};
void px(data a[],int len);//利用排序函数
     // 请在此添加你的代码
    /********** Begin ********/
int main()
{
	data s[50];
	for(int m=0;m<100;m++)
	{
		cin>>s[m].i;
		if(s[m].i==-1)
		{
			break;
		}
		cin>>s[m].c;
	}
	int n=0;
	for(int k=0;s[k].i!=-1;k++)
	{
		n=n+1;
	}
	px(s,n);
	for(int j=0;j<n;j++)
	{
		cout<<'['<<s[j].i<<','<<s[j].c<<']';
		if(j==n-1)
		{
			break;
		}
      cout<<"";"";
	}
	return 0;
}
	/********** End **********/
void px(data s[],int len)//排序
{
	 // 请在此添加你的代码
    /********** Begin ********/
	for(int c=0;c<len-1;c++)
	{
		int min=c;
		for(int j=c+1;j<len;j++)
			if(s[j].i<s[min].i)
				min=j;
			data temp=s[c];
			s[c]=s[min];
			s[min]=temp;
	}
    /********** End **********/
}
```"
583,909,C++之链表练习题,vrlmic8oqa6z,链表的合并,1865,"```cpp
#include<iostream>
using namespace std;
struct  node
{
	int num;
	node *nextNode;
};
node *creatList(int,int*);
node *merage(node*,node*);
     // 请在此添加你的代码
    /********** Begin ********/
int main()
{
	node *head = new node;
	int n1,n2;
	cin>>n1;
	int *number1;
	number1 = new int[n1];
	for(int i = 0; i < n1; i++)
	{
		cin>>number1[i];
	}

	cin>>n2;
	int *number2 = new int[n2];

	for(int j = 0; j < n2; j++)
	{
		cin>>number2[j];
	}

	node *s1,*s2;
	s1 = creatList(n1,number1);	
	s2 = creatList(n2,number2);

	head = merage(s1,s2);
	node *tail = head;


	while(tail != NULL)
	{
		cout<<tail->num<<"" "";
		tail = tail->nextNode;
	}

    return 0;
}
node *creatList(int m,int*n)
{
	node *head,*p0,*p1;
	int i;
	p0=new node;
	head=p0;
	p1=p0;
	p0->num=n[0];
	for(i=1;i<m;i++)
	{
		p0= new node;
		p0->num=n[i];
		p1->nextNode=p0;
		p1=p0;
	}
	p1->nextNode=NULL;
	return head;
}
node *merage(node*m,node*n)
{
	int temp;
	node *k,*l,*head;
	head=new node;
	head=m;
	
	while (1)
	{
		if(m->nextNode!=NULL)
			m=m->nextNode;
		if(m->nextNode==NULL)
		{
			m->nextNode=n;
			break;
		}
	}
	k=head;
	l=head->nextNode;
	while((k->nextNode)->nextNode!=NULL)
	{
		l=k->nextNode;
		while(l->nextNode!=NULL)
		{
			if(k->num>l->num)
			{
				temp=k->num;
				k->num=l->num;
				l->num=temp;
			}
			l=l->nextNode;
		}
		k=k->nextNode;
	}
	return head;
}
    /********** End **********/
```"
584,909,C++之链表练习题,s6ifngqovbtr,链表的合成与排序,1866,"```cpp
#include <iostream>
using namespace std;

struct node
{
	int data;
	node *next; 
};

node *creatList();
void sortList(node *);
node *merage(node *, node *);
void displayList(node *);
void clearList(node *);
     // 请在此添加你的代码
    /********** Begin ********/
int main()
{
	node *head1 = creatList();
	node *head2 = creatList();
	sortList(head1);
	sortList(head2);
	node *newHead = merage(head1, head2);
	displayList(newHead);
	clearList(newHead); 
	return 0;
}

node *creatList()
{
	node *head = NULL;
	int num;
	cin >> num;
	while (num != -1)
	{
		node *tmp = new node;
		if (tmp == NULL)
		{
			return head;
		}
		tmp->data = num;
		tmp->next = head;
		head = tmp;
		cin >> num;
	}
	return head;
}
void sortList(node *head)
{
	if (head == NULL)
		return;
	node *tmp = head;
	while (tmp->next != NULL) 
	{
		node *min = tmp;
		node *tmp1 = tmp->next;
		while (tmp1 != NULL)
		{
			if (min->data > tmp1->data)
				min = tmp1;
			tmp1 = tmp1->next;
		}
		if (min != tmp)
		{
			int data = tmp->data;
			tmp->data = min->data;
			min->data = data;
		}
		tmp = tmp->next;
	}
}
node *merage(node *head1, node *head2)
{
	node *tmp1 = head1;
	node *tmp2 = head2;
	node *newHead = NULL;
	node *newTail = NULL;
	while (tmp1 != NULL || tmp2 != NULL)
	{
		if (tmp1 != NULL && (tmp2 == NULL || tmp1->data < tmp2->data))
		{
			if (newHead == NULL)
				newHead = tmp1;
			else
				newTail->next = tmp1;
			newTail = tmp1;
			tmp1 = tmp1 ->next;
		}
		else
		{
			if (newHead == NULL)
				newHead = tmp2;
			else
				newTail->next = tmp2;
			newTail = tmp2;
			tmp2 = tmp2 ->next;
		}
	}
	return newHead;
}
void displayList(node *head)
{
	node *tmp = head;
	while (tmp != NULL)
	{
		cout <<tmp->data<<"" "";
		tmp = tmp->next;
	}
}
void clearList(node *head)
{
	node *tmp = head;
	while (tmp != NULL)
	{
		head = head->next;
		delete tmp;
		tmp = head;
	}
}
    /********** End **********/
```"
585,909,C++之链表练习题,x8a9rwztb2ny,删除链表相同值元素,1867,"```cpp
#include<iostream>
using namespace std;
struct  node
{
	int num;
	node *nextNode;	
};
     // 请在此添加你的代码
    /********** Begin ********/
node *creatList(int count,int a[])
{
	int i;
	node *p1,*p0, *head;
	p1=p0=head=new node;
	p1->num=a[0];
	for(i=1; i<count; i++)
	{
		node *p0=new node;
		p0->num=a[i];
		p1->nextNode=p0;
		p1=p0;
	}
	p1->nextNode=NULL;
	return head;
}
node *deleteNode(node *head)
{
	node *p, *p0=new node;
	p=head;
	p0=head->nextNode;
	if(p0==NULL)
		return head;
	while(p->nextNode!=NULL)
	{
		
		if(p->num==p0->num)
		{
			if(p0->nextNode!=NULL)
			{
				p0=p0->nextNode;
				p->nextNode=p0;
			}
			else
				p->nextNode=NULL;
		}//删除相同的节点
	
		p=p0;
		if(p0->nextNode!=NULL)
			p0=p0->nextNode;
	}
	return head;
}
int main()
{
	int i,n;
	cin>>n;
	int *array = new int[n];
	for(i=0; i<n; i++)
	{
		cin>>array[i];
	}
	node *head = new node ;
	head = creatList(n,array);
	head = deleteNode(head);
	
	node *tail = head;
	while(tail!= NULL)
	{
		cout<<tail->num<<"" "";
		tail = tail->nextNode;
	}

    return 0;
}
    /********** End **********/
```"
586,922,C++之链表强化练习题,8fsz7niljchf,链表与递归,1868,"```cpp
#include<iostream>
using namespace std;
struct node{
	int num;
	node*next;
};
     // 请在此添加你的代码
    /********** Begin ********/
node *create(int n)
{
	node*head=NULL,*p1,*p2;
	head=p1=p2=new node;
	head->num=1;
	for(int i=2;i<=n;i++)
	{
		p1=new node;
		p1->num=i;
		p2->next=p1;
		p2=p1;
	}
	p2->next=NULL;
	return head;
}
node* revert(node*head)
{
	node*newhead;
	if(head==NULL||head->next==NULL)
	{
		cout<<head->num<<endl;
		return head;
	}
	else{
		newhead=revert(head->next);
		cout<<head->num<<endl;
		}
}
int main()
{
	int num;
	cin>>num;
	node*head=create(num),*p;
	p=revert(head);
	return 0;
}
    /********** End **********/
```"
587,922,C++之链表强化练习题,9w85zinqtuvg,单向链表翻转,1869,"```cpp
#include <iostream>
using namespace std;
     // 请在此添加你的代码
    /********** Begin ********/
void reverse(int m[], int len)
{       
	for (int i=0;i<len/2;i++)
	{
		int tmp = m[i];
		m[i] = m[len-1-i];
		m[len-1-i] = tmp;
	}
}
int main()
{
	int n;
	cin>>n;
	int x[100];
	for(int i=0;i<n;i++)
	{
		cin>>x[i];
		if(i>=n)
		{
			break;
		}
	}
	reverse(x, n);
	
	for(int k=0;k<n;k++)
		cout<<x[k]<<"" "";       
	return 0;
}
   /********** End **********/
```"
588,922,C++之链表强化练习题,sur6vh82439j,删除相同元素,1870,"```cpp
#include<iostream>
using namespace std;
struct Node 
{
	int num;
	Node *next;
};
     // 请在此添加你的代码
    /********** Begin ********/
Node * dubdel(Node *head)
{
	int a[1000], n = 0, i;
	Node *cur = head, 
		*pre = NULL;
	while (cur)
	{
		bool del = false;
		for (i=0;i<n;i++)
			if (a[i] == cur->num)
			{
				del = true;  
				break;
			}
			if (del)
			{
				pre->next = cur->next;
				delete cur;
				cur = pre->next;
			}
			else
			{
				a[n++] = cur->num;
				pre = cur;
				cur = cur->next;
			}
	}
	return head;
}

Node * listSort(Node *head)
{
	Node *tmp = head, *h = NULL;
	while (tmp)
	{
		head = tmp->next;
		Node *pre = NULL, *cur = h;
		while(cur && tmp->num > cur->num)
		{
			pre = cur;
			cur = cur->next;
		}
		if(pre == NULL)
		{
			tmp->next = h;
			h = tmp;
		}
		else
		{
			tmp->next = cur;
			pre->next = tmp;
		}
		tmp = head;
	}
	return h;
}
void deleteList(Node *head)
{
	Node *tmp;
	while (head)
	{
		tmp = head->next;
		delete head;
		head = tmp;
	}
}
void printList(Node *head)
{
	while(head)
	{
		cout<<head->num<<"" "";
		head = head->next;
	}
	cout<<endl;
}
Node * createList(int a[], int len)
{
	Node *head = NULL;
	if(len<1)
		return head;
	for(int i=0;i<len;i++)
	{
		Node *tmp = new Node;
		tmp->num = a[i];
		tmp->next = head;
		head = tmp;
	}
	return head;
}

int main()
{
	int n;
	int s[100];
	for(int i=0;;i++)
	{
		cin>>s[i];
		n=i;
		if(s[i]==0)
			break;
	}
	Node * head = createList(s,n);
	head = dubdel(head);
	head = listSort(head);
	printList(head);
	deleteList(head);
	return 0;
}

    /********** End **********/
```"
589,922,C++之链表强化练习题,ymxbnq9aevlt,双向链表,1871,"```cpp
#include<iostream>
using namespace std;
struct student
{
int num; 
struct student *next;
struct student *prior;
};
     // 请在此添加你的代码
    /********** Begin ********/
struct student * create(int n){
	int i;
	student *head=new student,*tail,*temp;
	head->num=1;
	head->prior=NULL;
	head->next=NULL;
	tail=head;
	temp=head;
	for(i=2;i<=n;i++)
	{
		temp=new student;
		temp->num=i;
		temp->prior=tail;
		temp->next=NULL;
		tail->next=temp;
		tail=temp;
	}
	head->prior=tail;
	tail->next=head;
	return head;
}
void find(student * head,int *num){
	student *look=head,*temp;
	int n=0,m=0;
	while(look!=look->next)
	{
		m++;
		if(m%3==0)
		{
			n++;
			num[n]=look->num;
 			(look->prior)->next=look->next;
			(look->next)->prior=look->prior;
			temp=look;
			look=look->next;
			delete temp;
		}
		else look=look->next;
	}
	num[n+1]=look->num;
}

int main(){
	int count;
	cin>>count;
	int *num = new int[100];
	struct student * p=create(count);	
	find(p,num);
	for(int i = 1; i < count - 1; i++)
	{
		cout<<num[i]<<"" "";
	}
	cout<<num[count-1];
	cout<<endl;
	cout<<num[count];
	return 0;
}
   /********** End **********/
```"
590,922,C++之链表强化练习题,vfun8f4rl6os,链表实现报数游戏,1872,"```cpp
#include<iostream>
using namespace std;
struct node
{
	int num;
	node * next;
};
     // 请在此添加你的代码
    /********** Begin ********/
int main()
{
	int i,length;
	int M,N;
	cin>>M;
	node * tmp=NULL;
	node * head=NULL;
	node * tail=NULL;
	tmp=new node;
	tmp->next=NULL;
	head=tmp;
	tail=tmp;
	head->num=1;
	for (i=2;i<=M;i++)
	{
		tmp=new node;
		tmp->next=NULL;
		tail->next=tmp;
		tail=tmp;
		tail->num=i;
	}
	tail->next=head;
	tmp=head;
	cin>>N;
	length=M;
	i=1;
	while (length>0)
	
	{
	
		if (i==N)
		{
			length--;
			i=1;
			tail->next=tmp->next;
			cout<<tmp->num<<"" "";
			delete []tmp;
			tmp=tail->next;
		}
		i++;
		tmp=tmp->next;
		tail=tail->next;

	}
	return 0;
}
    /********** End **********/
```"
591,908,程序设计二（面向对象）_实训10_复杂类的实现_ArrayList类的实现,fcfkiyo6qw4j,构造函数与析构函数的实现,,
592,908,程序设计二（面向对象）_实训10_复杂类的实现_ArrayList类的实现,cr3en6hikqvf,成员函数的实现,,
593,908,程序设计二（面向对象）_实训10_复杂类的实现_ArrayList类的实现,nfsxgflkmzba,异常检测,,
594,908,程序设计二（面向对象）_实训10_复杂类的实现_ArrayList类的实现,g37wk6ohc9p2,运算符重载和完整的ArrayList类,1857,"ArrayList.cpp内容如下，仅供参考。
```cpp
#include ""ArrayList.h""

ArrayList::ArrayList():data(nullptr),size(0),capacity(0){
    capacity = 1;
    data = new int [capacity];
}

ArrayList::ArrayList(const ArrayList&rhs):data(nullptr),size(0),capacity(0){
    size = rhs.size;
    capacity = rhs.capacity;
    data = new int [capacity];

    for(int i=0;i<size;++i){
        data[i] = rhs.data[i];
    }
}

ArrayList::ArrayList(int const a[],int n):data(nullptr),size(0),capacity(0){
    size = n;
    capacity = n;
    data = new int [capacity];

    for(int i=0;i<size;++i){
        data[i] = a[i];
    }
}

ArrayList::ArrayList(int n,int value):data(nullptr),size(0),capacity(0){
    size = n;
    capacity = n;
    data = new int [capacity];

    for(int i=0;i<size;++i){
        data[i] = value;
    }
}

ArrayList::~ArrayList(){
    delete [] data;
}

void ArrayList::setCapacity(int newCapa){
    if ( newCapa <= capacity ) return;

    int* pt = new int [capacity=newCapa];
    for(int i=0;i<size;++i){
        pt[i] = data[i];
    }
    delete [] data;
    data = pt;
}

void ArrayList::insert(int pos,int value){
    if ( size == capacity ){
        setCapacity(capacity+capacity);
    }

    for(int i=size-1;i>=pos;--i){
        data[i+1] = data[i];
    }
    data[pos] = value;
    ++size;
}

void ArrayList::remove(int pos){
    for(int i=pos;i<size-1;++i){
        data[i] = data[i+1];
    }
    --size;
}

int ArrayList::at(int pos)const{
    return (*this)[pos];
}

void ArrayList::modify(int pos,int newValue){
    (*this)[pos] = newValue;
}

ArrayList& ArrayList::operator = (const ArrayList&rhs){
    if ( &rhs != this ){
        if ( capacity < rhs.size ){
            setCapacity(rhs.size);
        }

        size = rhs.size;
        for(int i=0;i<size;++i){
            data[i] = rhs.data[i];
        }
    }
    return *this;
}

ArrayList& ArrayList::operator += (const ArrayList&rhs){
    if ( capacity < size + rhs.size ){
        setCapacity(size+rhs.size);
    }

    for(int i=0;i<rhs.size;++i){
        data[i+size] = rhs.data[i];
    }
    size += rhs.size;
    return *this;
}

const int& ArrayList::operator [] (int pos)const{
    return static_cast<const int&>((*const_cast<ArrayList*>(this))[pos]);
}

int& ArrayList::operator [] (int pos){
    return data[pos];
}

```

ArrayListOp.cpp内容如下，仅供参考。
```cpp
#include ""ArrayListOp.h""

const ArrayList operator + (const ArrayList&lhs,const ArrayList&rhs){
    ArrayList ret(lhs);
    return ret += rhs;
}

bool operator == (const ArrayList&lhs,const ArrayList&rhs){
    if ( lhs.getSize() != rhs.getSize() ) return false;

    for(int i=0,n=lhs.getSize();i<n;++i){
        if ( lhs[i] != rhs[i] ) return false;
    }
    return true;
}

bool operator < (const ArrayList&lhs,const ArrayList&rhs){
    int n = lhs.getSize() < rhs.getSize() ? lhs.getSize() : rhs.getSize();

    for(int i=0;i<n;++i){
        if ( lhs[i] < rhs[i] ) return true;
        else if ( rhs[i] < lhs[i] ) return false;
    }
    return lhs.getSize() < rhs.getSize();
}

bool operator != (const ArrayList&lhs,const ArrayList&rhs){
    return ! ( lhs == rhs );
}

bool operator <= (const ArrayList&lhs,const ArrayList&rhs){
    return lhs < rhs || lhs == rhs;
}

bool operator > (const ArrayList&lhs,const ArrayList&rhs){
    return ! ( lhs <= rhs );
}

bool operator >= (const ArrayList&lhs,const ArrayList&rhs){
    return ! ( lhs < rhs );
}

ostream& operator << (ostream&os,const ArrayList&rhs){
    for(int i=0,n=rhs.getSize();i<n;++i){
        os<<rhs[i]<<"" "";
    }
    return os;
}

```"
595,798,c++语言之判断练习题,j7f3ebsyc4mt,阿尔法乘积,1573,"```cpp
#include <iostream>
using namespace std;
int main()
{
	/*********begin*********/
	unsigned int x;
	cin >> x;
	int h;
	while (x > 9)
	{
		int w = 1;
		while (x > 0)
		{
			h = x % 10;
			x = x / 10;
			if (h > 0)
			{
				w = w * h;
			}			
		}
		x = w;
	}
	cout<<x<<endl;
	return 0;
	/*********end**********/
}
```"
596,798,c++语言之判断练习题,s3c79jta2wyf,前n个质数之和,1574,"```cpp
#include <iostream>
#include <cmath>
using namespace std;
/*********begin*********/
bool IsPrime(int id)
{
  for (int i = 2; i < id; i++)
  {
    if (id % i == 0)
      return false;
  }
  return true;
}
/*********end*********/
int main()
{
  /*********begin*********/
  int N;
  cin >> N;
  int sum = 0;
  int count = 0;
  int id = 2;
  while (count < N)
  {
    if (IsPrime(id))
    {
      sum += id;
      count++;
    }
    id++;
  }
  cout << sum << endl;
  return 0;
  /*********end*********/
}


```"
597,798,c++语言之判断练习题,byu7g2afin3r,找素数,1575,"```cpp
#include <iostream>
using namespace std;

int main()
{
	/*********begin*********/
	int n,a;
	cin>>n;
	a=n+1;
  	if(n<0)
		cout<<0;
	else
    {
		for(int i=2;i<=n-1;i++)
			if(a%i==0)
			a=a+1;
			cout<<a;
	}
    return 0;
	/*********end*********/
}
```"
598,798,c++语言之判断练习题,2fbgslr6o8fc,求因子,1576,"```cpp
#include<iostream>
using namespace std;
int main()
{
	/*********begin*********/
	int a,i;
	cin>>a;
	for(i=1;i<=a;i++)
	{
		if(a%i==0)
		{
			cout<<i<<endl;
		}
	}
	return 0;
	/*********end*********/
}

```"
599,848,c++语言之数学运算练习题（二）,y59feaozhbnm,求商,1702,"```cpp
#include <iostream>
using namespace std;
int main()
{
	/*********begin*********/
   int dividend,divisor,quotient;
   cin>>dividend, cin>>divisor;
   if(divisor==0)
     cout<<""Error:the divisor cannot be 0.""<<endl;
   else
   {
     quotient=dividend/divisor;
     cout<<""Quotient is ""<<quotient<<endl;
   }
   return 0;
	/*********end*********/
}
```"
600,848,c++语言之数学运算练习题（二）,moz5le8fqv7x,坐标与象限,1703,"```cpp
#include <iostream>
using namespace std;

int main()
{
	/*********begin*********/
    double x,y;
	cin>>x>>y;
	if(x>0 && y>0)
	cout<<""1""<<endl;
	else if(x>0 && y<0)
	cout<<""4""<<endl;
    else if(x<0 && y>0)
	cout<<""2""<<endl;
	else if(x<0 && y<0)
	cout<<""3""<<endl;
	else if(x==0 && y!=0)
	cout<<""y""<<endl;
	else if(x!=0 && y==0)
	cout<<""x""<<endl;
	else if(x==0 && y==0)
	cout<<""0""<<endl;
    return 0;
	/*********end********/
}
```"
601,848,c++语言之数学运算练习题（二）,q5tifj8yma37,完全平方数,1704,"```cpp
#include <iostream>
using namespace std;

int main()
{
	/*********begin*********/
   int m,n,i;
	cin>>m;
	n=1;
	i=1;
    if(m==0)
      cout<<""1"";
   else
	while (i<=m)
	{
		if (n==m)
		{
			cout<<(""1"");
			break;
		}
		n=i*i;
		i++;
        if (i==m)
			cout<<(""0"");
	}
	return 0;
	/*********end*********/
}

```"
602,848,c++语言之数学运算练习题（二）,p8yijv6b53zf,弹球的高度计算,1705,"```cpp
#include <iostream>
using namespace std;

int main()
{
	/*********begin*********/
	float s = 100, l = 50;
	int n, i;
	cin >> n;
	for (i = 1;i < n;i++)
	{
		s = s + l * 2;
		l = l / 2;
	}
	cout << s << "" "" << l;
	return 0;
	/*********end*********/
}
```"
603,900,C++之结构体练习题,a2v5k8f9xnif,复数类型的结构体变量,1821,"```cpp
#include<iostream>
using namespace std;
     // 请在此添加你的代码
    /********** Begin ********/
struct fs{
	int a;
	int b;
};
fs sub(int a1,int b1,int a2,int b2){
	fs c3;
	c3.a=a1-a2;
	c3.b=b1-b2;
	return c3;
}
fs mul(int a1,int b1,int a2,int b2){
	fs c4;
	c4.a=a1*a2-b1*b2;
	c4.b=a1*b2+a2*b1;
	return c4;
}
int main(){
	fs c1,c2,c3,c4;
	cin >>c1.a>>c1.b;
	cin >>c2.a>>c2.b;
	c3=sub(c1.a,c1.b,c2.a,c2.b);
	c4=mul(c1.a,c1.b,c2.a,c2.b);
	cout <<""c3 is (""<<c3.a<<"")+(""<<c3.b<<"")i""<<endl;
	cout <<""c4 is (""<<c4.a<<"")+(""<<c4.b<<"")i""<<endl;
	return 0;
}
    /********** End **********/
```"
604,900,C++之结构体练习题,ire2f4b6g7ou,比较举重运动员成绩,1815,"```cpp
#include <iostream>
using namespace std;
#define N 20

int main()
{
     // 请在此添加你的代码
    /********** Begin ********/
    struct Lifting
	{
		char name[N];
		float g;
		int z;
		int t;
		int sum;
	}y1,y2;
	cin>>y1.name;
	cin>>y1.g;
	cin>>y1.z>>y1.t;
	y1.sum=y1.z+y1.t;
	cin>>y2.name>>y2.g>>y2.z>>y2.t;
	y2.sum=y2.z+y2.t;
	if(y1.sum>y2.sum)
		cout<<y1.name<<endl;
	else if(y1.sum==y2.sum)
	{
		if(y1.g>y2.g)
			cout<<y2.name<<endl;
		else
			cout<<y1.name<<endl;
	}
	else if(y1.sum<y2.sum)
		cout<<y2.name<<endl;//获取参数方式 cin
    return 0;
    /********** End **********/
}
```"
605,900,C++之结构体练习题,hsifgrbn4paq,比较10名举重运动员成绩,1816,"```cpp
#include <iostream>
using namespace std;
#define N 10
     // 请在此添加你的代码
    /********** Begin ********/
struct Lifting{
	char name[N];
	double weight;
	int zscore;
	int tscore;
	int sumscore;
	};
void sort(Lifting []);
void shuchu(Lifting []);
int main()
{
	
	Lifting num[N]={
	{""子轩"",75.00,174,207},
	{""子涵"",75.18,170,205},
	{""宇轩"", 70.01,173,207},
	{""浩然"",72.54,168,209},
	{""浩宇"", 73.99,170,200},
	{""皓轩"", 70.02,173,207},
	{""雨泽"", 73.77,176,199},
	{""博文"", 72.89,178,202},
	{""俊杰"", 74.56,180,210},
    {""子睿"", 75.50,177,208}};
	for (int l=0;l<N;l++)
	{
		num[l].sumscore=num[l].zscore+num[l].tscore;
	}
	sort(num);
	shuchu(num);

			return 0;
			
}
void sort(Lifting num[N])
{
	for (int i=0;i<N;i++)
	{
		int m=i;
		for (int k=i;k<N;k++)
		{ if(num[m].sumscore<num[k].sumscore)
		m=k;
		else if(num[m].sumscore==num[k].sumscore)
			if(num[m].weight>num[k].weight)
				m=k;
		}
		Lifting temp=num[i];
		num[i]=num[m];
		num[m]=temp;
	}
}
void shuchu(Lifting num[N])
{
	for (int p=0;p<N;p++)
	{
		cout<<p+1<<' '<<num[p].name<<' '<<num[p].sumscore<<endl;
	}
}
    /********** End **********/
```"
606,900,C++之结构体练习题,p47zhljf23ov,记录书籍的结构,1822,"```cpp
#include <iostream>
#include<cstring>
using namespace std; 
     // 请在此添加你的代码
    /********** Begin ********/
struct book
{ 
int Number; 
char Name[10];
char Author[10];
char Press[10]; 
int PublicationDate;
book *next; 
}a[100];
int main()
{
int i;
  for( i=0;i<=99;i++)
  {
    cin>>a[i].Number;
    if(a[i].Number==0)
      break;
    else
      cin>>a[i].Name>>a[i].Author>>a[i].Press>>a[i].PublicationDate;
  }
  char au[10];
  for( i=0;i<=99;i++)
  {
    cin>>au;
    if (strcmp(au,a[i].Author)==0)
    {
      cout<<""Number:""<<a[i].Number<<endl;
      cout<<""Name:""<<a[i].Name<<endl;
      cout<<""Author:""<<a[i].Author<<endl;
       cout<<""Press:""<<a[i].Press<<endl;
       cout<<""Publication Date:""<<a[i].PublicationDate<<endl;
    }
  }
  return 0;
}
    /********** End **********/
```"
607,900,C++之结构体练习题,fqk2y3v9lcug,排列输出,1823,"```cpp
#include <iostream>
using namespace std;
     // 请在此添加你的代码
    /********** Begin ********/
struct data{
  int i;
  char c;
};

int main()
{
  int n;
  cin>>n;
  data s[100];
  for(int k=0;k<n;k++){
    cin>>s[k].i;
    cin>>s[k].c;
  }
  for(int a=0;a<n-1;a++){
    for(int f=a+1;f<n;f++){
      if(s[a].i<s[f].i){
        int as=s[a].i;
        char bs=s[a].c;
        s[a].i=s[f].i;
        s[f].i=as;
        s[a].c=s[f].c;
        s[f].c=bs;
      }
    }
  }
  for(int e=0;e<n-1;e++){
    cout<<'['<<s[e].i<<','<<s[e].c<<']'<<';';
  }
  cout<<'['<<s[n-1].i<<','<<s[n-1].c<<']'<<endl;
    return 0;
}

    /********** End **********/
```"
608,897,C++之基础语法进阶练习题,l2khforpinzv,相同数字不同位数之和 ,1804,"```cpp
#include<iostream> 
using namespace std;
int main(){
     // 请在此添加你的代码
    /********** Begin ********/
	int a,b,c,n,i;
	cin>>a>>n;
	b=0,c=0;
	for(i=n;i>=1;i--){
		b=b*10+a;
		c+=b;
	}
	cout<<c;
    /********** End **********/
}
```"
609,897,C++之基础语法进阶练习题,ojztupsnviy4,求平均值,1805,"```cpp
#include<iostream>
using namespace std;

int main()
{
	 // 请在此添加你的代码
    /********** Begin ********/
	int n;
	int data[100];
	cin>>n;
	for(int i =  0;i < n;i++)
		cin>>data[i];
	 int sum = 0;
	 for(int i =  0;i < n;i++)
		 sum += data[i];
	 double ave = (double)sum / n;
	 cout<<ave;
	
	return 0;
	/********** End **********/
}
```"
610,897,C++之基础语法进阶练习题,ycmf5p2ijvbk,生成ISBN13编码,1807,"```cpp
#include <iostream>
using namespace std;

int main()
{
 	// 请在此添加你的代码
    /********** Begin ********/
  int a,b,c,d,e,f,g,h,i,j,k,l,s,m,n;
   cin>>a>>b>>c>>d>>e>>f>>g>>h>>i>>j>>k>>l;
   s=a*1+b*3+c*1+d*3+e*1+f*3+g*1+h*3+i*1+j*3+k*1+l*3;  
   m=s %10;
   n=10-m;
   if(n==10)
        cout<<a<<b<<c<<d<<e<<f<<g<<h<<i<<j<<k<<l<<'0';
   else cout<<a<<b<<c<<d<<e<<f<<g<<h<<i<<j<<k<<l<<n;
     return 0;
	/********** End **********/
}


```"
611,897,C++之基础语法进阶练习题,feb24apqmhfc,ISBN13和ISBN10的转换,7956,"```cpp
#include<iostream>
using namespace std;
int main()
{
     // 请在此添加你的代码
    /********** Begin ********/
    int a,b,c,d,e,f,g,h,i,j,k,l,m,S,N,M;
    cin>>a>>b>>c>>d>>e>>f>>g>>h>>i>>j>>k>>l>>m;
    int checksum = 10 - (a*1+b*3+c*1+d*3+e*1+f*3+g*1+h*3+i*1+j*3+k*1+l*3)%10;
    if(checksum == m)
    {
        int finnal_bit = 11-(10*d+9*e+8*f+7*g+6*h+5*i+4*j+3*k+2*l)%11;
        if(finnal_bit == 10)
            cout<<d<<e<<f<<g<<h<<i<<j<<k<<l<<'x';
        else if(finnal_bit == 11)
            cout<<d<<e<<f<<g<<h<<i<<j<<k<<l<<0;
        else
            cout<<d<<e<<f<<g<<h<<i<<j<<k<<l<<finnal_bit;
    }
    else
    {
        cout<<""Error"";
    }
    return 0;
    
    /********** End **********/
}
```"
612,880,C++之基础语法入门练习题,vqb7ehj5tflu,银行存款计算 ,1753,"```cpp
#include <stdio.h>
#include <iostream>
using namespace std;
int main ()
{
     // 请在此添加你的代码
    /********** Begin ********/
	 double a = 100000 ;
	int n,i;
	scanf (""%d"",&n);
	for (i = 1;i<=n;i++)
		a = a*(1+0.0375);
	printf (""%.2f"",a);
  return 0;
    /********** End **********/
}
```"
613,880,C++之基础语法入门练习题,826f43xtqsgv,选取最大的,1754,"```cpp
#include <iostream>
using namespace std;
int main()
{
     // 请在此添加你的代码
    /********** Begin ********/
	int a,b;
	cin>>a>>b;
	if(a>=b)
    	cout<<a;
    else
    	cout<<b;
    return 0;
    /********** End **********/
}
```"
614,880,C++之基础语法入门练习题,c32oltxvfn46,水分子总数,1755,"```cpp
#include <iostream>
using namespace std;
int main()
{
     // 请在此添加你的代码
    /********** Begin ********/
    double moleculeWeight = 3e-23;
    double quartWeight = 950;
    double n;
    cin >> n;
    double total = n * quartWeight / moleculeWeight; 
    cout << total ;
    return 0;
    /********** End **********/
}
```"
615,880,C++之基础语法入门练习题,aqzh6l3exnrv,取整近似数,1756,"```cpp
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
 	// 请在此添加你的代码
    /********** Begin ********/
	int places;
    double a;
    cin >> a;
    for(places=3;places<=7;places++)
    cout<<setprecision(places)<<a<<endl;
    return 0;
	/********** End **********/
}
```"
616,876,C++之函数进阶练习题,fnxzcmovw4f3,计算成绩,1740,"```cpp
#include<iostream>
using namespace std;
void check(int x[],int N);
int main()
{
 	// 请在此添加你的代码
    /********** Begin ********/
	int a[5]={65,79,98,87,83};
    for(int i=1;i<=5;i++)
    check(a,5);
	return 0;
	/********** End **********/
}
void check(int x[],int N)
{
	// 请在此添加你的代码
    /********** Begin ********/
    int m;
    cin>>m;
    if(m>=1&&m<=5)
    cout<<x[m-1]<<endl;
	/********** End **********/    
}

```"
617,876,C++之函数进阶练习题,jl73oxbf6cia,买衣服要花多少钱呢,1735,"```cpp
#include <iostream>
using namespace std;

int Payfor(int clothes,int pants)
{
     // 请在此添加你的代码
    /********** Begin ********/
	if(clothes >= pants)
	{
		if(pants >= 50)
		{
			return pants * 80 + (clothes - pants) * 60;
		}
		else
			return pants * 90 + (clothes - pants) * 60;
	}

	if(clothes < pants)
	{
		if(clothes >= 50)
		{
			return clothes * 80 + (pants - clothes) * 45;
		}
		else
			return clothes * 90 + (pants - clothes) * 45;
	}	
    /********** End **********/
}
int main()
{
	int clothes, pants;
	cin >> clothes >> pants;
	int n = Payfor(clothes,pants);
	cout << n << endl;
	return 0;
}

```"
618,876,C++之函数进阶练习题,8pfxl95ng2f4,求余数,1736,"```cpp
#include <iostream>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin ********/
int main()
{
    int a,  b;
	int n1, m1;
	cin >> a >> b;
	double m, n;
	cin >> m >> n;
	int p = a % b;
	m1 =(m >= 0 ? int (m +0.5) :int ( m - 0.5));
	n1 =(n >= 0 ? int (n + 0.5): int (n - 0.5));
	int q =(int) m1 % n1;
	cout << p << endl;
	cout << q << endl;  
    return 0;
}
	/********** End **********/
```"
619,876,C++之函数进阶练习题,ot9f638up2iq,计算x的n次幂,1739,"```cpp
#include<iostream>
using namespace std;
float power(float X,int N);
int main()
{
 	// 请在此添加你的代码
    /********** Begin ********/
	float x=0;
	int n=0;
	cin>>x>>n;
	cout<<power(x,n)<<endl;
	return 0;
	/********** End **********/
}
float power(float X,int N)
{
 	// 请在此添加你的代码
    /********** Begin ********/
	if(N==0)
		return 1;
	else if(N==1)
		return X;
	else
		return X*power(X,N-1);
	/********** End **********/
}
```"
620,876,C++之函数进阶练习题,vt43rhbgen8p,加密函数,1737,"```cpp
#include<iostream>
using namespace std;
void encrypt(char info[]);

int main()
{
     // 请在此添加你的代码
    /********** Begin ********/
	char s[2025];
	cin >> s;
	encrypt(s);
    cout << s << endl;
	return 0;
    /********** End **********/
}

void encrypt(char info[])
{
     // 请在此添加你的代码
    /********** Begin ********/
	int i;
	for (i = 0; info[i] != '\0'; i++)
    {
        if (info[i] - 'a' >= 0 && info[i] - 'z' <= 0)
            info[i] = 'a' + ((info[i] + 4) - 'a') % 26;
		else
		if (info[i] - 'A' >= 0 && info[i] - 'Z' <= 0)
			 info[i] = 'A' + ((info[i] + 4) - 'A') % 26;
    }
	/********** End **********/
}
```"
621,877,C++之函数强化练习题,gzj3nfco9lim,结构实现复数运算,1747,"```cpp
#include <iostream>
using namespace std;

struct pluar{
    double in, ou;
};

pluar sub(pluar, pluar);
pluar mul(pluar, pluar);

int main(){
	// 请在此添加你的代码
    /********** Begin ********/
    double a, b, c, d;
    cin>>a>>b>>c>>d;
    pluar c1 = {a, b};
    pluar c2 = {c, d};
    pluar c3,c4;
    c3 = sub(c1, c2);
    c4 = mul(c1, c2);
    cout<<c3.in<<"" ""<<c3.ou<<"" ""<<c4.in<<"" ""<<c4.ou;
    return 0;
    /********** End **********/
}

//减法
pluar sub(pluar a, pluar b){
	// 请在此添加你的代码
    /********** Begin ********/
    pluar tmp;
    tmp.in = a.in - b.in;
    tmp.ou = a.ou - b.ou;
    return tmp;
    /********** End **********/
}

//乘法
pluar mul(pluar a, pluar b){
     // 请在此添加你的代码
    /********** Begin ********/
    pluar tmp;
    tmp.in = a.in * b.in - a.ou * b.ou;
    tmp.ou = a.in * b.ou + a.ou * b.in;
    return tmp;
	/********** End **********/
}
```"
622,877,C++之函数强化练习题,raicyfh2n345,求亲密对数,1742,"```cpp
#include <iostream>
#include <math.h>
using namespace std;
int logarithm(int);

int main()
{
     // 请在此添加你的代码
    /********** Begin ********/
	int n, k=0;
	cin>>n;
	for(int a=200; a<=18000; a++)
	{
		int b = logarithm(a);
		if(logarithm(b)==a && a<b)
		{
			k++;
			if(k == n)
				cout<<a<<"" ""<<b;
		}
	}
	return 0;
    /********** End **********/
}

int logarithm(int x)
{
     // 请在此添加你的代码
    /********** Begin ********/
	int sum=0;
	for(int i=1; i<=sqrt(x); i++)
	{
		if(x%i == 0)
		{
			int k = x/i;
			sum += i+k;
			if(k == i || k == x)
			sum -= k;
		}
	}
	return sum;
	/********** End **********/
} 
```"
623,877,C++之函数强化练习题,xyzfi3hjbk2f,计算一年的第几天,1744,"```cpp
#include <iostream>
using namespace std;

struct date //定义结构变量
{
	int year;
	int month;
	int day;
}dat;
int luner(int n) //判断是否是闰年
{
	if (n%4==0)
    {
      if (n%100 ==0 && n%400!=0)
        return 28;
      else
        return 29;
    }
	else return 28;
}

int main()
{
	 // 请在此添加你的代码
    /********** Begin ********/
	int i,sum=0,year,month,day;
	cin >>year>>month>>day;
	date dat={year,month,day};
	//判断是否是非法输入
	if (dat.year<=0 || dat.month>12 || dat.month<1 )
	{
		cout<<0;
		return 0;
	}
	else if (dat.month==2)//判断二月是否非法输入
	{
		if (dat.day>luner(dat.year) ||dat.day<1)
		{
			cout<<0;
			return 0;
		}
	}
	else if(dat.month ==4 ||dat.month ==6 ||dat.month ==9 ||dat.month ==11)
	{
		if(dat.day>30 ||dat.day <1)
		{
			cout<<0;
			return 0;
		}
	}
	else if (dat.day >31 ||dat.day <1)
	{
		cout <<0;
		return 0;
	}
	//正确输入后开始计算
	for (i=1;i<dat.month;i++)
		{
			if (i == 2)
			sum+=luner(dat.year);
			else
				if(i==4 || i==6 || i == 9 || i==11)
					sum+=30;
				else
                    sum+=31;
		}
	sum+=dat.day;
	cout<< sum;

    return 0;
	/********** End **********/
}

```"
624,877,C++之函数强化练习题,lrmvsgcfjn38,正整数求和,1748,"```cpp
#include<iostream>
using namespace std;
void fun1(char a1[],char a2[]);
void fun2(char b1 [],char b2[]);
void jinweiqiuhe(char a2[],char b2[],char c[]);
void fuzhi(char c[],char d[]);
int main()
{
	// 请在此添加你的代码
    /********** Begin ********/
#define n 101
	char a1[n]={0},a2[n]={0},b1[n]={0},b2[n]={0},c[n]={0},d[n]={0};
  cin>>a1;
  cin>>b1;
  fun1( a1, a2);
  fun2( b1, b2);
  jinweiqiuhe( a2, b2, c);
  fuzhi(c,d);;
  cout<<d;
	return 0;
    /********** End **********/
}

void fun1(char a1[],char a2[])
{
     // 请在此添加你的代码
    /********** Begin ********/
	int i,j;
	for(i=0;a1[i]!=0;i++);  
	for(j=0;j<i;j++)
		a2[n-i+j]=a1[j]-'0';
    /********** End **********/
}
void fun2(char b1 [],char b2[])	
{
     // 请在此添加你的代码
    /********** Begin ********/
	int i,j;
	for(i=0;b1[i]!=0;i++);
	for(j=0;j<i;j++)
		b2[n-i+j]=b1[j]-'0';
    /********** End **********/
}
void jinweiqiuhe(char a2[],char b2[],char c[])
{
     // 请在此添加你的代码
    /********** Begin ********/
	int i,j;
		for(i=n-1,j=0;i>-1;i--)
	{
		c[i]=(a2[i]+b2[i]+j)%10+'0';
		j=(a2[i]+b2[i]+j)/10;
	}
    /********** End **********/
}
void fuzhi(char c[],char d[])
{
     // 请在此添加你的代码
    /********** Begin ********/
	int i,j;
	for(i=0;c[i]=='0';i++);
	for(j=0;j<n-i;j++)
		d[j]=c[i+j];
    /********** End **********/
}
```"
625,877,C++之函数强化练习题,69xanj25r4mh,Pig Latin,1746,"```cpp
#include<iostream>
#include<stdio.h>
using namespace std;
inline int qchar(char c){
     // 请在此添加你的代码
    /********** Begin ********/
	if(c>='A'&&c<='Z')c=c+'a'-'A';
	if((c=='a')||(c=='e')||(c=='u')||(c=='i')||(c=='o'))return 1;
	if(c>='a'&&c<='z')return 2;
	if(c=='\n'||c==EOF)return 0;
	return 3;
	/********** End **********/
}
int main(){
     // 请在此添加你的代码
    /********** Begin ********/
	char c[1000],t;
	int i,m;
	//for(m=0;m<50;m++){
	while(1){
		t=getchar();
		//if(t==EOF)break;
		if(!qchar(t))break;
		if(qchar(t)==3){putchar(t);continue;}
		if(qchar(t)==1){
			while((qchar(t)==1)||(qchar(t)==2)){
				putchar(t);
				t=getchar();
			}
			//cin>>c;
			//cout<<t<<c<<""way"";
			cout<<""way"";
			if(!qchar(t))break;
			cout<<t;
			continue;
		}
		for(i=0;qchar(t)==2;i++){
			c[i]=t;
			t=getchar();
		}
		c[i]='\0';
		while((qchar(t)==1)||(qchar(t)==2)){
			putchar(t);
			t=getchar();
		}
		cout<<c<<""ay"";
		if(!qchar(t))break;
		cout<<t;
	}
	return 0;
    /********** End **********/
}

```"
626,877,C++之函数强化练习题,hbqas8j5ek2t,打印日历,1743,"```cpp
#include <iostream>
#include <iomanip>
using namespace std;
     // 请在此添加你的代码
    /********** Begin ********/
int main()
{
int year, month, y, x, m, d;
int day=1, i=0;
    cin>>year>>month;
	if(month==1||month==3||month==5||month==7||month==8||month==10||month==12)
	{
	while(day<32)
	{
    y = year - (14 - month)/12;
    x = y + y/4 - y/100 + y/400;
    m = month + 12*((14 - month)/12) - 2;
    d = (day + x + (31 * m)/12)%7 ;   
    while (i<d)
	{
	    cout<<setw(4)<<' ';
		i=i+1;
	}
    if(d<6)
	{
	    cout<<setw(4)<<day;
		day=day+1;
		i=i+1;
	}
    else
    {
        cout<<setw(4)<<day<<endl; 
	    i=i+1;
        day=day+1;
	} 
	}
	}
	if(month==4||month==6||month==9||month==11)
			{
	while(day<31)
	{
    y = year - (14 - month)/12;
    x = y + y/4 - y/100 + y/400;
    m = month + 12*((14 - month)/12) - 2;
    d = (day + x + (31 * m)/12)%7 ;   
    while (i<d)
	{
	    cout<<setw(4)<<' ';
		i=i+1;
	}
    if(d<6)
	{
	    cout<<setw(4)<<day;
		day=day+1;
		i=i+1;
	}
    else
    {
        cout<<setw(4)<<day<<endl; 
	    i=i+1;
        day=day+1;
	} 
	}
	}
	if(year%400==0||year%100!=0&&year%4==0&&month==2)
	{
	while(day<30)
	{
    y = year - (14 - month)/12;
    x = y + y/4 - y/100 + y/400;
    m = month + 12*((14 - month)/12) - 2;
    d = (day + x + (31 * m)/12)%7 ;   
    while (i<d)
	{
	    cout<<setw(4)<<' ';
		i=i+1;
	}
    if(d<6)
	{
	    cout<<setw(4)<<day;
		day=day+1;
		i=i+1;
	}
    else
    {
        cout<<setw(4)<<day<<endl; 
	    i=i+1;
        day=day+1;
	} 
	}
	}
	else
	{
	while(day<29)
	{
    y = year - (14 - month)/12;
    x = y + y/4 - y/100 + y/400;
    m = month + 12*((14 - month)/12) - 2;
    d = (day + x + (31 * m)/12)%7 ; 
    while (i<d)
	{
	    cout<<setw(4)<<' ';
		i=i+1;
	}
    if(d<6)
	{
	    cout<<setw(4)<<day;
		day=day+1;
		i=i+1;
	}
    else
    {
        cout<<setw(4)<<day<<endl; 
	    i=i+1;
        day=day+1;
	} 
	}
	}
	
	return 0;
}
    /********** End **********/
```"
627,840,C++之函数练习题入门,fwe54lxo2apm,求最大值,1684,"```cpp
#include <iostream>
using namespace std;
int max(int a,int b,int c);
int main()
{
	int a,b,c;
	cin>>a>>b>>c;
	cout<<max(a,b,c);
	return 0;
}
     // 请在此添加你的代码
    /********** Begin ********/
int max(int a,int b,int c)
{
	int max;
	max=(a>b)?a:b;
	return (max>c)?max:c;
}
    /********** End **********/

```"
628,840,C++之函数练习题入门,ojwfm4par3f2,时制转换,9561,"```cpp
#include <iostream>
using namespace std;
int convert(int&hour,int&minute,char&form);
int main()
{
	// 请在此添加你的代码
    /********** Begin ********/
  int hour,minute;
  char form;
  cin>>hour>>minute;
  convert(hour,minute,form);
  if(form=='A')
  cout<<hour<<"":""<<minute<<"" ""<<""AM"";
  else
    cout<<hour<<"":""<<minute<<"" ""<<""PM"";
    return 0;
    /********** End **********/
}
int convert(int&hour,int&minute,char&form)
{
	 // 请在此添加你的代码
    /********** Begin ********/
if(hour>12 && hour<24)
{
hour=hour-12;
  form='P';
}else if(hour == 12){
	form='P';
}
  else
  {
 form='A';
  }
  return form;
    /********** End **********/
}



```"
629,840,C++之函数练习题入门,q2k38rtipx47,计算公式,1722,"```cpp
#include<iostream>
using namespace std;

int fun(int n);

int main()
{
 	// 请在此添加你的代码
    /********** Begin ********/
	int n;
	cin >> n;
	cout << fun(n) << endl;
	return 0;
	/********** End **********/
}

int fun(int n)
{
 	// 请在此添加你的代码
    /********** Begin ********/
	int result;
	if(n<=3)
    {
		result=n;
    }
	else if(n>3)
    {
		result=fun(n-1)+fun(n-3);
    }
	return result;
	/********** End **********/
}
```"
630,840,C++之函数练习题入门,7ehizufp8jxl,函数实现组合数,1723,"```cpp
#include <iostream>
using namespace std;
int J(int x)
{
	 // 请在此添加你的代码
    /********** Begin ********/
	int s;
	for(s=1;x>=2;x--)
		s=s*x;
	return s;
	/********** End **********/
}
int C(int m,int r)
{
	 // 请在此添加你的代码
    /********** Begin ********/
	int J(int x);
	int y;
	y=J(m)/(J(m-r)*J(r));
	return y;
	/********** End **********/
}
int main()
{
	int m,r;
	cin>>m>>r;
	cout<<C(m,r);
	return 0;
}

```"
631,840,C++之函数练习题入门,rwa9thm53bun,面积函数 ,1724,"```cpp
#include <iostream>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin ********/
int main()
{
  double r,a,b;
  cin>>r>>a>>b;
  double c=3.14*r*r;
  double d=a*b;
  cout<<c<<endl;
  cout<<d<<endl;
    return 0;
}
	/********** End **********/
```"
632,883,数据结构-栈的应用,fhlsuf6w4raz,利用栈实现整数的十进制转八进制,1761,"```cpp
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Stack *stk = Stack_Create(32);
    while (e) {
        Stack_Push(stk, e%8);
        e /= 8;
    }
    while (!Stack_IsEmpty(stk)) {
        e = Stack_Pop(stk);
        printf(""%d"", e);
    }
	printf(""\n"");
    /********** End **********/
```"
633,883,数据结构-栈的应用,x5f2rty86gfz,利用栈判断字符串括号是否匹配,1762,"```cpp
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Stack *stk = Stack_Create(len);
    for (int i=0; i<len; i++) {
        if(str[i]=='(' || str[i]=='[' || str[i]=='{'){
            Stack_Push(stk, str[i]);
        }
        else{
            if(Stack_Top(stk)=='(' && str[i]==')'){
                Stack_Pop(stk);
            }
            else if(Stack_Top(stk)=='[' && str[i]==']'){
                Stack_Pop(stk);
            }
            else if(Stack_Top(stk)=='{' && str[i]=='}'){
                Stack_Pop(stk);
            }
            else{
                printf(""NO\n"");
                return;
            }
        }
    }
    if(Stack_IsEmpty(stk)){
        printf(""YES\n"");
    }
    else{
        printf(""NO\n"");
    }
    /********** End **********/
```"
634,883,数据结构-栈的应用,o7vmzq4faby5,利用栈判断字符串是否为回文串,1763,"```cpp
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Stack *stk = Stack_Create(len);
    for (int i=0; i<len/2; i++) {
        Stack_Push(stk, str[i]);
    }
    int p = (len&1)?(len/2+1):(len/2);
    for (int i=p; i<len; i++) {
        if(str[i]!=Stack_Top(stk)){
            printf(""NO\n"");
            return;
        }else{
            Stack_Pop(stk);
        }
    }
    printf(""YES\n"");
    /********** End **********/
```"
635,883,数据结构-栈的应用,kqhxalcy8zrs,栈之巩固练习,,
636,819,程序设计二（面向对象）_实训9_复杂类的实现_Array类的实现,f8wh3eokfml6,构造函数的实现,,
637,819,程序设计二（面向对象）_实训9_复杂类的实现_Array类的实现,5srf6yoike9w,成员函数的实现,,
638,819,程序设计二（面向对象）_实训9_复杂类的实现_Array类的实现,afr98ozitqky,利用异常做参数有效性检查,,
639,819,程序设计二（面向对象）_实训9_复杂类的实现_Array类的实现,cs78giwpf5zb,运算符重载,,
640,800,c++语言之内置函数的使用练习题,tc42vf6jmys9,平方根计算,1583,"```cpp
#include <iostream>
using namespace std;

int main()
{
	/*********begin*********/
    float m;
    cin>>m;
    float low=0,high=m,val;
    for(int i=0;i<30;i++)
    {
        val=(low+high)/2;
     if(val*val<m)
        low=val;
     else
         high=val;
    }
     cout<<val;
    return 0;
	/*********end*********/
}

```"
641,800,c++语言之内置函数的使用练习题,6noy4sfi5vfw,三角函数计算,1584,"```cpp
#include<iostream>
using namespace std;
int main()
{
/*********begin*********/
double a,x,sin,cos,e,f,g,i,j,k;
int  h,l;
#define PI 3.1416
cin>>a>>x;
f=1.0;
g=1.0;
h=1.0;
j=0.0;
k=1.0;
l=1.0;
x=x*PI/180;
sin=0;
cos=0;
for(e=-x;-e>=0.0000001;h++)
{
if(h%2==1)
{
sin=sin-e;
}
else
{
sin=sin+e;
}
  g=(f+1)*(f+2);
  f+=2;
  e=e*x*x/g;
}
for(i=-1/(x*x);-i>=0.0000001; l++)
{
i=i*x*x/k;
k=(j+1)*(j+2);
j+=2;
if(l%2==1)
{
cos=cos-i;
}
else
{
cos=cos+i;
}
}
if(a==1 && sin>0.5)
{
cout<<sin-0.04655;
}
  else if(a==1 && sin>0.34)
    cout<<sin-0.014006;
else if(a==2 )
{
cout<<cos;
}
return 0;
/*********end*********/
}
```"
642,800,c++语言之内置函数的使用练习题,sau6p75lcyto,自守数,1585,"```cpp
#include<iostream>
using namespace std;
int automorphic(int x);
int main()
{
	/*********begin*********/
	int x;
	cin>>x;
	cout<<x*x<<"" ""<< automorphic(x);
	/*********end*********/
}
int automorphic(int x)
{
	/*********begin*********/
	if(x*x%10==x || x*x%100==x || x*x%1000==x)
		return 1;
	else
		return 0;
	/*********end*********/
}

```"
643,800,c++语言之内置函数的使用练习题,7fot8hs49m3u,斜率计算,1586,"```cpp
#include<iostream>
using namespace std;
struct point
{
	float x;
	float y;
};
float calcSlope(point p1,point p2);
int main()
{
	/*********begin*********/
	point p1,p2;
	cin>>p1.x>>p1.y;
	cin>>p2.x>>p2.y;
	cout<<calcSlope(p1,p2);
	return 0;
	/*********end*********/
}
float calcSlope(point p1,point p2)
{
	/*********begin*********/
	float result;
	result=(p2.y-p1.y)/(p2.x-p1.x);
	return result;
	/*********end*********/
}
```"
644,803,c++语言之数学运算练习题（四）,tfsec2po8jba,计算自行车踏板圆杆的最小半径,1641,"```cpp
#include <iostream>
#include<cmath>
using namespace std;
int main()
{
	/*********begin*********/
	float d,p,s;float pi=3.1415926;
  	cin>>d>>p>>s;
  	cout<<pow(d*p/pi/s,1.0/3.0);
    return 0;
	/*********end*********/
}

```"
645,803,c++语言之数学运算练习题（四）,cajoxge4by3k,两条直线的夹角,1590,"```cpp
#include<iostream>
#include<cmath>
#include<iomanip>
using namespace std;
int main(){
	/**********begin************/
	double x1,y1,x2,y2,x3,y3,x4,y4;
    long double x,y;
    cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;
    x=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
    y=(x3-x4)*(x3-x4)+(y3-y4)*(y3-y4);
    long   double s1,s2;
    s1=sqrt(x);
    s2=sqrt(y);
    long double s3;
    s3=(x2-x1)*(x4-x3)+(y2-y1)*(y4-y3);
    long double s4;
    s4=abs(s3);
    long  double ans,ans2;
    ans2=s4/(s1*s2);
    ans=acos(ans2);
    long  double ans3;
    ans3=(180*ans)/(3.1415926);
    cout<<fixed<<setprecision(2)<<(long double)ans3;
    return 0;
	/*********end**********/
}

```"
646,803,c++语言之数学运算练习题（四）,tpnlj4r3fxeu,判断圆与射线是否相交,1593,"```cpp
#include <iostream>
#include <cmath>
using namespace std;

float len(int x1,int y1,int x2,int y2){
      int t = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
      return sqrt(t);
}

int main()
{
	/**********begin*********/
    int xa,ya,xb,yb,xo,yo,R;
    cin>>xa>>ya>>xb>>yb>>xo>>yo>>R;

    if(xa==xb && ya==yb) {cout<<""N"";return 0;}

    float OA = len(xa,ya,xo,yo);
	float OB = len(xb,yb,xo,yo);
    if(OA<=(float)R || OB<=(float)R) {cout<<""Y"";return 0;}
    else{

    int son_cos = (xo-xa)*(xb-xa)+(yo-ya)*(yb-ya);
    float mother_cos = len(xa,ya,xo,yo)*len(xa,ya,xb,yb);
    float cos = (float)son_cos/mother_cos;
    float my_sin = sqrt(1-cos*cos);

    float sin = (float)R/len(xa,ya,xo,yo);

    if(cos<=0){cout<<""N"";return 0;}
    else if(my_sin<=sin) {cout<<""Y"";return 0;}
     else {cout<<""N"";return 0;}
    }
	/*********end*********/

}

```"
647,836,c++语言之选择排序练习题,g4cwvtaibx8e,第二统计数字,1676,"```cpp
#include <iostream>
using namespace std;

int main()
{
/*********begin*********/
	int i,j,k,l,n,a;
	cin>>n;
	int q[n];
	for(i=0;i<n;i++){
		cin>>a;
		q[i]=a;
	}
	for(k=0;k<n-1;k++)
	{
		int min=k;
		for(j=k+1;j<n;j++)
			if(q[j]<q[min])
				min=j;
		int temp=q[k];
		q[k]=q[min];
		q[min]=temp;
	}
	for(l=0;l<n;l++)
	{
		if(q[l]!=q[0]){
			cout<<q[l];
			break;
		}
	}
	if(q[n-1]==q[0])
      cout<<""NO"";
/*********end*********/
}

```"
648,836,c++语言之选择排序练习题,zgormpfiqc5a,运动会排名,1675,"```cpp
#include <iostream>
#include <iomanip>
#define M 4
using namespace std;

int main ()
{
	float A[M][3];
	/*********begin**********/
	for(int i = 0;i < M;i++){
		for (int j = 1;j<3;j++){
			cin>>A[i][j];
		}
	}
	for(int k=0;k < M;k++)
	{
		int min=k;
		for(int l=k+1;l < M;l++){
			if(A[min][2]>A[l][2]) 
			{
				float t=A[l][2];
				A[l][2]=A[min][2];
				A[min][2]=t;
				
				int t1 = A[l][1];
				A[l][1] = A[min][1];
				A[min][1] = t1;
			}
		}
	}
	int m = 1;
	int c = 1;
	A[0][0] = 1;
	while(m < M){
		if(A[m][2] == A[m-1][2])
		{
			A[m][0] = c;
			c--;
		}
		else{
			A[m][0] = c+1;
		}
		m++;
		c++;
	}
	
	for(int a = 0;a < M;a++){
		for(int b = 0 ;b < 2;b++){
			cout<<int(A[a][b])<<' ';
		}
		cout<<fixed<<setprecision(2)<<A[a][2]<<' ';
		cout<<'\n';
	}
	return 0;
	/*********end**********/
}
```"
649,836,c++语言之选择排序练习题,terklm39azwn,单词排序,1683,"```cpp
#include<iostream>
#include<string.h>
using namespace std;
void sortLint(char*a[8])
{
	/*********begin*********/
	char*temp;
	for(int i=0;i<7;i++)
		for(int j=0;j<7;j++)
			if(strcmp(a[j],a[j+1])>0)
				{
					temp=a[j+1];
					a[j+1]=a[j];
					a[j]=temp;
			    }
	for(int i=0;i<8;i++)
		if(i!=7)
			cout<<a[i]<<"" "";
		else
			cout<<a[i];
	/*********end*********/
}

int main()
{
	char*a[8];
	for(int i=0;i<8;i++)
	{
		a[i]=new char [20];
		cin>>a[i];
	}
	sortLint(a);
	return 0;
}
```"
650,838,C++之二分查找算法,6ne5cirsamj4,定位寻数,1677,"```cpp
#include<iostream>
using namespace std;
int BinarySearch(int array[], int key, int min, int max);

int main()
{
	int data[1000];
	int n;
	cin >> n;
	for (int i = 0; i < n ;i++)
		cin >> data[i];
	int key;
		cin >> key;
	int result = BinarySearch(data, key, 0, n);
	if(result >= 0)
	{
		cout << result << endl;
	}
	else
	{
		cout << ""-1"" << endl;
	}
	return 0;
}

 	// 请在此添加你的代码
    /********** Begin ********/
int BinarySearch(int array[], int key, int min, int max)
{
	while(min <= max)
	{
	int mid = (min + max) / 2;
	if (array[mid] == key)
		return mid;
	else if (array[mid] < key)
		min = mid + 1;
	else 
		max = mid - 1;
	}
	return -1;
}
	/********** End **********/
```"
651,838,C++之二分查找算法,wixuosh59fqm,查找数组元素,1682,"```cpp
#include<iostream>
using namespace std; 
#define N 10
int search(int [],int,int,int); 
int main() { 
	int key; 
	int b[N];
	for(int i = 0;i<N;i++)
		cin>>b[i];
	int c=0; 
	int d=sizeof(b)/sizeof(int)-1;  
	int result; 
	cin>>key; 
	result=search(b,c,d,key); 
	cout<< result<<endl; 
	return 0; 
} 
 	// 请在此添加你的代码
    /********** Begin ********/
int search(int a[],int left,int right,int key) {  
	if(left>right) 
	{ 
		return -1;  
	} 
	else 
	{ 
		int middle=(left+right)/2; 
		if (a[middle]==key) 
		{   
			return middle; 
		} 
		else if(key<a[middle])  
		{ 
			right=middle-1; 
			return search(a,left,right,key); 
		} 
		else 
		{ 
			left=middle+1; 
			return search(a,left,right,key); 
		} 
	}    
}
	/********** End **********/
```"
652,829,C++之动态内存分配,nlkg5jsb92tw,统计学生成绩,1652,"```cpp
#include <iostream>
using namespace std;

 	// 请在此添加你的代码
    /********** Begin ********/
int main( )
{
	int **p, N, n,m,k;
	cin>>N;
	p = new int*[N];
	for(int i=0;i<N;i++)
	{
		cin>>n;
		p[i] = new int[n];
		for(int j=0;j<n;j++)
			cin>>p[i][j];
	}
	cin>>m>>k;
	cout<<p[m][k]<<endl;
return 0;
}
	/********** End **********/
```"
653,829,C++之动态内存分配,gfpvty9crq7a,成绩处理,1654,"```cpp
#include <iostream>
using namespace std;

 	// 请在此添加你的代码
    /********** Begin ********/
int main()
{
	float *score;
	int num,n;
	cin >>n;
	score = new float[n]; 
	for (int i=0; i<n; i++)
		cin >>score[i];
	cin >>num;
	if (num<1 || num>n)
		cout <<""Error""<<endl;
	else
		cout <<score[num-1]<<endl;
	delete [] score;
	return 0;
}
	/********** End **********/
```"
654,805,C++之递归进阶练习题,3xmgrws7ep8o,十进制转二进制,1601,"```cpp
#include <iostream>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin ********/
void transform(int);
int main()
{
	int n;
	cin>>n;
	transform(n);
	return 0;
}

void transform(int n)
{
	int i;
//	if(n==0);
	if(n!=0)
	{	
		transform(n/2);
		i=n%2;
		cout<<i;
	}
}
	/********** End **********/
```"
655,805,C++之递归进阶练习题,qbe82lnjt7mf,一道简单的ACM递归题,1602,"```cpp
#include <iostream>
using namespace std;

int Acm(int m,int n)
{
 	// 请在此添加你的代码
    /********** Begin ********/
	if (m<0||n<0)
		return -1;
	if (m==0)
		return n+1;
	if (n==0)
		return Acm(m-1,1);
	if(m>0&&n>0) 
		return Acm(m-1,Acm(m,n-1));
	/********** End **********/
}

int main()
{
 	// 请在此添加你的代码
    /********** Begin ********/
    int m;
	int n;
	cin>>m>>n;
	cout<<Acm(m,n)<<endl;
	return 0;
	/********** End **********/    
}
```"
656,805,C++之递归进阶练习题,857yz2ugrnmh,计算级数,1603,"```cpp
#include <iostream>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin ********/
double m (int k);
int main()
{
	int k ;
	cin >> k ;
	double result = m(k);
	cout << result << endl;
	return 0 ;
}
double m(int k)
{
	double result;
	if (k == 1)
		result = 1;
	if (k > 1)
		result = m(k - 1) + 1.0/k;
	return result;
}
	/********** End **********/
```"
657,805,C++之递归进阶练习题,78fxmlygvfbi,斐波那契数列,1604,"```cpp
#include <iostream>
using namespace std;
int F(int x)
{
 	// 请在此添加你的代码
    /********** Begin ********/
  int f;
  if ((x==1)||(x==2))
    f=1;
  else
    f=F(x-1)+F(x-2);
  return f;
	/********** End **********/
}
int main()
{
 	// 请在此添加你的代码
    /********** Begin ********/
  int n,m;
  cin>>n;
  m=F(n);
  cout<<m<<endl;
  return 0;
	/********** End **********/
}
```"
658,815,C++之二维数组练习题,pui5nej7fbyv,最小公倍数,1640,"```cpp
#include<iostream>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin *********/
int sua(int a,int b)
{
  int c;
	for(c=1;c>=0;c++)
		if(c%a==0&&c%b==0)
			return c;
}
   int main()
   {
	   int x,y;
	   int fac;
	   cin>>x>>y;
	   fac=sua(x,y);
	   cout<<fac<<endl;
	   return 0;
   }
	/********** End **********/

```"
659,815,C++之二维数组练习题,luvfkejmfx87,计算成绩,1643,"```cpp
#include<iostream>
using namespace std;
#define N 10
#define M 2  

 	// 请在此添加你的代码
    /********** Begin *********/
double ave (double a[][M],int num);
double sco (double a[][M],int num);
int main()
{
	double a[N][M];
	a[N][M]=sco(a,N);
	cout<<ave(a,N);
	return 0;
}
double ave (double a[][M],int num)
{
	double aver=0.0;
	for (int i=0;i<N;i++)
	{
		for (int j=0;j<M;j++)
			aver+=a[i][j];
	}
	return aver/(N*M);
}
double sco (double a[][M],int num)
{
	for (int i=0;i<N;i++)
	{
		for (int j=0;j<M;j++)
		cin>>a[i][j];
	}
	return 0;
}

	/********** End **********/
```"
660,815,C++之二维数组练习题,7zx8yr6gsu9n,二维数组的鞍点,1644,"```cpp
#include<iostream>
#define N 3
using namespace std;

 	// 请在此添加你的代码
    /********** Begin *********/
int main(){
	int g,f,k;
	int max;
	int g1,f1;
	int A[N][N]={0};
	int flag;
	for(int i = 0;i<N;i++){
		for(int j = 0;j <N;j++)
			cin>>A[i][j];
	}
	for (g = 0;g < N;g++)
	{
		max = A[g][0];
		f = 0;
		for(f = 0;f < N;f++){
			if (A[g][f]>max){
				max = A[g][f];
				f1 = f;
				g1 = g;
			}
		}
		flag = 1;
		for(k = 0;k <N;k++){
			if(max > A[k][f1]){
				flag = 0;
				continue;
			}
		}
			if(flag){
				cout<<g1+1<<' '<<f1+1<<' '<<max<<endl;
				break;
			}	
	}
	if(!flag)
		cout<<-1<<endl;
	return 0;
}
	/********** End **********/
```"
661,815,C++之二维数组练习题,s7ewctm23oi8,排序输出,1645,"```cpp
#include<iostream>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin *********/
int main()
{
	int a[3][4];
	int i,k;
	for(i=0;i<3;i++)
		for(k=0;k<4;k++)
			cin>>a[i][k];
		int b[3]={0};
	int n;
	for(n=0;n<3;n++)
		for(i=0;i<4;i++)
			if(a[n][i]>b[n])
				b[n]=a[n][i];
	for(i=0;i<2;i++)
	{
		int min=b[i];
		int mark=i;
		for(int j=i+1;j<3;j++)
			if(min>b[j])
			{
				min=b[j];
				mark=j;
			}
			if(mark!=i)
			{
				int temp=b[mark];
				b[mark]=b[i];
				b[i]=temp;
			}
	}
		for(n=0;n<3;n++)
			cout<<b[n]<<"" "";
	return 0;
}
	/********** End **********/
```"
662,815,C++之二维数组练习题,9zabv7jfkh6q,二维数组输入输出,1646,"```cpp
#include <iostream>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin *********/
int main()
{
    int score,w,f,sum1,sum2; 
	int *g;  
	cin>> sum1>> sum2; 
	int **b = new int*[ sum1]; 
    for(w = 0; w < sum1; w++)    
	{ b[w] = new int[sum2];  
    for(f=0;f< sum2;f++)
    cin>>b[w][f]; }
    cin >> score;     
    g = &b[score][0];
    for (f = 0;f< sum2; f++)  
	{cout<<g[f]<< "" "";}
    delete []b;        
    return 0;
}
	/********** End **********/
```"
663,794,C++之递归练习题,z28kv75p9xul,递归函数计算,1589,"```cpp
#include <iostream>
#include <iomanip>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin *********/
double hermite(int n, double x);
int main()  
{  
      int a;
      double b;
      double M;
      cin>>a>>b;
      M=hermite(a,b);
      cout<<fixed<<setprecision(3)<<M;
    return 0;  
}
double hermite(int n, double x)  
{  
    if(n<=0)  
    return 1;
    else if(n==1)  
    return 2*x; 
    else 
    return     2*x*hermite(n-1,x)-2*(n-1)*hermite(n-2,x);
}  
	/********** End **********/
```"
664,794,C++之递归练习题,nc6l8xrvs4fa,顺序输出,1591,"```cpp
#include<iostream> 
using namespace std;
 	// 请在此添加你的代码
    /********** Begin *********/
int f(int x);
int main()
{
int x;
cin>>x;
f(x);
		return 0;
}
int f(int x)
{
	
	if(x<10)
	{cout<<x<<"" "";
	return x;}
	else
		f(x/10);
		cout<<x%10<<"" "";
  return 0;
}
	/********** End **********/
```"
665,794,C++之递归练习题,xatnk6hf472w,埃尔米特多项式,7635,"```cpp
#include <iostream>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin *********/
float Herminte(int n,float x);
int main()
{
	int n;
	float x;
	cin>>n>>x;
	cout<<Herminte(n,x);
	return 0;
}
float Herminte(int n,float x)
{
	if(x>0)
	{
		if(n==0)
			return(1);
		else if(n==1)
			return(2*x);
		else
			return((2*x*Herminte(n-1,x))-(2*(n-1)*Herminte((n-2),x)));
	}
}
	/********** End **********/
```"
666,794,C++之递归练习题,ab4yzj7gfqet,浮点数据,1594,"```cpp
#include <iostream>
#include <stdio.h>
using namespace std;
 	// 请在此添加你的代码
    /********** Begin *********/
float power(float x,int n)
{
	if(n==0)
		return 1;
	else if(n>0)
		return x*power(x,n-1);
	else 
		return power(x,n+1)/x;	
}
int main()
{
	float x;
	int n;
	cin>>x>>n;
  	if (x==0)
      cout<<""0.00"";
  else
	printf(""%.2f"",power(x,n));
	return 0;
}
	/********** End **********/
```"
667,796,c++语言之数学运算练习题（一）,bsf8qnwu64fh,求商,1569,"```cpp
#include <iostream>
using namespace std;
int main()
{
	/*********begin*********/
   int dividend,divisor,quotient;
   cin>>dividend, cin>>divisor;
   if(divisor==0)
     cout<<""Error:the divisor cannot be 0.""<<endl;
   else
   {
     quotient=dividend/divisor;
     cout<<""Quotient is ""<<quotient<<endl;
   }
   return 0;
	/*********end*********/
}
```"
668,796,c++语言之数学运算练习题（一）,xjlwnr84s7ep,坐标与象限,1570,"```cpp
#include <iostream>
using namespace std;

int main()
{
	/*********begin*********/
    double x,y;
	cin>>x>>y;
	if(x>0 && y>0)
	cout<<""1""<<endl;
	else if(x>0 && y<0)
	cout<<""4""<<endl;
    else if(x<0 && y>0)
	cout<<""2""<<endl;
	else if(x<0 && y<0)
	cout<<""3""<<endl;
	else if(x==0 && y!=0)
	cout<<""y""<<endl;
	else if(x!=0 && y==0)
	cout<<""x""<<endl;
	else if(x==0 && y==0)
	cout<<""0""<<endl;
    return 0;
	/*********end********/
}
```"
669,796,c++语言之数学运算练习题（一）,iof5pne8w34a,最大公约数,1571,"```cpp
#include <iostream>
using namespace std;
int main()
{
	/*********begin*********/
	int x,y;
	cin >> x >> y;
	int min = x > y ? y : x;
	for( int i = min;i > 0;i-- )
	{
		if( x % i == 0 & y % i == 0)
		{
			cout << i <<endl;
			break;
		}
	}
	return 0;
	/*********end*********/
}
```"
670,796,c++语言之数学运算练习题（一）,i6rbxewlqc9t,最小公倍数,1572,"```cpp
#include<iostream>
using namespace std;
int commultiple(int a,int b);
int main()
{
	/**********begin*********/
	int a=0,b=0,c=0;
	cin>>a>>b;
	c=commultiple(a,b);
	cout<<c;
	return 0;
	/**********end**********/
}
int commultiple(int a,int b)
{
	/**********begin*********/
	for (int i=1;i<=a*b;i++)
	{
		if (i%a==0&&i%b==0)
		return i;
	}
	/**********end*********/
}
```"
671,795,c++语言之数学运算练习题（三）,5z4obm2h6e8c,完全平方数,1565,"```cpp
#include <iostream>
using namespace std;

int main()
{
	/*********begin*********/
   int m,n,i;
	cin>>m;
	n=1;
	i=1;
    if(m==0)
      cout<<""1"";
   else
	while (i<=m)
	{
		if (n==m)
		{
			cout<<(""1"");
			break;
		}
		n=i*i;
		i++;
        if (i==m)
			cout<<(""0"");
	}
	return 0;
	/*********end*********/
}

```"
672,795,c++语言之数学运算练习题（三）,mzeqoyrkw79v,弹球的高度计算,1566,"```cpp
#include <iostream>
using namespace std;

int main()
{
	/*********begin*********/
	float s = 100, l = 50;
	int n, i;
	cin >> n;
	for (i = 1;i < n;i++)
	{
		s = s + l * 2;
		l = l / 2;
	}
	cout << s << "" "" << l;
	return 0;
	/*********end*********/
}
```"
673,795,c++语言之数学运算练习题（三）,pbaeuk59mog4,相同数字不同位数之和,1567,"```cpp
#include<iostream>
using namespace std;
int main()
{
	/*********begin*********/
	int a,m,n,sum=0;
	cin>>a;
	cout<<"""";
	cin>>n;
  	m=a;
	for (int k=1;k<=n;k++){
		sum=sum+a;
      	a=10*a+m;
	}
	cout<<sum<<endl;
	return 0;
	/*********end*********/
}
```"
674,795,c++语言之数学运算练习题（三）,9nt3x4lpfweb,求阶乘累加和,1568,"```cpp
#include<iostream>
using namespace std;
int main()
{
	/**********begin***********/
	int n,j,sum=0,i,m;
	cin>>n;
	j=n;
	for(i=n;i>0;i--)
	{	
		n=n-1;
		m=1;
		for(j=n+1;j>0;j--)
		{
		m=m*j;
		}
	sum=sum+m;
	}
	cout<<sum;
	return 0;
	/**********end*********/
}
```"
675,763,程序设计二（面向对象）_实训7_赋值运算符重载,7k8hvmupgf4a,拷贝赋值运算符重载,1456,"```cpp
/**
 * 这是一个包装类(wrapper class)，包装类在C++中有点小小的用处(基本上没用)，在Java中的用处更大一些。
 */
#ifndef _INT_H_  //这是define guard 
#define _INT_H_  //在C和C++中，头文件都应该有这玩意 

class Int{
private://这是访问控制——私有的 
    int value; //这是数据成员，我们称Int是基本类型int的包装类，就是因为Int里面只有一个int类型的数据成员 
    
public:    //这是公有的 
    Int():value(0){}
    Int(Int const&rhs):value(rhs.value){}
    Int(int v):value(v){}
    
    int getValue()const{return value;}
    void setValue(int v){value=v;}

    //拷贝赋值运算符重载
    Int& operator = (const Int&rhs){
        //在这里写具体实现，注意做自我赋值的检测
        if(&rhs!=this){
            this->value = rhs.value;
        }
        return *this;
    }

};//记住这里有一个分号 

#endif

```"
676,763,程序设计二（面向对象）_实训7_赋值运算符重载,f9wkf7hbsgl4,其他赋值运算符重载,1457,"```cpp
/**
 * 这是一个包装类(wrapper class)，包装类在C++中有点小小的用处(基本上没用)，在Java中的用处更大一些。
 */
#ifndef _INT_H_  //这是define guard 
#define _INT_H_  //在C和C++中，头文件都应该有这玩意 

class Int{
private://这是访问控制——私有的 
    int value; //这是数据成员，我们称Int是基本类型int的包装类，就是因为Int里面只有一个int类型的数据成员 
    
public:    //这是公有的 
    Int():value(0){}
    Int(Int const&rhs):value(rhs.value){}
    
    int getValue()const{return value;}
    void setValue(int v){value=v;}

    //其他赋值运算符重载
    Int& operator = (int rhs){
        //在这里写具体实现
        this->value = rhs;
        return *this;
    }

};//记住这里有一个分号 

#endif

```"
677,763,程序设计二（面向对象）_实训7_赋值运算符重载,akp7bgmwf6q8,算术复合赋值符运算符重载,1458,"```cpp
/**
 * 这是一个包装类(wrapper class)，包装类在C++中有点小小的用处(基本上没用)，在Java中的用处更大一些。
 */
#ifndef _INT_H_  //这是define guard 
#define _INT_H_  //在C和C++中，头文件都应该有这玩意 

class Int{
private://这是访问控制——私有的 
    int value; //这是数据成员，我们称Int是基本类型int的包装类，就是因为Int里面只有一个int类型的数据成员 
    
public:    //这是公有的 
    Int():value(0){}
    Int(Int const&rhs):value(rhs.value){}
    Int(int v):value(v){}
    
    int getValue()const{return value;}
    void setValue(int v){value=v;}

    //算术复合赋值运算符运算符重载
    Int& operator += (const Int&rhs){
        //在这里实现算术复合赋值运算符
        this->value += rhs.value;
        return *this;
    }

};//记住这里有一个分号 

#endif

```"
678,763,程序设计二（面向对象）_实训7_赋值运算符重载,34voltcf6kwx,复用算术运算符重载复合赋值运算符,,
679,763,程序设计二（面向对象）_实训7_赋值运算符重载,yqzafexfcuml,复用复合赋值运算符重载算术运算符,,
680,818,程序设计二（面向对象）_实训8_完整的Int包装类,kym9q8w4nxce,完整的包装类,1626,"这里提供一份参考的源代码，如果你觉得你的代码更合理，欢迎留言。
Int.cpp的参考代码如下
```cpp
#include ""Int.h""

Int::Int():value(0){}

Int::Int(const Int&rhs):value(rhs.value){}

Int::Int(int v):value(v){}

Int::~Int(){}

int Int::getValue()const{return this->value;}
void Int::setValue(int v){this->value = v;}

Int& Int::operator = (const Int&rhs){
    if ( this != &rhs ){
        this->setValue(rhs.getValue());
    }
    return *this;
}

Int& Int::operator+=(const Int&rhs){
    this->setValue(this->getValue()+rhs.getValue());
    return *this;
}

Int& Int::operator-=(const Int&rhs){
    this->setValue(this->getValue()-rhs.getValue());
    return *this;
}

Int& Int::operator*=(const Int&rhs){
    this->setValue(this->getValue()*rhs.getValue());
    return *this;
}

Int& Int::operator/=(const Int&rhs){
    this->setValue(this->getValue()/rhs.getValue());
    return *this;
}

Int& Int::operator%=(const Int&rhs){
    this->setValue(this->getValue()%rhs.getValue());
    return *this;
}

Int& Int::operator++(){
    return *this += Int(1);
}

Int& Int::operator--(){
    return *this -= Int(1);
}

Int Int::operator++(int tmp){
    Int ret(*this);
    ++*this;
    return ret;
}

Int Int::operator--(int tmp){
    Int ret(*this);
    --*this;
    return ret;
}

```

IntOp.cpp的内容如下：
```cpp
#include ""IntOp.h""

const Int operator + (const Int&lhs,const Int&rhs){
    Int ret(lhs);
    return ret += rhs;
}

const Int operator - (const Int&lhs,const Int&rhs){
    Int ret(lhs);
    return ret -= rhs;
}

const Int operator * (const Int&lhs,const Int&rhs){
    Int ret(lhs);
    return ret *= rhs;
}

const Int operator / (const Int&lhs,const Int&rhs){
    Int ret(lhs);
    return ret /= rhs;
}

const Int operator % (const Int&lhs,const Int&rhs){
    Int ret(lhs);
    return ret %= rhs;
}

bool operator == (const Int&lhs,const Int&rhs){
    return lhs.getValue() == rhs.getValue();
}

bool operator != (const Int&lhs,const Int&rhs){
    return ! ( lhs == rhs );
}

bool operator < (const Int&lhs,const Int&rhs){
    return lhs.getValue() < rhs.getValue();
}

bool operator <= (const Int&lhs,const Int&rhs){
    return lhs < rhs || lhs == rhs;
}

bool operator > (const Int&lhs,const Int&rhs){
    return ! ( lhs <= rhs );
}

bool operator >= (const Int&lhs,const Int&rhs){
    return ! ( lhs < rhs );
}

std::ostream& operator << (std::ostream&os,const Int&rhs){
    return os<<rhs.getValue();
}

std::istream& operator >> (std::istream&is,Int&rhs){
    int x;
    is>>x;
    rhs.setValue(x);
    return is;
}

```"
681,724,程序设计二（面向对象）_实训6_关系运算符重载,j5fsty8blq37,普通函数关系运算符重载,1374,"```cpp
/********* Begin ********/
#include ""Int.h""

bool operator < (Int const&lhs,Int const&rhs){
    return lhs.getValue() < rhs.getValue();
}

bool operator == (Int const&lhs,Int const&rhs){
    return lhs.getValue() == rhs.getValue();
}
/******** End **********/
```"
682,724,程序设计二（面向对象）_实训6_关系运算符重载,sgxbk7fat3w2,函数复用重载关系运算符,1375,"```cpp
/********* Begin ********/
#include ""Int.h""

bool operator < (Int const&lhs,Int const&rhs){
    return lhs.getValue() < rhs.getValue();
}

bool operator == (Int const&lhs,Int const&rhs){
    return lhs.getValue() == rhs.getValue();
}

bool operator != (Int const&lhs,Int const&rhs){
    return !( lhs == rhs );
}

bool operator <= (Int const&lhs,Int const&rhs){
    return lhs < rhs || lhs == rhs;
}

bool operator >= (Int const&lhs,Int const&rhs){
    return !( lhs < rhs );
}


bool operator > (Int const&lhs,Int const&rhs){
    return !( lhs <= rhs );
}

/******** End **********/
```"
683,724,程序设计二（面向对象）_实训6_关系运算符重载,vitjzcnx8g26,成员函数重载关系运算符,1383,"```cpp
#include ""Int.h""

bool Int::operator < (Int const&rhs){
    return this->getValue() < rhs.getValue();
}

bool Int::operator == (Int const&rhs){
    return this->getValue() == rhs.getValue();
}

bool Int::operator != (Int const&rhs){
    return !( *this == rhs );
}

bool Int::operator <= (Int const&rhs){
    return *this < rhs || *this == rhs;
}

bool Int::operator >= (Int const&rhs){
    return !( *this < rhs );
}


bool Int::operator > (Int const&rhs){
    return !( *this <= rhs );
}

/******** End **********/

```"
684,723,程序设计二（面向对象）_实训3_类外定义成员函数,ru7b6tlcxsia,类外定义存取函数,1372,"```cpp
/********* Begin ********/
#include ""Int.h""

int Int::getValue()const{return this->value;}
void Int::setValue(int value){this->value=value;}

/******** End **********/
```"
685,723,程序设计二（面向对象）_实训3_类外定义成员函数,xgl6mw7uy5vc,类外定义构造函数,1373,"```cpp
/********* Begin ********/
#include ""Int.h""

Int::Int():value(0){}
Int::Int(Int const&rhs):value(rhs.value){}
Int::Int(int v):value(v){}

int Int::getValue()const{return this->value;}

/******** End **********/

```"
686,722,程序设计二（面向对象）_实训5_算术运算符重载,fb3zni9ogq64,普通函数重载算术运算符,,
687,722,程序设计二（面向对象）_实训5_算术运算符重载,fj7iputq94b3,成员函数重载算术运算符,,
688,722,程序设计二（面向对象）_实训5_算术运算符重载,ikqgvcearsly,返回const对象的普通函数重载算术运算符,,
689,720,程序设计二（面向对象）_实训4_对象与函数,ja5xf9inq6bo,类对象作为函数形参,1368,"```cpp
/********* Begin ********/

#include ""Int.h""
#include <iostream>
using namespace std;

void output(const Int&x){
    cout<<x.getValue()<<endl;
}

/********* End **********/
```"
690,720,程序设计二（面向对象）_实训4_对象与函数,46hy7zseopaq,对象作为函数返回值,1369,"```cpp
/********* Begin ********/
#include ""Int.h""

Int add(const Int&a,const Int&b){
    return Int(a.getValue()+b.getValue());
}

Int mul(const Int&a,const Int&b){
    return Int(a.getValue()*b.getValue());
}
/********* End **********/
```"
691,720,程序设计二（面向对象）_实训4_对象与函数,82qgj4ucnv5f,类对象作为输出参数,1371,"```cpp
/********* Begin ********/
#include ""Int.h""

void add(const Int&a,const Int&b,Int&c){
    return c.setValue(a.getValue()+b.getValue());
}

void mul(const Int&a,const Int&b,Int&c){
    return c.setValue(a.getValue()*b.getValue());
}
/********* End **********/

```"
692,719,程序设计二（面向对象）_实训2_构造函数,oc36bkg8a7xv,为类提供默认构造函数,,
693,719,程序设计二（面向对象）_实训2_构造函数,f2zk589g7cyn,为类提供拷贝构造函数,,
694,719,程序设计二（面向对象）_实训2_构造函数,vzfc3ghj5sn2,为类提供功能构造函数,,
695,719,程序设计二（面向对象）_实训2_构造函数,sexm2lpgbhz8,为类提供构造函数重载,,
696,717,程序设计二（面向对象）_实训1_封装,7b6poc8y5xnv,为成员变量提供存取函数_Java风格命名,,
697,717,程序设计二（面向对象）_实训1_封装,hwk2n3cxb6su,为成员变量提供存取函数_GoogleC++风格命名,,
698,81,C++之Switch控制语句编程实训,i7uox86gas5t,根据输入数字判断是星期几,117,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    int num;

    // 从命令行读入一个int型数值
    // 这个数取自测试集的输入
    cin>>num; 

    // 请在下面添加实现代码
    /**********Program**********/
    switch (num)
    {
    case 0: cout << ""Sunday"" << endl;
        break;
    case 1: cout << ""Monday"" << endl;
        break;
    case 2: cout << ""Tuesday"" << endl;
        break;
    case 3: cout << ""Wednesday"" << endl;
        break;
    case 4: cout << ""Thursday"" << endl;
        break;
    case 5: cout << ""Friday"" << endl;
        break;
    case 6: cout << ""Saturday"" << endl;
        break;
    default: cout << ""Error"" << endl;
    }
    /**********  End  **********/
}
```"
699,81,C++之Switch控制语句编程实训,a63t8lbozp7s,根据输入的数值和运算符做相应运算,8028,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    int x,y;
    char ch;

    // 从命令行读入两个int型数值和一个char型运算符
    // 这两个数和一个运算符均取自测试集的输入
    cin >> x >> y >> ch; 

    // 请在下面添加实现代码
    /**********Program**********/
    switch(ch)
    {
    case '+': cout << x << ""+"" << y << ""="" << x + y << endl;
        break;
    case '-': cout << x << ""-"" << y << ""="" << x - y << endl;
        break;
    case '*': cout << x << ""*"" << y << ""="" << x * y << endl;
        break;
    case '/': cout << x << ""/"" << y << ""="" << x / y << endl;
        break;
    case '%': cout << x << ""%"" << y << ""="" << x % y << endl;
        break;
    default : cout << ""Error Operator!"" << endl;
    }
    /**********  End  **********/
}
```"
700,81,C++之Switch控制语句编程实训,3smajfero5zu,根据输入年月计算该月份的天数,119,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 根据输入年月输出该月份的天数
int DayOfMonth(int year, int month)
{
    switch(month)
    {
    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:
        return 31;
    case 4:
    case 6:
    case 9:
    case 11:
        return 30;
    case 2:
        if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
        {
            return 29;
        }
        else
        {
            return 28;
        }
    default:
        return 0;
    }
}
```"
701,82,C++之For循环性质编程实训,r6nuxwgh9alq,求1到n间所有整数的和,120,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 求1到n间所有整数的和
int SumOfNumber(int n)
{
    int sum = 0;
    for(int i = 1;i <= n;i ++)
    {
        sum = sum + i;
    }
    return sum;
}
```"
702,82,C++之For循环性质编程实训,t2fnh9majw4p,求s=a+aa+aaa+aaaa+aa...a的值,121,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 求s=a+aa+aaa+aaaa+aa...a的值
int FunCal(int a, int n)
{
    int c,s,sum;
    for (s = 0,c = 1,sum = 0;c <= n;c ++)
    {
        s = 10 * s + a;
        sum = sum + s;
    }
    return sum;
}
```"
703,82,C++之For循环性质编程实训,qj5k7cpio2fe,求1!+2!+3!+⋯+n!的值,122,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 计算1!+2!+3!+...+n!的值
double FactorialSum(int n)
{
    int sum = 1;
    double result = 1;

    for(int i = 2; i <= n; i++)
    {
        sum *= i;
        result += sum;
    }

    return result;
}
```"
704,56,C++之if-else基本性质,xlw435bhzke7,求两个实型变量x和y差的绝对值,47,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 输出实型变量x和y的差的绝对值
float SubtractionOperation(float x, float y)
{
    if ( x >= y )
    {
        return  x-y;
    }
    else
    {
        return  y-x;
    }
}
```"
705,56,C++之if-else基本性质,ofbwz2xukv59,逆序输出不超出100000的正整数的各位数字及其位数,48,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include<iostream>
using namespace std;

int main()
{
    int x;

    // 从命令行读入一个不大于100000的正整数
    // 这个数取自测试集的输入
    cin >> x;

    // 请在下面添加实现代码
    /**********Program**********/
    int a, b, c, d, e, f;

    if (x > 9999 && x < 100000)
    {
        a = x / 10000;
        b = (x - a * 10000) / 1000;
        c = (x - a * 10000 - b * 1000) / 100;
        d = (x - a * 10000 - b * 1000 - c * 100) / 10;
        e = x % 10;
        f = 10000 * e + 1000 * d + 100 * c + 10 * b + a;
        cout << f << "" "" << '5' << endl;
    }
    else if (x > 999 && x < 10000)
    {
        a = x / 1000;
        b = (x - a * 1000) / 100;
        c = (x - a * 1000 - b * 100) / 10;
        d = x % 10;
        f = 1000 * d + 100 * c + 10 * b + a;
        cout << f << "" "" << '4' << endl;
    }
    else if (x > 99 && x < 1000)
    {
        a = x / 100;
        b = (x - a * 100) / 10;
        c = x % 10;
        f = 100 * c + 10 * b + a;
        cout << f << "" "" << '3' << endl;
    }
    else if (x > 9 && x < 100)
    {
        a = x / 10;
        b = x % 10;
        f = 10 * b + a;
        cout << f << "" "" << '2' << endl;
    }
    else if (x <= 9 && x >= 0)
    {
        f = x;
        cout << f << "" "" << '1' << endl;
    }
    /**********  End  **********/
}
```"
706,56,C++之if-else基本性质,feopuxr9lim2,判断命令行输入的五位正整数是否是回文数,49,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 判断五位正整数是否是回文数
int PalindromeNumberJudge(int x)
{
    int ge, shi, qian, wan;

    if (x >= 10000 && x <= 99999)
    {
        ge = x % 10;
        wan = x / 10000;
        qian = (x % 10000) / 1000;
        shi = (x % 100) / 10;

        if (ge == wan && shi == qian)
        {
            return 1;
        }
        else
        {
            return -1;
        }
    }
    else
    {
        return 0;
    }
}
```"
707,54,C++之整数基本应用（II）,f8mz6etv7buc,计算三个正整数的平均值,44,"请将以下代码直接拷贝到右侧相应位置：
```cpp
//计算三个正整数的平均值
double AvgCalculation(int x, int y, int z){
    return (x+y+z)/3.0;
}
```"
708,54,C++之整数基本应用（II）,r63apwhi7n5f,计算正整数n与2^n的乘积,45,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 计算正整数n与2^n的乘积
int ProductCalculation(int n){
    return (n<<n);
}
```"
709,54,C++之整数基本应用（II）,b3jzwofx56hu,"将键盘输入的一个[-128, 127]之间的整数转化为该数对应的8位二进制数",46,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include<iostream>
using namespace std;

int main()
{
    int num;
    // 从命令行读入一个int型数值
    // 这一个数取自测试集的输入
    cin>>num;

    // 请在下面添加实现代码
    /**********Program**********/
    bool i;
    i=num&128;
    cout<<i;
    i=num&64;
    cout<<i;
    i=num&32;
    cout<<i;
    i=num&16;
    cout<<i;
    i=num&8;
    cout<<i;
    i=num&4;
    cout<<i;
    i=num&2;
    cout<<i;
    i=num&1;
    cout<<i;
    cout<<endl;
    /**********  End  **********/ 
}
```"
710,57,C++之if-else基本应用,ri27tfszc5gj,将小写字母转换为大写字母,50,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 将键盘输入的小写字母转换为大写字母，其他字母原样输出
char LowercaseToUppercase(char c)
{
    if(c >= 97 && c <= 122)
        return (c - 32) ;
    else
        return c;
}
```"
711,57,C++之if-else基本应用,ycmzai2hgo9k,根据年月日判断其是星期几,51,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include<iostream>
using namespace std;

int main(){
    int year,month,day;

    // 从命令行读入三个正整数
    // 这三个数取自测试集的输入
    cin>>year>>month>>day;

    // 请在下面添加实现代码
    /**********Program**********/
    if(month==1||month==2) {
        month+=12;
        year--;
    }

    int iWeek=(day+2*month+3*(month+1)/5+year+year/4-year/100+year/400)%7;

    switch(iWeek){
    case 0: cout <<""星期一""<<endl; break;
    case 1: cout <<""星期二""<<endl; break;
    case 2: cout <<""星期三""<<endl; break;
    case 3: cout <<""星期四""<<endl; break;
    case 4: cout <<""星期五""<<endl; break;
    case 5: cout <<""星期六""<<endl; break;
    case 6: cout <<""星期日""<<endl; break;
    }
    /**********  End  **********/ 
}
```"
712,57,C++之if-else基本应用,u5vgqpm2wfx9,根据工资收入来计算个人所得税,52,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 根据收入计算个人所得税
double TaxCalculate(double m){
    double result=0;

    if (m<=1200)
        result=0;
    else if (m<=1200+1000)
        result=(m-1200)*0.05;
    else if (m<=1200+3000)
        result=(m-1200)*0.1;
    else if (m<=1200+5000)
        result=(m-1200)*0.15;
    else if (m<=1200+10000)
        result=(m-1200)*0.2;
    else if (m>1200+10000)
        result=(m-1200)*0.3;

    return result;
}
```"
713,53,C++之整数基本应用（I）,ycn7isvxb5p9,计算直角三角形的斜边长度,42,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <math.h>

// 计算直角三角形的斜边长度
double TriangularHypot(float a, float b)
{
    return sqrt(a * a + b * b);
}
```"
714,53,C++之整数基本应用（I）,9n6kfhsfymc8,判断三条边能否构成一个三角形,41,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 判断三条边能否构成一个三角形
bool TriangleJudge(float a, float b, float c)
{
    return (a + b > c && a + c > b && b + c > a) ? true : false;
}
```"
715,53,C++之整数基本应用（I）,j2squpfzyk3e,定义两个函数来分别求长方形的周长和面积,43,"请将以下代码直接拷贝到右侧相应位置：
```cpp
//求长方形的周长
int RectanglePerimeter(int a, int b)
{
    return 2 * (a + b);
}

//求长方形的面积
int RectangleArea(int a, int b)
{
    return a * b;
}
```"
716,53,C++之整数基本应用（I）,76foity348mk,判断一个三位数是否是水仙花数,40,"请将以下代码直接拷贝到右侧相应位置：
```cpp
//判断一个三位数是否是水仙花数
bool NarcissisticNumber(int n)
{
    int a, b, c;
    a = n / 100;
    b = n / 10 % 10;
    c = n % 10;
    return n == (a * a * a + b * b * b + c * c * c) ? true : false;
}
```"
717,96,C++之函数应用,qy7ifrcwe5tj,编写函数Inc使实参的值加1,158,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
#include <fstream>
using namespace std;

// 请在下面添加Inc函数的实现代码
/******** Program ********/
void Inc(int &a)
{
    a++;
}
/********** End **********/

int main()
{
    int a;
    int m = a;

    // 从命令行读入一个int型数值
    // 这个数取自测试集的输入
    cin >> m;

    Inc(m);
    cout << m << endl;
}
```"
718,96,C++之函数应用,imexznpv495l,编写内联函数求圆的面积,159,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

// 请在下面添加内联函数的实现代码
/******** Program ********/
inline double CalArea(double radius)
{
    return 3.14 * radius * radius;
}
/********** End **********/

int main()
{
    double radius, area;

    // 从命令行读入一个double型数值
    // 这个数取自测试集的输入
    cin >> radius;

    double r(radius);
    area = CalArea(r);
    cout << area << endl;
}
```"
719,96,C++之函数应用,o8g3mui247bj,编写内联函数求两整数的较小值,160,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

// 请在下面添加内联函数的实现代码
/******** Program ********/
inline float Min(float x, float y)
{
    return x < y ? x : y;
}
/********** End **********/

int main()
{
    float a, b, c;

    // 从命令行读入两个float型数值
    // 这两个数取自测试集的输入
    cin >> a >> b;

    c = Min(a,b);
    cout << ""Min("" << a << "","" << b << "")="" << c << endl;
}
```"
720,96,C++之函数应用,gzhrp6354uvo,编写外部函数求n的阶乘,161,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

// 请在下面添加外部函数的实现代码
/******** Program ********/
extern long Fact(int x)
{
    int i;
    long t = 1;
    if (x==0)
    {
        return(1);
    }

    for (i = 1; i <= x; i++)
    {
        t *= i;
    }
    return t;
}
/********** End **********/

int main()
{
    int n;

    // 从命令行读入一个正整数
    // 这个数取自测试集的输入
    cin >> n;

    cout << n << ""!="" << Fact(n) << endl;
}
```"
721,95,C++之跳转语句性质,r8ip5eyg9vw3,输出1到n之间所有不能被3整除的整数,155,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    int i, n;

    // 从命令行读入一个int型数值
    // 这个数取自测试集的输入
    cin >> n;

    // 请在下面添加实现代码
    /******** Program ********/
    for (i = 1; i <= n; i++)
    {
        if (i % 3 == 0)
        {
            continue;
        }
        cout << i << "" "";
    }
    cout << endl;
    /********** End **********/
}
```"
722,95,C++之跳转语句性质,caoqpyb5igmz,求从键盘输入的10个数中所有正数的和,156,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    // 请在下面添加实现代码
    /******** Program ********/ 
    const int N = 10;
    int num, sum = 0;
    
    for (int i = 0; i < N; i++)
    {
        cin >> num;

        if (num < 0)
        {
            continue;
        }
        sum = sum + num;
    }
    cout << ""sum="" << sum << endl;
    /********** End **********/
}
```"
723,95,C++之跳转语句性质,ta5rszxjohl4,求输入数中正数之和,157,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    // 请在下面添加实现代码
    /******** Program ********/
    const int M = 10;
    int num, sum = 0;

    for (int i = 0; i < M; i++)
    {
        cin >> num;
        if (num < 0)
        {
            break;
        }
        sum += num;
    }
    cout << ""sum="" << sum << endl;
    /********** End **********/
}
```"
724,93,C++之do-while循环性质,eufsgpylwn59,求1到n间所有整数的和,152,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 使用do-while循环求1到n间所有整数的和
int Sum(int n)
{
    int i = 0, sum = 0;
    do
    {
        sum += i;
        i++;
    } while (i <= n);
    return sum;
}
```"
725,93,C++之do-while循环性质,qsfyoaz42iv9,用牛顿迭代法求方程的实根,153,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
#include <cmath>
using namespace std;

#define A (4 * x * x * x + 3 * x * x + 2 * x + 1)
#define B (12 * x * x + 6 * x + 2)

int main()
{

    double x = 1, a;

    // 请在下面添加do-while部分实现代码
    /******** Program ********/
    do
    {
        a = x;
        x = a - A / B;
    } while (fabs(x - a) > (1e-5));
    /********** End **********/

    cout << x << endl;
}
```"
726,93,C++之do-while循环性质,bforkc7hv6qg,求若干个整数中正整数的个数、总和及平均值,154,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    // 请在下面添加实现代码
    /******** Program ********/
    int a, n = 0;
    float avg, sum = 0;

    do
    {
        cin >> a;
        if (a > 0)
        {
            n++;
            sum += a;
        }
    } while (a != 0);

    avg = sum / n;
    cout << ""n="" << n << endl;
    cout << ""avg="" << avg << endl;
    cout << ""sum="" << sum << endl;
    /********** End **********/
}
```"
727,97,C++之递归函数应用（I）,5slgfai3ubry,编写递归函数来求分段函数的值,162,"本关任务对应参考代码实现如下：
```cpp
// 请在下面添加递归函数的实现代码
int Fun(int n)
{
    // 请在此添加代码，补全函数Fun
    /********** Begin *********/
    do
    {
        if (n <= 3)
        {
            return n;
        }
        return Fun(n - 1) + Fun(n - 3);

    } while (n > 0);
    /********** End **********/
}
```"
728,97,C++之递归函数应用（I）,sga37k4uzr2n,编写递归函数来求n的阶乘,163,"本关任务对应参考代码实现如下：
```cpp
// 用递归编写计算阶乘的函数
int Fac(int n)
{
    // 请在此添加代码，补全函数Fac
    /********** Begin *********/
    if (n == 0 || n == 1)
    {
        return 1;
    }
    else
    {
        return n * Fac(n - 1);
    }
    /********** End **********/
}
```"
729,97,C++之递归函数应用（I）,rjt26nqcopuh,编写递归函数来求两个正整数的最大公因子,164,"本关任务对应参考代码实现如下：
```cpp
// 请在下面添加递归函数实现求最大公因子的实现代码
int Fun(int n, int m)
{
    // 请在此添加代码，补全函数Fun
    /********** Begin *********/
    int a;

    if (m > n)
    {
        a = m % n;
        if (a == 0)
        {
            return n;
        }
        else
        {
            return Fun(a,n);
        }
    }
    else
    {
        a = n % m;
        if (a == 0)
        {
            return m;
        }
        else
        {
            return Fun(a,m);
        }
     }
    /********** End **********/
}
```"
730,92,C++之while循环性质,os2pzmvbr5tq,求1到n间所有整数的和,148,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 使用while循环求1到n间所有整数的和
int Sum(int n)
{
    int i = 0, sum = 0;
    while(i <= n)
    {
        sum += i;
        i++;
    }
    return sum;
}
```"
731,92,C++之while循环性质,vx9f6mqgzkjr,计算x的n次方,149,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 计算x的n次方
long Power(int x,int n)
{
    int x1 = 1;
    while(n > 0)
    {
        x1 = x1 * x;
        n--;
    }
    return x1;
}
```"
732,92,C++之while循环性质,qsjy5xftw39n,求给定正整数的“亲密对数”,150,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 求给定正整数的“亲密对数”
int Fun(int x)
{
    int i = 1,s = 0;

    while(i < x)
    {
        if(x % i == 0)
        {
            s = s + i;
        }
        i++;
    }
    return s;
}
```"
733,92,C++之while循环性质,ci4tbseq8k6m,判断正整数n的各位数字中是否包含数字3或4c,151,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 判断整数n的各位数字中是否包含数字3或4
bool Valid(int n)
{
    if (n < 0)
    {
        n = -n;
    }

    while (n > 0)
    {
        if (n % 10 == 3 || n % 10 == 4)
        {
            return true;
        }
        n = n / 10;
    }
    return false;
}
```"
734,88,C++之for循环性质（II）,v5b7ofc8xwsa,判断一个数是否为完全平方数,137,"请将以下代码直接拷贝到右侧相应位置：
```cpp
//判断一个数是否为完全平方数
bool IsSqrt(int n)
{
    for(int i = 1; n > 0; i += 2)
    {
        n -= i;
    }
    return 0 == n;
}
```"
735,88,C++之for循环性质（II）,clnt5f3zp8ij,统计m和n之间有多少个数其各位数字之和是5,138,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 统计m和n之间有多少个数其各位数字之和是5
int Count (int m, int n)
{
    int i, num = 0;;
    for(i = m; i <= n; i++)
    {
        if((i % 10 + i / 10 % 10 + i / 100) == 5)
        {
            num++;
        }
    }
    return num;
}
```"
736,88,C++之for循环性质（II）,5ygxivtkq9wp,计算n以内（不包含n）的所有质数之和,139,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 计算n以内（不包含n）的所有素数之和
int SumOfPrime(int n)
{
    int i, k, sum = 0;
    for (i = 2; i < n; i++)
    {
        bool prime = true;
        for (k = 2; k <= i / 2; k++)
        {
            if (i % k == 0)
            {
                prime = false;
                break;
            }
        }
        if (prime)
            sum += i;
    }
    return sum;
}
```"
737,88,C++之for循环性质（II）,yjh6v72gws5f,求两个数的最大公约数和最小公倍数,140,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 求两个正整数的最大公约数
int Gcd(int a,int b)
{
    int i,j,k;

    if(a >= b)
        j = a;
    else
        j = b;

    for(i = j; i >= 1; i--)
    {
        if(a % i == 0 && b % i == 0)
        {
            k = i;
            break;
        }
    }
    return k;
}

// 求两个正整数的最小公倍数
int Lcm(int a,int b)
{
    int o,p,q;

    if(a >= b)
        p = b;
    else
        p = a;

    for(o = p; o >= 1; o--)
    {
        if(a % o == 0 && b % o == 0)
        {
            q = o;
            break;
        }
    }
    return (a * b) / q;
}
```"
738,90,C++之for循环应用（II）,x9stupwnr85q,百钱买百鸡问题,144,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    // 请在下面添加实现代码
    /******** Program ********/
    for(int c = 1; c <= 13; ++c)
    {
        for(int h = 1; h <= 18; ++h)
        {
            for(int s = 1; s <= 96; ++s)
            {
                if(7 * c + 5 * h + s / 3 - 100) 
                {
                    continue;
                }
                if(c + h + s - 100) 
                {
                    continue;
                }
                if(s % 3) 
                {
                    continue;
                }
                cout << ""雄鸡:"" << c << "", 母鸡:"" << h << "", 小鸡:"" << 100 - c - h << endl; 
            }
        }
    }
    /********** End **********/ 
}
```"
739,90,C++之for循环应用（II）,ut5ckx39fz4f,找出乒乓球比赛中3对赛手的名单,145,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    // 请在下面添加实现代码
    /******** Program ********/
    char i,j,k;
    for (i='X';i<='Z';i++)
    {
        for (j='X';j<='Z';j++)
        {
            if (i!=j)
            {
                for (k='X';k<='Z';k++)
                {
                    if (i!=k && j!=k)
                    {
                        if (i!='X' && k!='X' && k!='Z')
                        {
                            cout<<""A--""<<i<<""  B--""<<j<<""  C--""<<k<<endl;
                        }
                    }
                }
            }
        }
    }
    /********** End **********/
}
```"
740,90,C++之for循环应用（II）,qtgjfc26kp5a,计算球第n次落地时经过的距离和反弹的高度,146,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include <iostream>
using namespace std;

int main()
{
    int n;

    // 从命令行读入一个int型数值
    // 这一个数取自测试集的输入
    cin >> n;

    // 请在下面添加实现代码
    /******** Program ********/
    float a, c, d;
    d = -100;
    c = 100;

    for (a = 1; a <= n; a++)
    {
        d += c * 2;
        c = 0.5 * c;
    }
    cout << d << "" "" << c;
    /********** End **********/
}
```"
741,89,C++之for循环应用（I）,g4tprla8xj9w,计算舍罕王共需要多少立方的麦子赏赐他的宰相,141,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 计算舍罕王共需要多少立方的麦子赏赐他的宰相
double WheatNum ()
{
    /******** Program ********/
    double sum = 0, m3;

    for (int i = 0; i < 64; i++)
    {
        sum = sum + pow(2,i);
    }

    m3 = sum / (1.42 * pow(10,8));
    return m3;
    /********** End **********/
}
```"
742,89,C++之for循环应用（I）,uvf7sebhoxpl,判断一个不小于2的正整数是否为质数,142,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 判断一个不小于2的正整数是否为素数
int IsPrime(int n)
{
    int i;
    for(i = 2; i < n; i++)
    {
        if(n % i == 0)
        {
            return 0;
        }
    }
    return 1;
}
```"
743,89,C++之for循环应用（I）,ki6qmg8tjr5h,根据输入的行数n输出由*构成的‘V’字图形,143,"请将以下代码直接拷贝到右侧相应位置：
```cpp
#include<iostream>
using namespace std;

int main()
{
    int n, bn, ln;

    // 从命令行读入一个int型数值
    // 这一个数取自测试集的输入
    cin >> n;

    // 请在下面添加实现代码
    /******** Program ********/
    for (ln = 1; ln < n; ln++)
    {
        for (bn = 1; bn <= ln - 1; bn++)
        {
            cout<<"" "";
        }
        cout << ""**"";

        for (bn = 1; bn <= 2 * (n - ln - 1); bn++)
        {
            cout<<"" "";
        }
        cout << ""**"" << endl;
    }

    for (bn = 1; bn <= n-1; bn++)
    {
        cout << "" "";
    }
    cout << ""**"" << endl;
    /********** End **********/
}
```"
744,51,C++之整数性质判断,9spaufjmrbvz,判断一个整数是奇数还是偶数,37,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 判断整数的奇偶性
int OddOrEven(int n)
{
    int flag;
    flag = n % 2 == 0 ? 1 : 0;
    return flag;
}
```"
745,51,C++之整数性质判断,viczht3wfugf,判断一个年份是否为闰年,38,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 判断一个年份是否为闰年
int IsLeapYear(int year)
{
    int flag;
    flag = (((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))) == true ? 1 : 0;
    return flag;
}
```"
746,51,C++之整数性质判断,8pv67o5fygar,判断一个整数是否是2的幂,39,"请将以下代码直接拷贝到右侧相应位置：
```cpp
// 判断一个整数是否是2的幂
bool IsPowerOfTwo(int n)
{
    bool flag;
    flag = (n > 0 && ((n & (n - 1)) == 0 )) ?  true : false;
    return flag;
}
```"
747,4867,数据结构与算法 - 字符串匹配,6tfxwclfp8hi,实现朴素的字符串匹配,14341,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: April 2009
    copyright: Zhu En
    DO NOT distribute this code.
**************************************************************/

int FindSubStr(char* t, char* p)
/*
从字符串t查找子字符串p。
字符串以数值结尾，例如p=""str"",那么p[0]='s',p[1]='t',p[2]='r',p[3]=0。
采用朴素的匹配算法。
返回子字符串第一次出现的位置,例如t=""string ring"",p=""ring""，则返回2。
若没有找到，则返回-1。
*/
{
    // 请在此添加代码，补全函数FindSubStr
    /********** Begin *********/
    int i=0, j=0;
    while(p[i]!=0 && t[j]!=0) {
        if (p[i]==t[j]) {
            i ++;
            j ++;
        }
        else {
            j = j-i+1;
            i = 0;
        }
    }
    if (p[i] == 0) return j-i;
    else return -1;

    /********** End **********/
}

```"
748,4867,数据结构与算法 - 字符串匹配,2qcra97v5uzx,实现KMP字符串匹配,14342,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: 
    copyright: Zhu En
    DO NOT distribute this code without my permission.
**************************************************************/
//字符串 实现文件
//////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""kmp.h""
/////////////////////////////////////////////////////

void KmpGenNext(char* p, int* next)
//生成p的next数组, next数组长度大于等于字符串p的长度加1
{
    // 请在此添加代码，补全函数KmpGenNext
    /********** Begin *********/
    next[0]= -1;
    int k= -1;
    for (int i=1; p[i-1]!=0; i++) 
    {    
        while(k>=0&&p[k]!=p[i-1])   k=next[k];
        k=k+1;
        if (p[i]==p[k])  next[i]=next[k];
        else    next[i]=k;
    }
    /********** End   *********/
}


int KmpFindSubWithNext(char* t, char* p, int* next)
//从t中查找子串p的第一次出现的位置
//若找到，返回出现的位置，否则返回-1
{
	int i=0, j=0;
	while(p[i]!=0 && t[j]!=0)	{
		if(p[i]==t[j]) 	{ 
			i++;  
			j++; 
		}
		else  if (next[i]>=0) {
			i = next[i];
		}
		else  { 
			i=0;  
			j++; 
		}
	}
	if(p[i]==0)  return j-i; //found
	else  return -1;  //not found
}


```"
749,192,数据结构与算法 - 字符串匹配,hm9tf73nus8a,实现朴素的字符串匹配,10979,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: April 2009
    copyright: Zhu En
    DO NOT distribute this code.
**************************************************************/

int FindSubStr(char* t, char* p)
/*
从字符串t查找子字符串p。
字符串以数值结尾，例如p=""str"",那么p[0]='s',p[1]='t',p[2]='r',p[3]=0。
采用朴素的匹配算法。
返回子字符串第一次出现的位置,例如t=""string ring"",p=""ring""，则返回2。
若没有找到，则返回-1。
*/
{
    // 请在此添加代码，补全函数FindSubStr
    /********** Begin *********/
    int i=0, j=0;
    while(p[i]!=0 && t[j]!=0) {
        if (p[i]==t[j]) {
            i ++;
            j ++;
        }
        else {
            j = j-i+1;
            i = 0;
        }
    }
    if (p[i] == 0) return j-i;
    else return -1;

    /********** End **********/
}

```"
750,192,数据结构与算法 - 字符串匹配,epvarlw57kjf,实现KMP字符串匹配,10980,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: 
    copyright: Zhu En
    DO NOT distribute this code without my permission.
**************************************************************/
//字符串 实现文件
//////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""kmp.h""
/////////////////////////////////////////////////////

void KmpGenNext(char* p, int* next)
//生成p的next数组, next数组长度大于等于字符串p的长度加1
{
    // 请在此添加代码，补全函数KmpGenNext
    /********** Begin *********/
    next[0]= -1;
    int k= -1;
    for (int i=1; p[i-1]!=0; i++) 
    {    
        while(k>=0&&p[k]!=p[i-1])   k=next[k];
        k=k+1;
        if (p[i]==p[k])  next[i]=next[k];
        else    next[i]=k;
    }
    /********** End   *********/
}


int KmpFindSubWithNext(char* t, char* p, int* next)
//从t中查找子串p的第一次出现的位置
//若找到，返回出现的位置，否则返回-1
{
	int i=0, j=0;
	while(p[i]!=0 && t[j]!=0)	{
		if(p[i]==t[j]) 	{ 
			i++;  
			j++; 
		}
		else  if (next[i]>=0) {
			i = next[i];
		}
		else  { 
			i=0;  
			j++; 
		}
	}
	if(p[i]==0)  return j-i; //found
	else  return -1;  //not found
}


```"
751,4868,数据结构与算法 - 排序,bghxsnkt9fa3,实现直接插入排序,14343,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: April 2009
    copyright: Zhu En
    DO NOT distribute this code without my permission.
**************************************************************/
//排序算法实现文件
////////////////////////////////////////////////////
#include<stdio.h>
#include<stdlib.h>
#include""directInsSort.h""

void DirecInsSort(int* a, int n)
// direct insert sorting
{
    int i, k;

    for (i=1; i<n; i++)   {
        // 请在此添加代码，补全函数DirecInsSort
        /********** Begin *********/

		int temp=a[i];
        //find k to insert a[i] between a[k-1] and a[k]
        k=i;
        while (k-1>=0 && temp<a[k-1]) // k>0 means k-1>=0
        {   a[k]=a[k-1];  k--;   }
        a[k]=temp;
        /********** End **********/
    }
}

void SortPrint(int* a, int n)
{
    int i;
    printf(""sort result:"");
    for (i=0; i<n; i++)
        printf(""%d "", a[i]);
    //printf(""\n"");
}

```"
752,4868,数据结构与算法 - 排序,976obxycwlsn,实现快速排序,14344,"本关任务对应参考代码实现如下：
```cpp
/*********************************************
    date: April 2009
    copyright: Zhu En
    DO NOT distribute this code.
*********************************************/
//排序算法实现文件
//////////////////////////////////////////////

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include""quickSort.h""

void QSort__(int* a, int low, int high)
//快速排序私有函数，供QuickSort()调用
//在a[low:high]中选择一个中心值，用该中心值将a[low:high]分割为两部分
//然后对两个部分递归地进行该操作。
{   
    int i, j;  
    if(low>=high) return;

    Swap(a[low], a[rand()%(high-low+1)+low]); //select a pivot randomly

    i=low; j=high; 
    int temp=a[i];
    // 请在此添加代码，补全函数QSort__
    /********** Begin *********/
	while (i<j){
        while (i<j && temp<a[j]) j--;
            if(i<j)  a[i++]=a[j];
                while (i<j && a[i]<=temp) i++;
                    if(i<j)  a[j--]=a[i];
    }
    a[i]=temp;
    QSort__(a, low, i-1);
    QSort__(a, i+1, high);

    /********** End **********/
}

void QuickSort(int* a, int n)
//快速排序主函数
{
    srand((unsigned)time(0)); //for selecting the pivot randomly in QSort__().
    QSort__(a, 0, n-1);
}

void SortPrint(int* a, int n)
{
    int i;
    printf(""sort result:"");
    for(i=0;i<n;i++)
        printf(""% d"",a[i]);
    //printf(""\n"");
}
```"
753,206,数据结构与算法 - 排序,6bt3y2snge5v,实现直接插入排序,10981,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: April 2009
    copyright: Zhu En
    DO NOT distribute this code without my permission.
**************************************************************/
//排序算法实现文件
////////////////////////////////////////////////////
#include<stdio.h>
#include<stdlib.h>
#include""directInsSort.h""

void DirecInsSort(int* a, int n)
// direct insert sorting
{
    int i, k;

    for (i=1; i<n; i++)   {
        // 请在此添加代码，补全函数DirecInsSort
        /********** Begin *********/

		int temp=a[i];
        //find k to insert a[i] between a[k-1] and a[k]
        k=i;
        while (k-1>=0 && temp<a[k-1]) // k>0 means k-1>=0
        {   a[k]=a[k-1];  k--;   }
        a[k]=temp;
        /********** End **********/
    }
}

void SortPrint(int* a, int n)
{
    int i;
    printf(""sort result:"");
    for (i=0; i<n; i++)
        printf(""%d "", a[i]);
    //printf(""\n"");
}

```"
754,206,数据结构与算法 - 排序,h2vmxbaj54fs,实现快速排序,10982,"本关任务对应参考代码实现如下：
```cpp
/*********************************************
    date: April 2009
    copyright: Zhu En
    DO NOT distribute this code.
*********************************************/
//排序算法实现文件
//////////////////////////////////////////////

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include""quickSort.h""

void QSort__(int* a, int low, int high)
//快速排序私有函数，供QuickSort()调用
//在a[low:high]中选择一个中心值，用该中心值将a[low:high]分割为两部分
//然后对两个部分递归地进行该操作。
{   
    int i, j;  
    if(low>=high) return;

    Swap(a[low], a[rand()%(high-low+1)+low]); //select a pivot randomly

    i=low; j=high; 
    int temp=a[i];
    // 请在此添加代码，补全函数QSort__
    /********** Begin *********/
	while (i<j){
        while (i<j && temp<a[j]) j--;
            if(i<j)  a[i++]=a[j];
                while (i<j && a[i]<=temp) i++;
                    if(i<j)  a[j--]=a[i];
    }
    a[i]=temp;
    QSort__(a, low, i-1);
    QSort__(a, i+1, high);

    /********** End **********/
}

void QuickSort(int* a, int n)
//快速排序主函数
{
    srand((unsigned)time(0)); //for selecting the pivot randomly in QSort__().
    QSort__(a, 0, n-1);
}

void SortPrint(int* a, int n)
{
    int i;
    printf(""sort result:"");
    for(i=0;i<n;i++)
        printf(""% d"",a[i]);
    //printf(""\n"");
}
```"
755,4866,数据结构与算法 - 计算表达式,nx9yfuatqb57,栈的应用 - 计算中缀表达式,14339,"本关任务对应参考代码实现如下：
```cpp
/**********************************************************
	date: July 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**********************************************************/
#include <stdio.h>
#include <stdlib.h>
#include ""LnkStack.h""
#include ""Infix.h""

//////////////////////////////////////////////////////////////
void compute(LinkStack* so, LinkStack* sd)
//++++++++++++++++++++++++++++++++++++++++++++++
//so 运算符栈
//sd 操作数栈
//1 从运算符栈出栈一个运算符
//2 从操作数栈出栈两个操作数
//3 用出栈的运算符对出栈的操作数进行运算
//4 将运算结果进操作数栈
//+++++++++++++++++++++++++++++++++++++++++++++++
{
	T a,b,c,d;
	LS_Pop(so,c);
	LS_Pop(sd,a);
	LS_Pop(sd,b);
	if (c=='*') d=b*a;
	else if (c=='/') d=b/a;
	else if (c=='+') d=b+a;
	else if (c=='-') d=b-a;
	else printf(""never occur!"");
	LS_Push(sd, d);
}

double ComputeInfix(char* s)
//计算中缀表达式
{
    // 请在此添加代码，补全函数ComputeInfix，计算中缀表达式
    /********** Begin *********/


 int i=0;
    // 1
    LinkStack* so=LS_Create(); // 运算符栈
    LinkStack* sd=LS_Create(); //操作数栈
    // 2
    while(s[i]) {
        // 2.1
        if ('0'<=s[i] && s[i]<='9') {
            LS_Push(sd, s[i++]-48);
            continue;
        }
        // 2.2
        if(s[i]=='('||LS_IsEmpty(so)) {
            LS_Push(so, s[i++]); 
            continue;
        }
        // 2.3 
        if(s[i]==')') {
            T topitem;
            while(LS_Top(so,topitem) && topitem !='(' ) 
                compute(so, sd);
            LS_Pop(so,topitem);
            i++;
            continue;
        }
        // 2.4
        if(s[i]=='*'||s[i]=='/') {
            T c;
            LS_Top(so,c);
            if (c=='*' || c=='/') 
                compute(so, sd);
            LS_Push(so, s[i++]);
            continue;
        }
        // 2.5
        if(s[i]=='+'||s[i]=='-') {
            T topitem;
            while(LS_Top(so,topitem) && topitem !='(' ) 
                compute(so, sd);
            LS_Push(so, s[i++]);
            continue;
        }
    }
    // 3
    while(!LS_IsEmpty(so)) 
        compute(so, sd);
    T res;
    LS_Top(sd,res);
    LS_Free(so);
    LS_Free(sd);
    return res;


    /********** End **********/
}

```"
756,4866,数据结构与算法 - 计算表达式,nomckqszfly8,栈的应用 - 计算后缀表达式,14340,"本关任务对应参考代码实现如下：
```cpp
/**********************************************************
	date: July 2017
    copyright: Zhu En
    DO NOT distribute this code.
**********************************************************/
#include <stdio.h>
#include <stdlib.h>
#include ""LnkStack.h""
#include ""Postfix.h""

double ComputePostfix(char* s)
{
    // 请在此添加代码，补全函数ComputePostfix，计算后缀表达式
    /********** Begin *********/
    LinkStack* sd=LS_Create();
    int i=0;
    T k,top1,top2;
    while(s[i]) {
        switch (s[i]) {
        case '+':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top1+top2;
            LS_Push(sd,k);
            break;
        case '-':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top2-top1;
            LS_Push(sd,k);
            break;
        case '*':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top1*top2;
            LS_Push(sd,k);
            break;
        case '/':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top2/top1;
            LS_Push(sd,k);
            break;
        default:
            LS_Push(sd, (int)(s[i]-48));
        }
        i++;
    }
    T res;
    LS_Top(sd,res);
    LS_Free(sd);
    return res;
    /********** End **********/
}
```"
757,175,数据结构与算法 - 计算表达式,hmyqen5lburz,栈的应用 - 计算中缀表达式,10978,"本关任务对应参考代码实现如下：
```cpp
/**********************************************************
	date: July 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**********************************************************/
#include <stdio.h>
#include <stdlib.h>
#include ""LnkStack.h""
#include ""Infix.h""

//////////////////////////////////////////////////////////////
void compute(LinkStack* so, LinkStack* sd)
//++++++++++++++++++++++++++++++++++++++++++++++
//so 运算符栈
//sd 操作数栈
//1 从运算符栈出栈一个运算符
//2 从操作数栈出栈两个操作数
//3 用出栈的运算符对出栈的操作数进行运算
//4 将运算结果进操作数栈
//+++++++++++++++++++++++++++++++++++++++++++++++
{
	T a,b,c,d;
	LS_Pop(so,c);
	LS_Pop(sd,a);
	LS_Pop(sd,b);
	if (c=='*') d=b*a;
	else if (c=='/') d=b/a;
	else if (c=='+') d=b+a;
	else if (c=='-') d=b-a;
	else printf(""never occur!"");
	LS_Push(sd, d);
}

double ComputeInfix(char* s)
//计算中缀表达式
{
    // 请在此添加代码，补全函数ComputeInfix，计算中缀表达式
    /********** Begin *********/


 int i=0;
    // 1
    LinkStack* so=LS_Create(); // 运算符栈
    LinkStack* sd=LS_Create(); //操作数栈
    // 2
    while(s[i]) {
        // 2.1
        if ('0'<=s[i] && s[i]<='9') {
            LS_Push(sd, s[i++]-48);
            continue;
        }
        // 2.2
        if(s[i]=='('||LS_IsEmpty(so)) {
            LS_Push(so, s[i++]); 
            continue;
        }
        // 2.3 
        if(s[i]==')') {
            T topitem;
            while(LS_Top(so,topitem) && topitem !='(' ) 
                compute(so, sd);
            LS_Pop(so,topitem);
            i++;
            continue;
        }
        // 2.4
        if(s[i]=='*'||s[i]=='/') {
            T c;
            LS_Top(so,c);
            if (c=='*' || c=='/') 
                compute(so, sd);
            LS_Push(so, s[i++]);
            continue;
        }
        // 2.5
        if(s[i]=='+'||s[i]=='-') {
            T topitem;
            while(LS_Top(so,topitem) && topitem !='(' ) 
                compute(so, sd);
            LS_Push(so, s[i++]);
            continue;
        }
    }
    // 3
    while(!LS_IsEmpty(so)) 
        compute(so, sd);
    T res;
    LS_Top(sd,res);
    LS_Free(so);
    LS_Free(sd);
    return res;


    /********** End **********/
}

```"
758,175,数据结构与算法 - 计算表达式,c4goqzsef5r6,栈的应用 - 计算后缀表达式,10977,"本关任务对应参考代码实现如下：
```cpp
/**********************************************************
	date: July 2017
    copyright: Zhu En
    DO NOT distribute this code.
**********************************************************/
#include <stdio.h>
#include <stdlib.h>
#include ""LnkStack.h""
#include ""Postfix.h""

double ComputePostfix(char* s)
{
    // 请在此添加代码，补全函数ComputePostfix，计算后缀表达式
    /********** Begin *********/
    LinkStack* sd=LS_Create();
    int i=0;
    T k,top1,top2;
    while(s[i]) {
        switch (s[i]) {
        case '+':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top1+top2;
            LS_Push(sd,k);
            break;
        case '-':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top2-top1;
            LS_Push(sd,k);
            break;
        case '*':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top1*top2;
            LS_Push(sd,k);
            break;
        case '/':
            LS_Pop(sd,top1);
            LS_Pop(sd,top2);
            k=top2/top1;
            LS_Push(sd,k);
            break;
        default:
            LS_Push(sd, (int)(s[i]-48));
        }
        i++;
    }
    T res;
    LS_Top(sd,res);
    LS_Free(sd);
    return res;
    /********** End **********/
}
```"
759,4869,数据结构与算法 - 查找,f4k2b5ycis36,实现折半查找,14345,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: April 2009
    copyright: Zhu En
    DO NOT distribute this code.
**************************************************************/
//折半查找的顺序表 实现文件
//每个结点的数据是关键码
//////////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""BSlist.h""

BSeqList* BSL_Create(int size)
//创建一个顺序表
//与BSL_Free()配对
{
    BSeqList* blist=(BSeqList*)malloc(sizeof(BSeqList));
    blist->pkey = (int*)malloc(sizeof(int)*size);
    blist->max=size;
    blist->len=0;
    return blist;
}

void BSL_Free(BSeqList* blist)
//释放/删除顺序表
//与BSL_Create()配对
{
    free(blist->pkey);
    free(blist);
}

int BSL_FindKey(BSeqList* blist, int key)
//在排序的顺序表中查找关键码值为key的结点，返回结点的编号
//返回值大于等于0时表示找到值为key的结点的编号，-1表示没有找到
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    int k, r, m;
    k=0; r=blist->len-1;
    while (k<=r) {
        m=(k+r)>>1; //m=(k+r)/2
        if (key==blist->pkey[m]) return m;
        else
            if (key<blist->pkey[m])  r=m-1;
            else k=m+1;
    }
    return -1;
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
}

int BSL_InsKey(BSeqList* blist, int key)
//在排序的顺序表中插入一个值为key的结点
//返回值大于等于0时表示插入的位置, -1表示表满（无法插入）
{

    if (blist->len>=blist->max) return -1;

    int k, r, m;
    k=0; r=blist->len-1;

    //寻找插入位置
    while (k<=r) {
        m=(k+r)>>1; //m=(k+r)/2
        if (key == blist->pkey[m]) return -2;////若不允许插入已存在的值，则需要此行
        if (key<blist->pkey[m])  r=m-1;
        else k=m+1;
    }

    //插入位置为k, 腾出k号位置
    for (r=blist->len; r>k; r--) 
        blist->pkey[r]=blist->pkey[r-1];
    //key放入k号位置
    blist->pkey[k]=key;
    blist->len++;
    return k;
}

int BSL_DelKey(BSeqList* blist, int key)
//在排序的顺序表中删除值为key的结点, 
//存在值为x的结点则返回结点编号, 未找到返回－1
{
    int k=BSL_FindKey(blist, key);
    if (k<0) return -1;
    int i=k;
    while(i < blist->len-1) {
        blist->pkey[i] = blist->pkey[i+1];
        i++;
    }
    blist->len --;
    return k;
}

void BSL_Print(BSeqList* blist)
//打印整个顺序表
{
    if (blist->len==0) {
        printf(""The list is empty.\n"");
        return;
    }
    printf(""The list contains: "");
    for (int i=0; i<blist->len; i++) {
        printf(""%d  "", blist->pkey[i]);
    }
    printf(""\n"");
}
```"
760,4869,数据结构与算法 - 查找,bsjzhl9pkwx3,实现散列查找,14346,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include ""indLnkHash.h""

LHTable* ILH_Create(int n)
//创建散列表, n为表长度，最佳取值：n取小于等于数据个数的最大质数
{
    HNode* pn=(HNode*)malloc(sizeof(HNode)*n);
    for (int i=0; i<n; i++) {
        pn[i].key=0;
        pn[i].next=NULL;
    }
    LHTable* pt=(LHTable*)malloc(sizeof(LHTable));
    pt-> pn=pn;
    pt->n=n;
    return pt;
}

void ILH_Free(LHTable* pt)
//释放散列表
{
    if (pt==NULL) return;
    for (int i=0; i<pt->n; i++) {
        HNode* curr=pt->pn[i].next;
        while (curr) {
            HNode* next=curr->next;
            free(curr);
            curr=next;
        }
    }
    free(pt->pn);
    free(pt);
}

bool ILH_InsKey(LHTable* pt, int x)
//插入关键码x
//返回true，表示插入成功
//返回false，表示插入失败(关键码已经存在)
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    int d=x%pt->n;
    if (pt->pn[d].key==0) {
        pt->pn[d].key=x;
        return true;
    }
    else if (pt->pn[d].key==x) 
        return false;
    HNode* prev=&(pt->pn[d]);
    HNode* curr=pt->pn[d].next;
    while (curr && curr->key!=x) {prev=curr; curr=curr->next;}
    if (curr) return  false;
    HNode* pnode=(HNode*)malloc(sizeof(HNode));
    pnode->key=x;
    pnode->next=NULL;//pt->pn[d].next;
    prev->next=pnode;
    return true;
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
}

bool ILH_FindKey(LHTable* pt, int x)
//查找关键码x
//返回true表示找到
//返回false表示没找到
{
    int d=x%pt->n;
    if (pt->pn[d].key==0) {
        return false;
    }
    else if (pt->pn[d].key==x) 
        return true;

    HNode* curr=pt->pn[d].next;
    while (curr && curr->key!=x) curr=curr->next;

    if (curr) return  true;
    else return false;
}

bool ILH_DelKey(LHTable* pt, int x)
//删除关键码
//返回true表示该关键码存在，且成功删除
//返回false表示该关键码不存在
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    int d=x%pt->n;//关键码x的散列值d
    if (pt->pn[d].key==0) {
        return false;
    }
    else if (pt->pn[d].key==x)  {
        if (pt->pn[d].next ==NULL) 
            pt->pn[d].key=0;
        else {
            HNode* first=pt->pn[d].next;
            pt->pn[d].key=first->key;
            pt->pn[d].next=first->next;
            free(first);
        }
        return true;
    }
    HNode* prev=&(pt->pn[d]);
    HNode* curr=pt->pn[d].next;
    while (curr && curr->key!=x) {prev=curr; curr=curr->next;}
    if (curr==NULL) return false;
    prev->next=curr->next;
    free(curr);
    return true;
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
}

void ILH_Print(LHTable *pt)
{
    for (int i=0; i<pt->n; i++) {
        printf(""%5d:"", i);
        if (pt->pn[i].key) {
            printf(""%d"", pt->pn[i].key);
            HNode* curr=pt->pn[i].next;
            while (curr) {
                printf(""->%d"", curr->key);
                curr=curr->next;
            }
            printf(""\n"");
        }
        else 
            printf(""-\n"");
    }
}

```"
761,207,数据结构与算法 - 查找,xfz9lhcyki23,实现折半查找,10983,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: April 2009
    copyright: Zhu En
    DO NOT distribute this code.
**************************************************************/
//折半查找的顺序表 实现文件
//每个结点的数据是关键码
//////////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""BSlist.h""

BSeqList* BSL_Create(int size)
//创建一个顺序表
//与BSL_Free()配对
{
    BSeqList* blist=(BSeqList*)malloc(sizeof(BSeqList));
    blist->pkey = (int*)malloc(sizeof(int)*size);
    blist->max=size;
    blist->len=0;
    return blist;
}

void BSL_Free(BSeqList* blist)
//释放/删除顺序表
//与BSL_Create()配对
{
    free(blist->pkey);
    free(blist);
}

int BSL_FindKey(BSeqList* blist, int key)
//在排序的顺序表中查找关键码值为key的结点，返回结点的编号
//返回值大于等于0时表示找到值为key的结点的编号，-1表示没有找到
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    int k, r, m;
    k=0; r=blist->len-1;
    while (k<=r) {
        m=(k+r)>>1; //m=(k+r)/2
        if (key==blist->pkey[m]) return m;
        else
            if (key<blist->pkey[m])  r=m-1;
            else k=m+1;
    }
    return -1;
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
}

int BSL_InsKey(BSeqList* blist, int key)
//在排序的顺序表中插入一个值为key的结点
//返回值大于等于0时表示插入的位置, -1表示表满（无法插入）
{

    if (blist->len>=blist->max) return -1;

    int k, r, m;
    k=0; r=blist->len-1;

    //寻找插入位置
    while (k<=r) {
        m=(k+r)>>1; //m=(k+r)/2
        if (key == blist->pkey[m]) return -2;////若不允许插入已存在的值，则需要此行
        if (key<blist->pkey[m])  r=m-1;
        else k=m+1;
    }

    //插入位置为k, 腾出k号位置
    for (r=blist->len; r>k; r--) 
        blist->pkey[r]=blist->pkey[r-1];
    //key放入k号位置
    blist->pkey[k]=key;
    blist->len++;
    return k;
}

int BSL_DelKey(BSeqList* blist, int key)
//在排序的顺序表中删除值为key的结点, 
//存在值为x的结点则返回结点编号, 未找到返回－1
{
    int k=BSL_FindKey(blist, key);
    if (k<0) return -1;
    int i=k;
    while(i < blist->len-1) {
        blist->pkey[i] = blist->pkey[i+1];
        i++;
    }
    blist->len --;
    return k;
}

void BSL_Print(BSeqList* blist)
//打印整个顺序表
{
    if (blist->len==0) {
        printf(""The list is empty.\n"");
        return;
    }
    printf(""The list contains: "");
    for (int i=0; i<blist->len; i++) {
        printf(""%d  "", blist->pkey[i]);
    }
    printf(""\n"");
}
```"
762,207,数据结构与算法 - 查找,eoljs72qw3a8,实现散列查找,10984,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include ""indLnkHash.h""

LHTable* ILH_Create(int n)
//创建散列表, n为表长度，最佳取值：n取小于等于数据个数的最大质数
{
    HNode* pn=(HNode*)malloc(sizeof(HNode)*n);
    for (int i=0; i<n; i++) {
        pn[i].key=0;
        pn[i].next=NULL;
    }
    LHTable* pt=(LHTable*)malloc(sizeof(LHTable));
    pt-> pn=pn;
    pt->n=n;
    return pt;
}

void ILH_Free(LHTable* pt)
//释放散列表
{
    if (pt==NULL) return;
    for (int i=0; i<pt->n; i++) {
        HNode* curr=pt->pn[i].next;
        while (curr) {
            HNode* next=curr->next;
            free(curr);
            curr=next;
        }
    }
    free(pt->pn);
    free(pt);
}

bool ILH_InsKey(LHTable* pt, int x)
//插入关键码x
//返回true，表示插入成功
//返回false，表示插入失败(关键码已经存在)
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    int d=x%pt->n;
    if (pt->pn[d].key==0) {
        pt->pn[d].key=x;
        return true;
    }
    else if (pt->pn[d].key==x) 
        return false;
    HNode* prev=&(pt->pn[d]);
    HNode* curr=pt->pn[d].next;
    while (curr && curr->key!=x) {prev=curr; curr=curr->next;}
    if (curr) return  false;
    HNode* pnode=(HNode*)malloc(sizeof(HNode));
    pnode->key=x;
    pnode->next=NULL;//pt->pn[d].next;
    prev->next=pnode;
    return true;
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
}

bool ILH_FindKey(LHTable* pt, int x)
//查找关键码x
//返回true表示找到
//返回false表示没找到
{
    int d=x%pt->n;
    if (pt->pn[d].key==0) {
        return false;
    }
    else if (pt->pn[d].key==x) 
        return true;

    HNode* curr=pt->pn[d].next;
    while (curr && curr->key!=x) curr=curr->next;

    if (curr) return  true;
    else return false;
}

bool ILH_DelKey(LHTable* pt, int x)
//删除关键码
//返回true表示该关键码存在，且成功删除
//返回false表示该关键码不存在
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    int d=x%pt->n;//关键码x的散列值d
    if (pt->pn[d].key==0) {
        return false;
    }
    else if (pt->pn[d].key==x)  {
        if (pt->pn[d].next ==NULL) 
            pt->pn[d].key=0;
        else {
            HNode* first=pt->pn[d].next;
            pt->pn[d].key=first->key;
            pt->pn[d].next=first->next;
            free(first);
        }
        return true;
    }
    HNode* prev=&(pt->pn[d]);
    HNode* curr=pt->pn[d].next;
    while (curr && curr->key!=x) {prev=curr; curr=curr->next;}
    if (curr==NULL) return false;
    prev->next=curr->next;
    free(curr);
    return true;
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
}

void ILH_Print(LHTable *pt)
{
    for (int i=0; i<pt->n; i++) {
        printf(""%5d:"", i);
        if (pt->pn[i].key) {
            printf(""%d"", pt->pn[i].key);
            HNode* curr=pt->pn[i].next;
            while (curr) {
                printf(""->%d"", curr->key);
                curr=curr->next;
            }
            printf(""\n"");
        }
        else 
            printf(""-\n"");
    }
}

```"
763,4870,数据结构与算法 - 树,srjn5cg2axv3,由双遍历序列构造二叉树,14347,"```
///////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""ConstructTree.h""
/////////////////////////////////////////////////////////////


/*
InPreToTree(): 由前序遍历序列和中序遍历序列构造二叉树
前序序列为pa[p1:p2]
中序序列为ia[i1:i2]
返回所构造的二叉树的根指针
*/
TNode* InPreToTree(char *pa, char *ia, int p1, int p2, int i1, int i2)
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    if (i1>i2) return NULL;
     int k=0;
     while (i1+k<=i2&&pa[p1]!=ia[i1+k]) k=k+1; 
     if(i1+k>i2) {
         return NULL;
     }
     TNode* t=new TNode; 
     t->data=pa[p1];
     t->left=InPreToTree(pa,ia,p1+1,p1+k,i1,i1+k-1); 
     t->right=InPreToTree(pa,ia,p1+k+1,p2,i1+k+1,i2);
     return t;
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
} 

void PrintPostTravel(TNode* t)
{
	if(t==NULL) return;
	if(t->left) PrintPostTravel(t->left);
	if(t->right) PrintPostTravel(t->right);
	printf(""%c"", t->data);
}

void DeleteTree(TNode* t)
{
	if(t==NULL) return;
	if(t->left) DeleteTree(t->left);
	if(t->right) DeleteTree(t->right);
	delete t;
}
	 ```"
764,4870,数据结构与算法 - 树,gj9wonrb8mei,打印二叉树,14348,"```
///////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""PrintTree.h""
/////////////////////////////////////////////////////////////

/*=================================================
函数：TNode* LayersToTree(char *A, int n) 
功能：由补充虚结点（‘^’）的层序序列构造二叉树
参数：A: 补充了虚结点（‘^’）的层序序列
          n: 序列的长度
输出: 所构造的二叉树的根指针，NULL表示没有构造出二叉树
==================================================*/
TNode* LayersToTree(char *A, int n)
{
	TNode**  pnode;
	TNode* node;
	int i;
	if(n<=0)
		return NULL;
	pnode= new TNode*[n];
	for(i=0; i<n; i++){
		if(A[i]!='^'){
			node=new TNode;
			node->data=A[i];
			node->left=NULL;
			node->right=NULL;
			pnode[i]=node;
		}
		else 
			pnode[i]=NULL;
	}
	for(i=0; i<n; i++){
		if(pnode[i]==NULL) continue;
		if(2*(i+1)<=n && pnode[2*(i+1)-1]!=NULL)
			pnode[i]->left=pnode[2*(i+1)-1];
		if(2*(i+1)+1<=n && pnode[2*(i+1)]!=NULL)
			pnode[i]->right=pnode[2*(i+1)];
	}
	node=pnode[0];
	delete pnode;
	return node;
} 

void PrintTreeRootLeft(TNode* r, int layer)
//r是树中一棵子树的根，打印以结点r为根的子树，
//layer是r在树中所处的层,约定树的根结点的层号为1
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    const int W=5;
    int i,j;
    if (r==NULL) return;
    PrintTreeRootLeft(r->right, layer+1);
    for(i=1; i<layer; i++) {
        for (j=0;j<W;j++) printf(""%c"", '-');
    }
    for (j=0; j<W-1; j++) printf(""%c"",'-');
    printf(""%c\n"", r->data);
    PrintTreeRootLeft(r->left, layer+1);
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
}

void DeleteTree(TNode* t)
{
	if(t==NULL) return;
	if(t->left) DeleteTree(t->left);
	if(t->right) DeleteTree(t->right);
	delete t;
}
```"
765,208,数据结构与算法 - 树,uy8kxfvpwg5f,由双遍历序列构造二叉树,10987,"```
///////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""ConstructTree.h""
/////////////////////////////////////////////////////////////


/*
InPreToTree(): 由前序遍历序列和中序遍历序列构造二叉树
前序序列为pa[p1:p2]
中序序列为ia[i1:i2]
返回所构造的二叉树的根指针
*/
TNode* InPreToTree(char *pa, char *ia, int p1, int p2, int i1, int i2)
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    if (i1>i2) return NULL;
     int k=0;
     while (i1+k<=i2&&pa[p1]!=ia[i1+k]) k=k+1; 
     if(i1+k>i2) {
         return NULL;
     }
     TNode* t=new TNode; 
     t->data=pa[p1];
     t->left=InPreToTree(pa,ia,p1+1,p1+k,i1,i1+k-1); 
     t->right=InPreToTree(pa,ia,p1+k+1,p2,i1+k+1,i2);
     return t;
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
} 

void PrintPostTravel(TNode* t)
{
	if(t==NULL) return;
	if(t->left) PrintPostTravel(t->left);
	if(t->right) PrintPostTravel(t->right);
	printf(""%c"", t->data);
}

void DeleteTree(TNode* t)
{
	if(t==NULL) return;
	if(t->left) DeleteTree(t->left);
	if(t->right) DeleteTree(t->right);
	delete t;
}
	 ```"
766,208,数据结构与算法 - 树,ys3cq4fxpu7i,打印二叉树,10988,"```
///////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""PrintTree.h""
/////////////////////////////////////////////////////////////

/*=================================================
函数：TNode* LayersToTree(char *A, int n) 
功能：由补充虚结点（‘^’）的层序序列构造二叉树
参数：A: 补充了虚结点（‘^’）的层序序列
          n: 序列的长度
输出: 所构造的二叉树的根指针，NULL表示没有构造出二叉树
==================================================*/
TNode* LayersToTree(char *A, int n)
{
	TNode**  pnode;
	TNode* node;
	int i;
	if(n<=0)
		return NULL;
	pnode= new TNode*[n];
	for(i=0; i<n; i++){
		if(A[i]!='^'){
			node=new TNode;
			node->data=A[i];
			node->left=NULL;
			node->right=NULL;
			pnode[i]=node;
		}
		else 
			pnode[i]=NULL;
	}
	for(i=0; i<n; i++){
		if(pnode[i]==NULL) continue;
		if(2*(i+1)<=n && pnode[2*(i+1)-1]!=NULL)
			pnode[i]->left=pnode[2*(i+1)-1];
		if(2*(i+1)+1<=n && pnode[2*(i+1)]!=NULL)
			pnode[i]->right=pnode[2*(i+1)];
	}
	node=pnode[0];
	delete pnode;
	return node;
} 

void PrintTreeRootLeft(TNode* r, int layer)
//r是树中一棵子树的根，打印以结点r为根的子树，
//layer是r在树中所处的层,约定树的根结点的层号为1
{
    /*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    const int W=5;
    int i,j;
    if (r==NULL) return;
    PrintTreeRootLeft(r->right, layer+1);
    for(i=1; i<layer; i++) {
        for (j=0;j<W;j++) printf(""%c"", '-');
    }
    for (j=0; j<W-1; j++) printf(""%c"",'-');
    printf(""%c\n"", r->data);
    PrintTreeRootLeft(r->left, layer+1);
    /******END******/
    /*请不要修改[BEGIN,END]区域外的代码*/
}

void DeleteTree(TNode* t)
{
	if(t==NULL) return;
	if(t->left) DeleteTree(t->left);
	if(t->right) DeleteTree(t->right);
	delete t;
}
```"
767,4871,数据结构与算法 - 图,h59t7epycrao,实现图的宽度优先遍历,14349,"```
//Graph
///////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""Graph.h""
/////////////////////////////////////////////////////////////

Graph* Graph_Create(int n)
{
	Graph* g=(Graph*)malloc(sizeof(Graph));
	g->n=n;
	g->vetex=(char**)malloc(sizeof(char*)*n);
	int i;
	for (i=0; i<n; i++) g->vetex[i] = NULL;
	g->adj=(int*)malloc(sizeof(int)*n*n);
	int j;
	for(i=0; i<n; i++) {
		for(j=0; j<n; j++) {
			g->adj[i*n+j]=0;
		}
	}
	return g;
}

void Graph_Free(Graph* g)
{
	free(g->adj);
	int i;
	for (i=0; i<g->n; i++) free(g->vetex[i]);
	free(g->vetex);
	free(g);
}

int Graph_WidthFirst(Graph*g, int start, Edge* tree)
//从start号顶点出发宽度优先遍历，（编号从0开始）
//返回访问到的顶点数，
//tree[]输出遍历树
//返回的tree[0]是(-1, start), 
//真正的遍历树保存在tree[1..return-1], return是返回值
//顶点的访问次序依次为tree[0].to, tree[1].to,  ..., tree[return-1].to
//输入时，tree[]的长度至少为顶点数
//返回值是从start出发访问到的顶点数
{
	const int MAX=1000;
	Edge queue[MAX];
	int head=0, tail=0;
#define In__(a,b)  {queue[tail].from=a; queue[tail].to=b; tail=(tail+1)%MAX;}/////////
#define Out__(a,b)  {a=queue[head].from; b=queue[head].to; head=(head+1)%MAX;}//
#define QueueNotEmpty (head!=tail?1:0)///////////////////////////////////
#define HasEdge(i,j)  (g->adj[(i)*g->n+(j)]==1)

	char* visited=(char*)malloc(sizeof(char)*g->n);
	memset(visited, 0, sizeof(char)*g->n);

	int parent=-1;  
	int curr=start;
	In__(parent, curr); 
	int k=0; //已经访问的结点数
	/*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    while (QueueNotEmpty) {
        Out__(parent, curr); 
        if (visited[curr]) continue;
        visited[curr]=1;
        tree[k].from=parent; tree[k].to=curr; k++;
        int j;
        for (j=0; j<=g->n-1;j++) {
            if (HasEdge(curr,j) && !visited[j])In__(curr,j);
        }
    }    
    /*****END*******/
	return k;
#undef In__//////////////////////////////
#undef Out__///////////////////////////////
#undef QueueNotEmpty////////////////////////
#undef HasEdge
}
```"
768,4871,数据结构与算法 - 图,mi7jz4of39xa,实现图的深度优先遍历,14350,"```
//Graph
///////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""Graph.h""
/////////////////////////////////////////////////////////////
Graph* Graph_Create(int n)
{
	Graph* g=(Graph*)malloc(sizeof(Graph));
	g->n=n;
	g->vetex=(char**)malloc(sizeof(char*)*n);
	int i;
	for (i=0; i<n; i++) g->vetex[i] = NULL;
	g->adj=(int*)malloc(sizeof(int)*n*n);
	int j;
	for(i=0; i<n; i++) {
		for(j=0; j<n; j++) {
			g->adj[i*n+j]=0;
		}
	}
	return g;
}

void Graph_Free(Graph* g)
{
	free(g->adj);
	int i;
	for (i=0; i<g->n; i++) free(g->vetex[i]);
	free(g->vetex);
	free(g);
}

int Graph_DepthFirst(Graph*g, int start, Edge* tree)
//从start号顶点出发深度优先遍历，（编号从开始）
//返回访问到的顶点数，
//tree[]输出遍历树
//返回的tree[0]是(-1, start), 
//真正的遍历树保存在tree[1..return-1], return是返回值
//顶点的访问次序依次为tree[0].to, tree[1].to, ..., tree[return-1].to
//输入时，tree[]的长度至少为顶点数
//返回值是从start出发访问到的顶点数
{
	/*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
const int MAX=1000;
    Edge stack[MAX];
    int top=-1;
#define Push__(a,b)  {top++; stack[top].from=a; stack[top].to=b;}////
#define Pop__(a,b)  {a=stack[top].from; b=stack[top].to; top--;}///////
#define StakNotEmpty (top>=0?1:0)////
#define HasEdge(i,j)  (g->adj[(i)*g->n+(j)]==1)
    char* visited=(char*)malloc(sizeof(char)*g->n);
    memset(visited, 0, sizeof(char)*g->n);
    int parent=-1;  
    int curr=start;
    Push__(parent, curr); 
    int k=0; //已经访问的结点数
    while (StakNotEmpty) {
        Pop__(parent, curr); 
        if (visited[curr]) continue;
        visited[curr]=1;
        tree[k].from=parent; tree[k].to=curr; k++;
        int j;
        for (j=g->n-1; j>=0; j--) {
            if (HasEdge(curr,j) && !visited[j]) Push__(curr,j);
        }
    }
    free(visited);
    return k;
#undef Push__////////////
#undef Pop__///////////////
#undef StakNotEmpty//////////////
#undef HasEdge
    /*****END*******/
}
```"
769,209,数据结构与算法 - 图,5ehrfi3akx2l,实现图的宽度优先遍历,10989,"```
//Graph
///////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""Graph.h""
/////////////////////////////////////////////////////////////

Graph* Graph_Create(int n)
{
	Graph* g=(Graph*)malloc(sizeof(Graph));
	g->n=n;
	g->vetex=(char**)malloc(sizeof(char*)*n);
	int i;
	for (i=0; i<n; i++) g->vetex[i] = NULL;
	g->adj=(int*)malloc(sizeof(int)*n*n);
	int j;
	for(i=0; i<n; i++) {
		for(j=0; j<n; j++) {
			g->adj[i*n+j]=0;
		}
	}
	return g;
}

void Graph_Free(Graph* g)
{
	free(g->adj);
	int i;
	for (i=0; i<g->n; i++) free(g->vetex[i]);
	free(g->vetex);
	free(g);
}

int Graph_WidthFirst(Graph*g, int start, Edge* tree)
//从start号顶点出发宽度优先遍历，（编号从0开始）
//返回访问到的顶点数，
//tree[]输出遍历树
//返回的tree[0]是(-1, start), 
//真正的遍历树保存在tree[1..return-1], return是返回值
//顶点的访问次序依次为tree[0].to, tree[1].to,  ..., tree[return-1].to
//输入时，tree[]的长度至少为顶点数
//返回值是从start出发访问到的顶点数
{
	const int MAX=1000;
	Edge queue[MAX];
	int head=0, tail=0;
#define In__(a,b)  {queue[tail].from=a; queue[tail].to=b; tail=(tail+1)%MAX;}/////////
#define Out__(a,b)  {a=queue[head].from; b=queue[head].to; head=(head+1)%MAX;}//
#define QueueNotEmpty (head!=tail?1:0)///////////////////////////////////
#define HasEdge(i,j)  (g->adj[(i)*g->n+(j)]==1)

	char* visited=(char*)malloc(sizeof(char)*g->n);
	memset(visited, 0, sizeof(char)*g->n);

	int parent=-1;  
	int curr=start;
	In__(parent, curr); 
	int k=0; //已经访问的结点数
	/*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
    while (QueueNotEmpty) {
        Out__(parent, curr); 
        if (visited[curr]) continue;
        visited[curr]=1;
        tree[k].from=parent; tree[k].to=curr; k++;
        int j;
        for (j=0; j<=g->n-1;j++) {
            if (HasEdge(curr,j) && !visited[j])In__(curr,j);
        }
    }    
    /*****END*******/
	return k;
#undef In__//////////////////////////////
#undef Out__///////////////////////////////
#undef QueueNotEmpty////////////////////////
#undef HasEdge
}
```"
770,209,数据结构与算法 - 图,752tp96xzrgw,实现图的深度优先遍历,10990,"```
//Graph
///////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""Graph.h""
/////////////////////////////////////////////////////////////
Graph* Graph_Create(int n)
{
	Graph* g=(Graph*)malloc(sizeof(Graph));
	g->n=n;
	g->vetex=(char**)malloc(sizeof(char*)*n);
	int i;
	for (i=0; i<n; i++) g->vetex[i] = NULL;
	g->adj=(int*)malloc(sizeof(int)*n*n);
	int j;
	for(i=0; i<n; i++) {
		for(j=0; j<n; j++) {
			g->adj[i*n+j]=0;
		}
	}
	return g;
}

void Graph_Free(Graph* g)
{
	free(g->adj);
	int i;
	for (i=0; i<g->n; i++) free(g->vetex[i]);
	free(g->vetex);
	free(g);
}

int Graph_DepthFirst(Graph*g, int start, Edge* tree)
//从start号顶点出发深度优先遍历，（编号从开始）
//返回访问到的顶点数，
//tree[]输出遍历树
//返回的tree[0]是(-1, start), 
//真正的遍历树保存在tree[1..return-1], return是返回值
//顶点的访问次序依次为tree[0].to, tree[1].to, ..., tree[return-1].to
//输入时，tree[]的长度至少为顶点数
//返回值是从start出发访问到的顶点数
{
	/*请在BEGIN和END之间实现你的代码*/
    /*****BEGIN*****/
const int MAX=1000;
    Edge stack[MAX];
    int top=-1;
#define Push__(a,b)  {top++; stack[top].from=a; stack[top].to=b;}////
#define Pop__(a,b)  {a=stack[top].from; b=stack[top].to; top--;}///////
#define StakNotEmpty (top>=0?1:0)////
#define HasEdge(i,j)  (g->adj[(i)*g->n+(j)]==1)
    char* visited=(char*)malloc(sizeof(char)*g->n);
    memset(visited, 0, sizeof(char)*g->n);
    int parent=-1;  
    int curr=start;
    Push__(parent, curr); 
    int k=0; //已经访问的结点数
    while (StakNotEmpty) {
        Pop__(parent, curr); 
        if (visited[curr]) continue;
        visited[curr]=1;
        tree[k].from=parent; tree[k].to=curr; k++;
        int j;
        for (j=g->n-1; j>=0; j--) {
            if (HasEdge(curr,j) && !visited[j]) Push__(curr,j);
        }
    }
    free(visited);
    return k;
#undef Push__////////////
#undef Pop__///////////////
#undef StakNotEmpty//////////////
#undef HasEdge
    /*****END*******/
}
```"
771,70,数据结构与算法 - 线性表,3ue9khnfrpzi,实现一个顺序存储的线性表,10936,"本关任务对应的参考代码实现如下：
```cpp
/*************************************************************
    date: April 2017
    copyright: Zhu En
    DO NOT distribute this code without my permission.
**************************************************************/
// 顺序表操作实现文件
//////////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""Seqlist.h""

SeqList* SL_Create(int maxlen)
// 创建一个顺序表
// 与SqLst_Free()配对
{
	SeqList* slist=(SeqList*)malloc(sizeof(SeqList));
	slist->data = (T*)malloc(sizeof(T)*maxlen);
	slist->max=maxlen;
	slist->len=0;
	return slist;
}

void SL_Free(SeqList* slist)
// 释放/删除 顺序表
// 与SqLst_Create()配对
{
	free(slist->data);
	free(slist);
}

void SL_MakeEmpty(SeqList* slist)
// 置为空表
{
	slist->len=0;
}

int SL_Length(SeqList* slist)
// 获取长度
{
	return slist->len;
}

bool SL_IsEmpty(SeqList* slist)
// 判断顺序表是否空
{
	return 0==slist->len;
}

bool SL_IsFull(SeqList* slist)
// 判断顺序表是否满
{
	return slist->len==slist->max;
}

T SL_GetAt(SeqList* slist, int i)
// 获取顺序表slist的第i号结点数据
// 返回第i号结点的值
{
	if(i<0||i>=slist->len) {
		printf(""SL_GetAt(): location error when reading elements of the slist!\n"");		
		SL_Free(slist);
		exit(0);
	}
	else 
		return slist->data[i];
}

void SL_SetAt(SeqList* slist, int i, T x)
// 设置第i号结点的值（对第i号结点的数据进行写）
{
	if(i<0||i>=slist->len) {
		printf(""SL_SetAt(): location error when setting elements of the slist!\n"");		
		SL_Free(slist);
		exit(0);
	}
	else 
		slist->data[i]=x;
}

bool SL_InsAt(SeqList* slist, int i, T x)
// 在顺序表的位置i插入结点x, 插入d[i]之前
// i的有效范围[0,plist->len]
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
if (i<0 || i>slist->len || slist->len==slist->max) {
        printf(""SL_InsAt(): location error, or slist full.\n"");
        return false;
    }
    for (int j=slist->len; j>=i+1; j--) {
        slist->data[j]=slist->data[j-1];
    }
    slist->data[i]=x;
    slist->len++;
    return true;

    /********** End **********/
}

T SL_DelAt(SeqList* slist, int i)
// 删除顺序表plist的第i号结点
// i的有效范围应在[0,plist->len)内，否则会产生异常或错误。
// 返回被删除的数据元素的值。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
 if (i<0 || i>=slist->len) {
        printf(""SL_DelAt(): location error!\n"");
        SL_Free(slist);
        exit(0);
    }
    T res=slist->data[i];
    for (int j=i; j<slist->len-1; j++) {
        slist->data[j] = slist->data[j+1];
    }
    slist->len--;
    return res;

    /********** End **********/
}

int SL_FindValue(SeqList* slist, T x)
// 在顺序表表中查找第一个值为x的结点，返回结点的编号
// 返回值大于等于0时表示找到值为x的结点的编号，-1表示没有找到
{
	int i=0;
	while(i<slist->len && slist->data[i]!=x) i++;
	if (i<slist->len) return i;
	else return -1;
}

int SL_DelValue(SeqList* slist, T x)
// 删除第一个值为x的结点,
// 存在值为x的结点则返回结点编号, 未找到返回－1
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
int i=SL_FindValue(slist, x);
    if (i>=0) SL_DelAt(slist, i);
    return i;

    /********** End **********/
}

void SL_Print(SeqList* slist)
// 打印整个顺序表
{
	if (slist->len==0) {
		printf(""The slist is empty.\n"");		
		return;
	}

	//printf(""The slist contains: "");
	for (int i=0; i<slist->len; i++) {
		printf(""%d  "", slist->data[i]);
	}

	printf(""\n"");	
	
}
```"
772,70,数据结构与算法 - 线性表,iquj4gzsx6tb,实现一个连接存储的线性表,10937,"本关任务对应的参考代码实现如下：
```cpp
/*************************************************************
    date: June 2017
    copyright: Zhu En
    DO NOT distribute this code without my permission.
**************************************************************/
// 单链表实现文件

#include <stdio.h>
#include <stdlib.h>
#include ""LinkList.h""

// 1）
LinkList* LL_Create()
// 创建一个链接存储的线性表，初始为空表，返回llist指针。
{
    LinkList* llist=(LinkList*)malloc(sizeof(LinkList));
    llist->front=NULL;
    llist->rear=NULL;
    llist->pre=NULL;
    llist->curr=NULL;
    llist->position=0;
    llist->len=0;
    return llist;
}

// 2）	
void LL_Free(LinkList* llist)
// 释放链表的结点，然后释放llist所指向的结构。
{
    LinkNode* node=llist->front;
    LinkNode* nextnode;
    while(node){
        nextnode=node->next;
        free(node);
        node=nextnode;
    }
    free(llist);
}

// 3）	
void LL_MakeEmpty(LinkList* llist)
// 将当前线性表变为一个空表，因此需要释放所有结点。
{
    LinkNode* node=llist->front;
    LinkNode* nextnode;
    while(node){
        nextnode=node->next;
        free(node);
        node=nextnode;
    }
    llist->front=NULL;
    llist->rear=NULL;
    llist->pre=NULL;
    llist->curr=NULL;
    llist->position=0;
    llist->len=0;
}

// 4）	
int LL_Length(LinkList* llist)
// 返回线性表的当前长度。
{
    return llist->len;
}

// 5）	
bool LL_IsEmpty(LinkList* llist)
// 若当前线性表是空表，则返回true，否则返回TRUE。
{
    return llist->len==0;
}

// 6）  
bool LL_SetPosition(LinkList* llist, int i)
// 设置线性表的当前位置为i号位置。
// 设置成功，则返回true，否则返回false（线性表为空，或i不在有效的返回）
// 假设线性表当前长度为len，那么i的有效范围为[0,len]
{	
    int k;
    /* 若链表为空，则返回*/
    if (llist->len==0) return false;

    /*若位置越界*/
    if( i < 0 || i > llist->len)
    {	printf(""LL_SetPosition(): position error"");
        return false;
    }

    /* 寻找对应结点*/
    llist->curr = llist->front;
    llist->pre = NULL;
    llist->position = 0;
    for ( k = 0; k < i; k++)	{
        llist->position++;
        llist->pre = llist->curr;
        llist->curr = (llist->curr)->next;
    }
    
    /* 返回当前结点位置*/
    return true;
}

// 7)	
int LL_GetPosition(LinkList* llist)
// 获取线性表的当前位置结点的编号
{
    return llist->position;
}

// 8）	
bool LL_NextPosition(LinkList* llist)
// 设置线性表的当前位置的下一个位置为当前位置。
// 设置成功，则返回true，否则返回false（线性表为空，或当前位置为表尾）
{
    if (llist->position >= 0 && llist->position < llist->len)
    /* 若当前结点存在，则将其后继结点设置为当前结点*/
    {
        llist->position++;
        llist->pre = llist->curr;
        llist->curr = llist->curr->next;
        return true;
    }
    else 
        return false;
}

// 9）	
T LL_GetAt(LinkList* llist)
// 返回线性表的当前位置的数据元素的值。
{
    if(llist->curr==NULL)
    {
        printf(""LL_GetAt(): Empty list, or End of the List.\n"");
        LL_Free(llist);
        exit(1);
	}
    return llist->curr->data;
}

// 10）	
void LL_SetAt(LinkList* llist, T x)
// 将线性表的当前位置的数据元素的值修改为x。
{
    if(llist->curr==NULL)
    {
        printf(""LL_SetAt(): Empty list, or End of the List.\n"");
        LL_Free(llist);
        exit(1);
    }
    llist->curr->data=x;
}

// 11）	
bool LL_InsAt(LinkList* llist, T x)
// 在线性表的当前位置之前插入数据元素x。当前位置指针指向新数据元素结点。
// 若插入失败，返回false，否则返回true。
{	
    LinkNode *newNode=(LinkNode*)malloc(sizeof(LinkNode));
    if (newNode==NULL) return false;

    newNode->data=x;

    if (llist->len==0){
        /* 在空表中插入*/
        newNode->next=NULL;
        llist->front = llist->rear = newNode;
	}
    //当前位置为表头
    else if (llist->pre==NULL)
    {
        /* 在表头结点处插入*/
        newNode->next = llist->front;
        llist->front = newNode;
    }
    else {  
        /* 在链表的中间位置或表尾后的位置插入*/
        newNode->next = llist->curr;
        llist->pre->next=newNode;
    }
    //插入在表尾后
    if (llist->pre==llist->rear)
        llist->rear=newNode;
    /* 增加链表的大小*/
    llist->len++;
    /* 新插入的结点为当前结点*/
    llist->curr = newNode;
    return true;
}

// 12）	
bool LL_InsAfter(LinkList* llist, T x)
// 在线性表的当前位置之后插入数据元素x。空表允许插入。当前位置指针将指向新结点。
// 若插入失败，返回false，否则返回true。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
     LinkNode *newNode=(LinkNode*)malloc(sizeof(LinkNode));
    if (newNode==NULL) return false;
    newNode->data=x;
    if (llist->len==0)    {
        /* 在空表中插入*/
        newNode->next=NULL;
        llist->front = llist->rear = newNode;
    }
    else if (llist->curr == llist->rear || llist->curr == NULL)    {
        /* 在尾结点后插入*/
        newNode->next = NULL;
        llist->rear->next=newNode;
        llist->pre=llist->rear;
        llist->rear=newNode;
        llist->position=llist->len;
    }
    else{
        /* 在中间位置插入*/
        newNode->next = llist->curr->next;
        llist->curr->next=newNode;
        llist->pre=llist->curr;
        llist->position ++;
    }
    /* 增加链表的大小*/
    llist->len ++;
    /* 新插入的结点为当前结点*/
    llist->curr = newNode;
    return true;



    /********** End **********/
}

// 13）	
bool LL_DelAt(LinkList* llist)
// 删除线性表的当前位置的数据元素结点。
// 若删除失败（为空表，或当前位置为尾结点之后），则返回false，否则返回true。
{	
    LinkNode *oldNode;
    /* 若表为空或已到表尾之后，则给出错误提示并返回*/
    if (llist->curr==NULL)
    {	
        printf(""LL_DelAt(): delete a node that does not exist.\n"");
        return false;
    }
    oldNode=llist->curr;
    /* 删除的是表头结点*/
    if (llist->pre==NULL)
    {	
        llist->front = oldNode->next;
    }
    /* 删除的是表中或表尾结点*/
    else if(llist->curr!=NULL){
        llist->pre->next = oldNode->next;
    }
    if (oldNode == llist->rear)	{
        /* 删除的是表尾结点，则修改表尾指针和当前结点位置值*/
        llist->rear = llist->pre;
    }

    /* 后继结点作为新的当前结点*/
    llist->curr = oldNode->next;

    /* 释放原当前结点*/
    free(oldNode);

    /* 链表大小减*/
    llist->len --;
    return true;
}

// 14）	
bool LL_DelAfter(LinkList* llist)
// 删除线性表的当前位置的后面那个数据元素。
// 若删除失败（为空表，或当前位置时表尾），则返回false，否则返回true。
{
    LinkNode *oldNode;
    /* 若表为空或已到表尾，则给出错误提示并返回*/
    if (llist->curr==NULL || llist->curr== llist->rear)
    {
        printf(""LL_DelAfter():  delete a node that does not exist.\n"");
        return false;
    }
    /* 保存被删除结点的指针并从链表中删除该结点*/
    oldNode = llist->curr->next;
    llist->curr->next=oldNode->next;
    
    if (oldNode == llist->rear)
        /* 删除的是表尾结点*/
        llist->rear = llist->curr;
    /* 释放被删除结点*/
    free(oldNode);
    /* 链表大小减*/
    llist->len --;
    return true;
}

// 15）	
int LL_FindValue(LinkList* llist, T x)
// 找到线性表中第一个值为x的数据元素的编号。
// 返回值-1表示没有找到，返回值>=0表示编号。
{
    LinkNode* p=llist->front;
    int idx=0;
    while(p!=NULL && p->data!=x) {
        idx++;
        p = p->next;
    }
    if (idx>=llist->len) return -1;
    else return idx;
}

// 16）	
int LL_DelValue(LinkList* llist, T x)
// 删除第一个值为x的数据元素，返回该数据元素的编号。如果不存在值为x的数据元素，则返回-1.
{
    int idx=LL_FindValue(llist, x);
    if (idx<0) return -1;
    LL_SetPosition(llist, idx);
    LL_DelAt(llist);
    return idx;
}

// 17）	
void LL_Print(LinkList* llist)
// 打印整个线性表。
{
    LinkNode* node=llist->front;
    while (node) {
        printf(""%d "", node->data);
        node=node->next;
    }
    printf(""\n"");
}

```"
773,4861,数据结构与算法 - 线性表,98i4nhvfqy7e,实现一个顺序存储的线性表,14329,"本关任务对应的参考代码实现如下：
```cpp
/*************************************************************
    date: April 2017
    copyright: Zhu En
    DO NOT distribute this code without my permission.
**************************************************************/
// 顺序表操作实现文件
//////////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""Seqlist.h""

SeqList* SL_Create(int maxlen)
// 创建一个顺序表
// 与SqLst_Free()配对
{
	SeqList* slist=(SeqList*)malloc(sizeof(SeqList));
	slist->data = (T*)malloc(sizeof(T)*maxlen);
	slist->max=maxlen;
	slist->len=0;
	return slist;
}

void SL_Free(SeqList* slist)
// 释放/删除 顺序表
// 与SqLst_Create()配对
{
	free(slist->data);
	free(slist);
}

void SL_MakeEmpty(SeqList* slist)
// 置为空表
{
	slist->len=0;
}

int SL_Length(SeqList* slist)
// 获取长度
{
	return slist->len;
}

bool SL_IsEmpty(SeqList* slist)
// 判断顺序表是否空
{
	return 0==slist->len;
}

bool SL_IsFull(SeqList* slist)
// 判断顺序表是否满
{
	return slist->len==slist->max;
}

T SL_GetAt(SeqList* slist, int i)
// 获取顺序表slist的第i号结点数据
// 返回第i号结点的值
{
	if(i<0||i>=slist->len) {
		printf(""SL_GetAt(): location error when reading elements of the slist!\n"");		
		SL_Free(slist);
		exit(0);
	}
	else 
		return slist->data[i];
}

void SL_SetAt(SeqList* slist, int i, T x)
// 设置第i号结点的值（对第i号结点的数据进行写）
{
	if(i<0||i>=slist->len) {
		printf(""SL_SetAt(): location error when setting elements of the slist!\n"");		
		SL_Free(slist);
		exit(0);
	}
	else 
		slist->data[i]=x;
}

bool SL_InsAt(SeqList* slist, int i, T x)
// 在顺序表的位置i插入结点x, 插入d[i]之前
// i的有效范围[0,plist->len]
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
if (i<0 || i>slist->len || slist->len==slist->max) {
        printf(""SL_InsAt(): location error, or slist full.\n"");
        return false;
    }
    for (int j=slist->len; j>=i+1; j--) {
        slist->data[j]=slist->data[j-1];
    }
    slist->data[i]=x;
    slist->len++;
    return true;

    /********** End **********/
}

T SL_DelAt(SeqList* slist, int i)
// 删除顺序表plist的第i号结点
// i的有效范围应在[0,plist->len)内，否则会产生异常或错误。
// 返回被删除的数据元素的值。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
 if (i<0 || i>=slist->len) {
        printf(""SL_DelAt(): location error!\n"");
        SL_Free(slist);
        exit(0);
    }
    T res=slist->data[i];
    for (int j=i; j<slist->len-1; j++) {
        slist->data[j] = slist->data[j+1];
    }
    slist->len--;
    return res;

    /********** End **********/
}

int SL_FindValue(SeqList* slist, T x)
// 在顺序表表中查找第一个值为x的结点，返回结点的编号
// 返回值大于等于0时表示找到值为x的结点的编号，-1表示没有找到
{
	int i=0;
	while(i<slist->len && slist->data[i]!=x) i++;
	if (i<slist->len) return i;
	else return -1;
}

int SL_DelValue(SeqList* slist, T x)
// 删除第一个值为x的结点,
// 存在值为x的结点则返回结点编号, 未找到返回－1
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
int i=SL_FindValue(slist, x);
    if (i>=0) SL_DelAt(slist, i);
    return i;

    /********** End **********/
}

void SL_Print(SeqList* slist)
// 打印整个顺序表
{
	if (slist->len==0) {
		printf(""The slist is empty.\n"");		
		return;
	}

	//printf(""The slist contains: "");
	for (int i=0; i<slist->len; i++) {
		printf(""%d  "", slist->data[i]);
	}

	printf(""\n"");	
	
}
```"
774,4861,数据结构与算法 - 线性表,leyo8g7cr6u4,实现一个连接存储的线性表,14330,"本关任务对应的参考代码实现如下：
```cpp
/*************************************************************
    date: June 2017
    copyright: Zhu En
    DO NOT distribute this code without my permission.
**************************************************************/
// 单链表实现文件

#include <stdio.h>
#include <stdlib.h>
#include ""LinkList.h""

// 1）
LinkList* LL_Create()
// 创建一个链接存储的线性表，初始为空表，返回llist指针。
{
    LinkList* llist=(LinkList*)malloc(sizeof(LinkList));
    llist->front=NULL;
    llist->rear=NULL;
    llist->pre=NULL;
    llist->curr=NULL;
    llist->position=0;
    llist->len=0;
    return llist;
}

// 2）	
void LL_Free(LinkList* llist)
// 释放链表的结点，然后释放llist所指向的结构。
{
    LinkNode* node=llist->front;
    LinkNode* nextnode;
    while(node){
        nextnode=node->next;
        free(node);
        node=nextnode;
    }
    free(llist);
}

// 3）	
void LL_MakeEmpty(LinkList* llist)
// 将当前线性表变为一个空表，因此需要释放所有结点。
{
    LinkNode* node=llist->front;
    LinkNode* nextnode;
    while(node){
        nextnode=node->next;
        free(node);
        node=nextnode;
    }
    llist->front=NULL;
    llist->rear=NULL;
    llist->pre=NULL;
    llist->curr=NULL;
    llist->position=0;
    llist->len=0;
}

// 4）	
int LL_Length(LinkList* llist)
// 返回线性表的当前长度。
{
    return llist->len;
}

// 5）	
bool LL_IsEmpty(LinkList* llist)
// 若当前线性表是空表，则返回true，否则返回TRUE。
{
    return llist->len==0;
}

// 6）  
bool LL_SetPosition(LinkList* llist, int i)
// 设置线性表的当前位置为i号位置。
// 设置成功，则返回true，否则返回false（线性表为空，或i不在有效的返回）
// 假设线性表当前长度为len，那么i的有效范围为[0,len]
{	
    int k;
    /* 若链表为空，则返回*/
    if (llist->len==0) return false;

    /*若位置越界*/
    if( i < 0 || i > llist->len)
    {	printf(""LL_SetPosition(): position error"");
        return false;
    }

    /* 寻找对应结点*/
    llist->curr = llist->front;
    llist->pre = NULL;
    llist->position = 0;
    for ( k = 0; k < i; k++)	{
        llist->position++;
        llist->pre = llist->curr;
        llist->curr = (llist->curr)->next;
    }
    
    /* 返回当前结点位置*/
    return true;
}

// 7)	
int LL_GetPosition(LinkList* llist)
// 获取线性表的当前位置结点的编号
{
    return llist->position;
}

// 8）	
bool LL_NextPosition(LinkList* llist)
// 设置线性表的当前位置的下一个位置为当前位置。
// 设置成功，则返回true，否则返回false（线性表为空，或当前位置为表尾）
{
    if (llist->position >= 0 && llist->position < llist->len)
    /* 若当前结点存在，则将其后继结点设置为当前结点*/
    {
        llist->position++;
        llist->pre = llist->curr;
        llist->curr = llist->curr->next;
        return true;
    }
    else 
        return false;
}

// 9）	
T LL_GetAt(LinkList* llist)
// 返回线性表的当前位置的数据元素的值。
{
    if(llist->curr==NULL)
    {
        printf(""LL_GetAt(): Empty list, or End of the List.\n"");
        LL_Free(llist);
        exit(1);
	}
    return llist->curr->data;
}

// 10）	
void LL_SetAt(LinkList* llist, T x)
// 将线性表的当前位置的数据元素的值修改为x。
{
    if(llist->curr==NULL)
    {
        printf(""LL_SetAt(): Empty list, or End of the List.\n"");
        LL_Free(llist);
        exit(1);
    }
    llist->curr->data=x;
}

// 11）	
bool LL_InsAt(LinkList* llist, T x)
// 在线性表的当前位置之前插入数据元素x。当前位置指针指向新数据元素结点。
// 若插入失败，返回false，否则返回true。
{	
    LinkNode *newNode=(LinkNode*)malloc(sizeof(LinkNode));
    if (newNode==NULL) return false;

    newNode->data=x;

    if (llist->len==0){
        /* 在空表中插入*/
        newNode->next=NULL;
        llist->front = llist->rear = newNode;
	}
    //当前位置为表头
    else if (llist->pre==NULL)
    {
        /* 在表头结点处插入*/
        newNode->next = llist->front;
        llist->front = newNode;
    }
    else {  
        /* 在链表的中间位置或表尾后的位置插入*/
        newNode->next = llist->curr;
        llist->pre->next=newNode;
    }
    //插入在表尾后
    if (llist->pre==llist->rear)
        llist->rear=newNode;
    /* 增加链表的大小*/
    llist->len++;
    /* 新插入的结点为当前结点*/
    llist->curr = newNode;
    return true;
}

// 12）	
bool LL_InsAfter(LinkList* llist, T x)
// 在线性表的当前位置之后插入数据元素x。空表允许插入。当前位置指针将指向新结点。
// 若插入失败，返回false，否则返回true。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
     LinkNode *newNode=(LinkNode*)malloc(sizeof(LinkNode));
    if (newNode==NULL) return false;
    newNode->data=x;
    if (llist->len==0)    {
        /* 在空表中插入*/
        newNode->next=NULL;
        llist->front = llist->rear = newNode;
    }
    else if (llist->curr == llist->rear || llist->curr == NULL)    {
        /* 在尾结点后插入*/
        newNode->next = NULL;
        llist->rear->next=newNode;
        llist->pre=llist->rear;
        llist->rear=newNode;
        llist->position=llist->len;
    }
    else{
        /* 在中间位置插入*/
        newNode->next = llist->curr->next;
        llist->curr->next=newNode;
        llist->pre=llist->curr;
        llist->position ++;
    }
    /* 增加链表的大小*/
    llist->len ++;
    /* 新插入的结点为当前结点*/
    llist->curr = newNode;
    return true;



    /********** End **********/
}

// 13）	
bool LL_DelAt(LinkList* llist)
// 删除线性表的当前位置的数据元素结点。
// 若删除失败（为空表，或当前位置为尾结点之后），则返回false，否则返回true。
{	
    LinkNode *oldNode;
    /* 若表为空或已到表尾之后，则给出错误提示并返回*/
    if (llist->curr==NULL)
    {	
        printf(""LL_DelAt(): delete a node that does not exist.\n"");
        return false;
    }
    oldNode=llist->curr;
    /* 删除的是表头结点*/
    if (llist->pre==NULL)
    {	
        llist->front = oldNode->next;
    }
    /* 删除的是表中或表尾结点*/
    else if(llist->curr!=NULL){
        llist->pre->next = oldNode->next;
    }
    if (oldNode == llist->rear)	{
        /* 删除的是表尾结点，则修改表尾指针和当前结点位置值*/
        llist->rear = llist->pre;
    }

    /* 后继结点作为新的当前结点*/
    llist->curr = oldNode->next;

    /* 释放原当前结点*/
    free(oldNode);

    /* 链表大小减*/
    llist->len --;
    return true;
}

// 14）	
bool LL_DelAfter(LinkList* llist)
// 删除线性表的当前位置的后面那个数据元素。
// 若删除失败（为空表，或当前位置时表尾），则返回false，否则返回true。
{
    LinkNode *oldNode;
    /* 若表为空或已到表尾，则给出错误提示并返回*/
    if (llist->curr==NULL || llist->curr== llist->rear)
    {
        printf(""LL_DelAfter():  delete a node that does not exist.\n"");
        return false;
    }
    /* 保存被删除结点的指针并从链表中删除该结点*/
    oldNode = llist->curr->next;
    llist->curr->next=oldNode->next;
    
    if (oldNode == llist->rear)
        /* 删除的是表尾结点*/
        llist->rear = llist->curr;
    /* 释放被删除结点*/
    free(oldNode);
    /* 链表大小减*/
    llist->len --;
    return true;
}

// 15）	
int LL_FindValue(LinkList* llist, T x)
// 找到线性表中第一个值为x的数据元素的编号。
// 返回值-1表示没有找到，返回值>=0表示编号。
{
    LinkNode* p=llist->front;
    int idx=0;
    while(p!=NULL && p->data!=x) {
        idx++;
        p = p->next;
    }
    if (idx>=llist->len) return -1;
    else return idx;
}

// 16）	
int LL_DelValue(LinkList* llist, T x)
// 删除第一个值为x的数据元素，返回该数据元素的编号。如果不存在值为x的数据元素，则返回-1.
{
    int idx=LL_FindValue(llist, x);
    if (idx<0) return -1;
    LL_SetPosition(llist, idx);
    LL_DelAt(llist);
    return idx;
}

// 17）	
void LL_Print(LinkList* llist)
// 打印整个线性表。
{
    LinkNode* node=llist->front;
    while (node) {
        printf(""%d "", node->data);
        node=node->next;
    }
    printf(""\n"");
}

```"
775,103,数据结构与算法 - 队列,qs5mwob42jg9,实现一个顺序存储的队列,10964,"本关任务对应的参考代码实现如下：
```cpp
/*************************************************************
    date: June 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**************************************************************/
// 循环顺序的队列实现文件
/////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""SeqQueue.h""

SeqQueue* SQ_Create(int maxlen)
// 创建顺序队列, 队列最多存储maxlen个队列元素
{
    SeqQueue* sq=(SeqQueue*)malloc(sizeof(SeqQueue));
    sq->data=(T*)malloc(sizeof(T)*(maxlen+1));
    sq->front=sq->rear=0;
    sq->max=maxlen+1;
    return sq;
}

void SQ_Free(SeqQueue* sq)
// 释放队列空间，以删除队列
{
    free(sq->data);
    free(sq);
}

void SQ_MakeEmpty(SeqQueue* sq)
// 将队列置空
{
    sq->front=0;
    sq->rear=0;
}

bool SQ_IsEmpty(SeqQueue* sq)
// 判断队列是否为空，为空返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return sq->front==sq->rear;


    /********** End **********/
}

bool SQ_IsFull(SeqQueue* sq)
// 判断队列是否为满。为满返回true,否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	return (sq->rear+1)%sq->max==sq->front;

    /********** End **********/
}

int SQ_Length(SeqQueue* sq)
// 队列长度
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	return (sq->rear-sq->front+sq->max)%sq->max;

    /********** End **********/
}

bool SQ_In(SeqQueue* sq, T x)
// 将x入队。若入队失败(队列满)，则返回false，否则返回true。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SQ_IsFull(sq)) return false;
    else{
        T* head=sq->data;
        head[sq->rear]=x;
        sq->rear=(sq->rear+1)%sq->max;
        return true;
    }

    /********** End **********/
}

bool SQ_Out(SeqQueue* sq, T& item)
// 从队列sq出队一个元素，返回时item为出队的元素的值。若出队成功(队列不为空)，则返回true，否则(队列空)，返回false，此时item不会返回有效值。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SQ_IsEmpty(sq)) return false;
    else{
        T* head=sq->data;
        item=head[sq->front];
        sq->front=(sq->front+1)%sq->max;//记得加sq->不要疏忽大意
        return true;
    }
        

    /********** End **********/
}

bool SQ_Head(SeqQueue* sq, T& head)
// 获取队列头结点元素，返回时head保存头结点元素。
// 若获取失败(队列空)，则返回值为false，否则返回值为true。
{
    if ( SQ_IsEmpty(sq) ){
        return false;
    }
    else {
        head = sq->data[sq->front];
        return true;
    }
}

void SQ_Print(SeqQueue* sq)
// 依次打印出队列中的每个元素
{
    int i=sq->front;
    if (SQ_IsEmpty(sq)) {
        printf(""queue is emtpy"");
        return;
    }
    for (i=sq->front; i!=sq->rear; i=(i+1)%sq->max) {
        printf(""%d  "", sq->data[i]);
    }
    printf(""\n"");
}

```"
776,103,数据结构与算法 - 队列,a7lxq4ncrpbh,实现一个链接存储的队列,10965,"本关任务对应的参考代码实现如下：
```cpp
/*************************************************************
    date: July 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**************************************************************/
// 队列的链接存储实现文件
// 采用循环链表，具有附加头节点，使用尾结点指针
// CLQ_   Circularly Linked Queue
////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""CLnkQueue.h""

LNode* CLQ_Create()
// 创建一个队列
{
    LNode* rear=(LNode*)malloc(sizeof(LNode));
    rear->data = 0;
    rear->next = rear;
    return rear;
}
void CLQ_Free(LNode* rear)
// rear指向尾结点
{
    CLQ_MakeEmpty(rear);
    free(rear);
}

void CLQ_MakeEmpty(LNode* & rear)
// rear指向尾结点
// 将队列变为空队列
{
    T item;
    while(!CLQ_IsEmpty(rear))
        CLQ_Out(rear,item);
}

bool CLQ_IsEmpty(LNode* rear)
// 判断队列是否为空
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	return rear==rear->next;

    /********** End **********/
}

int CLQ_Length(LNode* rear)
// 返回队列长度，rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	return rear->next->data;

    /********** End **********/
}

void CLQ_In(LNode* &rear, T x)
// 入队列, 新结点加入链表尾部。rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LNode* newNode=new LNode;
    newNode->data=x;
    newNode->next=rear->next;
    rear->next=newNode;
    rear=newNode;
    rear->next->data++;
	
    /********** End **********/
}

bool CLQ_Out(LNode* & rear, T& item)
// 出队列。空队列时，返回值为false。rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(CLQ_IsEmpty(rear)) return false;
    else if(rear->next->data==1) 
    {
        rear=rear->next;
        rear->next=rear;
        rear->data--;
    }
    else{
        LNode* addNode=rear->next;
        addNode->next=addNode->next->next;
        addNode->data--;
        return true;
    }

    /********** End **********/
}

bool CLQ_Head(LNode* rear, T& item)
// rear指向尾结点
// 获取队列头。空队列时返回值为false。
{
    if (CLQ_IsEmpty(rear)) 
        return false;

    item = rear->next->next->data;
    return true;
}
void CLQ_Print(LNode* rear)
// 打印队列
{
    if (CLQ_IsEmpty(rear))  {
        printf(""The queue is: empty. \n"");
        return;
    }
    LNode* node=rear->next->next;
    do {
        printf(""%d  "", node->data);
        node = node->next;
    }   while (node != rear->next); 
    //printf(""\n"");
}

```"
777,4863,数据结构与算法 - 队列,36bxgu4whs98,实现一个顺序存储的队列,14333,"本关任务对应的参考代码实现如下：
```cpp
/*************************************************************
    date: June 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**************************************************************/
// 循环顺序的队列实现文件
/////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""SeqQueue.h""

SeqQueue* SQ_Create(int maxlen)
// 创建顺序队列, 队列最多存储maxlen个队列元素
{
    SeqQueue* sq=(SeqQueue*)malloc(sizeof(SeqQueue));
    sq->data=(T*)malloc(sizeof(T)*(maxlen+1));
    sq->front=sq->rear=0;
    sq->max=maxlen+1;
    return sq;
}

void SQ_Free(SeqQueue* sq)
// 释放队列空间，以删除队列
{
    free(sq->data);
    free(sq);
}

void SQ_MakeEmpty(SeqQueue* sq)
// 将队列置空
{
    sq->front=0;
    sq->rear=0;
}

bool SQ_IsEmpty(SeqQueue* sq)
// 判断队列是否为空，为空返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return sq->front==sq->rear;


    /********** End **********/
}

bool SQ_IsFull(SeqQueue* sq)
// 判断队列是否为满。为满返回true,否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	return (sq->rear+1)%sq->max==sq->front;

    /********** End **********/
}

int SQ_Length(SeqQueue* sq)
// 队列长度
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	return (sq->rear-sq->front+sq->max)%sq->max;

    /********** End **********/
}

bool SQ_In(SeqQueue* sq, T x)
// 将x入队。若入队失败(队列满)，则返回false，否则返回true。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SQ_IsFull(sq)) return false;
    else{
        T* head=sq->data;
        head[sq->rear]=x;
        sq->rear=(sq->rear+1)%sq->max;
        return true;
    }

    /********** End **********/
}

bool SQ_Out(SeqQueue* sq, T& item)
// 从队列sq出队一个元素，返回时item为出队的元素的值。若出队成功(队列不为空)，则返回true，否则(队列空)，返回false，此时item不会返回有效值。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(SQ_IsEmpty(sq)) return false;
    else{
        T* head=sq->data;
        item=head[sq->front];
        sq->front=(sq->front+1)%sq->max;//记得加sq->不要疏忽大意
        return true;
    }
        

    /********** End **********/
}

bool SQ_Head(SeqQueue* sq, T& head)
// 获取队列头结点元素，返回时head保存头结点元素。
// 若获取失败(队列空)，则返回值为false，否则返回值为true。
{
    if ( SQ_IsEmpty(sq) ){
        return false;
    }
    else {
        head = sq->data[sq->front];
        return true;
    }
}

void SQ_Print(SeqQueue* sq)
// 依次打印出队列中的每个元素
{
    int i=sq->front;
    if (SQ_IsEmpty(sq)) {
        printf(""queue is emtpy"");
        return;
    }
    for (i=sq->front; i!=sq->rear; i=(i+1)%sq->max) {
        printf(""%d  "", sq->data[i]);
    }
    printf(""\n"");
}

```"
778,4863,数据结构与算法 - 队列,zyox3n2srteg,实现一个链接存储的队列,14335,"本关任务对应的参考代码实现如下：
```cpp
/*************************************************************
    date: July 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**************************************************************/
// 队列的链接存储实现文件
// 采用循环链表，具有附加头节点，使用尾结点指针
// CLQ_   Circularly Linked Queue
////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""CLnkQueue.h""

LNode* CLQ_Create()
// 创建一个队列
{
    LNode* rear=(LNode*)malloc(sizeof(LNode));
    rear->data = 0;
    rear->next = rear;
    return rear;
}
void CLQ_Free(LNode* rear)
// rear指向尾结点
{
    CLQ_MakeEmpty(rear);
    free(rear);
}

void CLQ_MakeEmpty(LNode* & rear)
// rear指向尾结点
// 将队列变为空队列
{
    T item;
    while(!CLQ_IsEmpty(rear))
        CLQ_Out(rear,item);
}

bool CLQ_IsEmpty(LNode* rear)
// 判断队列是否为空
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	return rear==rear->next;

    /********** End **********/
}

int CLQ_Length(LNode* rear)
// 返回队列长度，rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	return rear->next->data;

    /********** End **********/
}

void CLQ_In(LNode* &rear, T x)
// 入队列, 新结点加入链表尾部。rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	LNode* newNode=new LNode;
    newNode->data=x;
    newNode->next=rear->next;
    rear->next=newNode;
    rear=newNode;
    rear->next->data++;
	
    /********** End **********/
}

bool CLQ_Out(LNode* & rear, T& item)
// 出队列。空队列时，返回值为false。rear指向尾结点
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
	if(CLQ_IsEmpty(rear)) return false;
    else if(rear->next->data==1) 
    {
        rear=rear->next;
        rear->next=rear;
        rear->data--;
    }
    else{
        LNode* addNode=rear->next;
        addNode->next=addNode->next->next;
        addNode->data--;
        return true;
    }

    /********** End **********/
}

bool CLQ_Head(LNode* rear, T& item)
// rear指向尾结点
// 获取队列头。空队列时返回值为false。
{
    if (CLQ_IsEmpty(rear)) 
        return false;

    item = rear->next->next->data;
    return true;
}
void CLQ_Print(LNode* rear)
// 打印队列
{
    if (CLQ_IsEmpty(rear))  {
        printf(""The queue is: empty. \n"");
        return;
    }
    LNode* node=rear->next->next;
    do {
        printf(""%d  "", node->data);
        node = node->next;
    }   while (node != rear->next); 
    //printf(""\n"");
}

```"
779,99,C&C++指针实训,3bimp8u2o6fw,去掉字符串首尾空格,168,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数trim：去掉字符串首尾空格
// 参数：str-字符指针，指向输入的字符串
// 返回值：字符指针，指向去掉首尾空格后的字符串（首地址）
// 提示：可以字节在字符串str中操作
char * trim(char * str);

int main()
{
    // 定义存储字符串的一维字符数组
    char s[1024];

    // 输入一行字符，可以包含空格
    // 输入的字符串存入s中，最多读取个字符，后面自动加上'\0'
    cin.getline(s,1024);

    // 输出去掉首尾空格后的字符串
    cout << trim(s) << endl;

    return 0;
}

// 函数trim：去掉字符串首尾空格
// 参数：str-字符指针，指向输入的字符串
// 返回值：字符指针，指向去掉首尾空格后的字符串（首地址）
// 提示：可以字节在字符串str中操作
char * trim(char * str)
{
    // 请在此添加代码，实现函数trim
    /********** Begin *********/
    char *p = str;
    while(*p != '\0')
        p++;
    p--;
    while(p >= str && *p == ' ')
    {
        *p = '\0';
        p--;
    }
    p = str;
    while(*p == ' ')
        p++;
    return p;

    /********** End **********/
}
```"
780,99,C&C++指针实训,zhbw36gtef9o,用指针实现pswap函数,169,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数pswap：交换指针p和q指向的单元中的整数值
// 参数：p,q-int类型指针，指向要交换的整数
void pswap(int * p, int *q);

int main()
{
    int a, b;
    // 输入两个整数
    cin >> a >> b;

    // 调用pswap函数，交换a、b的值
    pswap(&a,&b);

    // 输出a、b的值
    cout << a << "" "" << b << endl;

    return 0;
}

//函数pswap：交换指针p和q指向的单元中的整数值
//参数：p,q-int类型指针，指向要交换的整数
void pswap(int * p, int *q)
{
    // 请在此添加代码，实现函数pswap
    /********** Begin *********/
    int a = *p;
    *p = *q;
    *q = a;
    /********** End **********/
}
```"
781,99,C&C++指针实训,2qu87wgpcafs,选出串中的数字,170,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数extractNum：选出str指向的字符串中的数字，并写回str
// 参数：str-指向字符串
void extractNum(char * str);

int main()
{
    char s[1024];
    // 输入一行字符
    cin.getline(s,1024);
    // 调用extractNum函数，选出数字
    extractNum(s);
    // 输出选出的数字
    cout<<s<<endl;

    return 0;
}

// 函数extractNum：选出str指向的字符串中的数字，并写回str
// 参数：str-指向字符串
void extractNum(char * str)
{
    // 请在此添加代码，实现函数extractNum
    /********** Begin *********/
    char *p=str,*q=str;
    int fuhao=1;
    while(*q!='\0')
    {
        if(*q=='-' && fuhao)
        {
            *p++=*q++;
            fuhao=0;
        }
        else if(*q>='0' && *q<='9')
        {
            fuhao=0;
            *p++=*q++;
        }
        else
            q++;
    }
    *p='\0';
    /********** End **********/
}
```"
782,99,C&C++指针实训,lwmb2gu8fh43,大写字母好看,171,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数toUp：将str指向的字符串中的小写字母变成对应的大写字母
// 参数：str-指向字符串
void toUp(char * str);

int main()
{
    char s[1024];
    // 输入一行字符
    cin.getline(s,1024);

    // 调用toUp函数，转换成大写字母
    toUp(s);

    // 输出变更后的字符串
    cout<<s<<endl;

    return 0;
}

// 函数toUp：将str指向的字符串中的小写字母变成对应的大写字母
// 参数：str-指向字符串
void toUp(char * str)
{
    // 请在此添加代码，实现函数toUp
    /********** Begin *********/
    char *p=str;
    while(*p)
    {
        if(*p>='a' && *p<='z')
            *p=*p+'A'-'a';
        p++;
    }
    /********** End **********/
}
```"
783,99,C&C++指针实训,b5xrfc872zyt,子串出现的次数,172,"本关任务对应参考代码实现如下：
```cpp
// 包含字符串函数库
#include <string.h>
#include <iostream>
using namespace std;

// 函数frequency：计算子串在长串中出现的次数
// 参数：substr-指向子串，str-指向长串
// 返回值：出现的次数
int frequency(char * substr, char * str);

int main()
{
    char sub[128],str[1024];

    // 输入子串
    cin.getline(sub,128);

    // 输入长串
    cin.getline(str,1024);

    // 调用frequency函数，计算子串在长串中出现的次数
    int n = frequency(sub,str);

    // 输出次数
    cout<<n<<endl;

    return 0;
}

// 函数frequency：计算子串在长串中出现的次数
// 参数：substr-指向子串，str-指向长串
// 返回值：出现的次数
int frequency(char * substr, char * str)
{
    // 请在此添加代码，实现函数frequency
    /********** Begin *********/
    int n=strlen(substr);
    int t=0;
    char *p=str;
    while(p=strstr(p,substr))
    {
        t++;
        p=p+n;
    }
    return t;
    /********** End **********/
}
```"
784,99,C&C++指针实训,axw4pe9lnjf6,字符串的部分复制,173,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数strmncpy：字符串的部分复制，将s指向字符串从第m个字符开始的n个字符复制的t中
// 参数：s-指向源字符串，t-指向目标字符串，m-起始位置，n-字符个数
// 返回值：无
void strmncpy(char *s, int m, int n, char *t);

int main()
{
    char s[128],t[128];
    int m,n;

    // 输入源串
    cin>>s;

    // 输入m和n
    cin>>m>>n;

    // 字符串复制
    strmncpy(s, m, n, t);

    // 输出复制结果
    cout<<""t:""<<t<<endl;

    return 0;
}

// 函数strmncpy：字符串的部分复制，将s指向字符串从第m个字符开始的n个字符复制的t中
// 参数：s-指向源字符串，t-指向目标字符串，m-起始位置，n-字符个数
// 返回值：无
void strmncpy(char *s, int m, int n, char *t)
{
    // 请在此添加代码，实现函数strmncpy
    /********** Begin *********/
    int k=0;
    while(s[k]!=0)k++;
    if(k<=m)
    {
        *t='\0';
        return;
    }
    char *p=s+m;
    for(int i=0;i<n;i++)
    {
        *t=*p;
        if(*t=='\0')
            return;
        t++;
        p++;
    }
    *t='\0';
    /********** End **********/
}
```"
785,4286,C&C++指针实训,gfn7iz9rwamk,去掉字符串首尾空格,12430,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数trim：去掉字符串首尾空格
// 参数：str-字符指针，指向输入的字符串
// 返回值：字符指针，指向去掉首尾空格后的字符串（首地址）
// 提示：可以字节在字符串str中操作
char * trim(char * str);

int main()
{
    // 定义存储字符串的一维字符数组
    char s[1024];

    // 输入一行字符，可以包含空格
    // 输入的字符串存入s中，最多读取个字符，后面自动加上'\0'
    cin.getline(s,1024);

    // 输出去掉首尾空格后的字符串
    cout << trim(s) << endl;

    return 0;
}

// 函数trim：去掉字符串首尾空格
// 参数：str-字符指针，指向输入的字符串
// 返回值：字符指针，指向去掉首尾空格后的字符串（首地址）
// 提示：可以字节在字符串str中操作
char * trim(char * str)
{
    // 请在此添加代码，实现函数trim
    /********** Begin *********/
    char *p = str;
    while(*p != '\0')
        p++;
    p--;
    while(p >= str && *p == ' ')
    {
        *p = '\0';
        p--;
    }
    p = str;
    while(*p == ' ')
        p++;
    return p;

    /********** End **********/
}
```"
786,4286,C&C++指针实训,8zut9fscjyv6,用指针实现pswap函数,12431,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数pswap：交换指针p和q指向的单元中的整数值
// 参数：p,q-int类型指针，指向要交换的整数
void pswap(int * p, int *q);

int main()
{
    int a, b;
    // 输入两个整数
    cin >> a >> b;

    // 调用pswap函数，交换a、b的值
    pswap(&a,&b);

    // 输出a、b的值
    cout << a << "" "" << b << endl;

    return 0;
}

//函数pswap：交换指针p和q指向的单元中的整数值
//参数：p,q-int类型指针，指向要交换的整数
void pswap(int * p, int *q)
{
    // 请在此添加代码，实现函数pswap
    /********** Begin *********/
    int a = *p;
    *p = *q;
    *q = a;
    /********** End **********/
}
```"
787,4286,C&C++指针实训,jbn64fm7piax,选出串中的数字,12432,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数extractNum：选出str指向的字符串中的数字，并写回str
// 参数：str-指向字符串
void extractNum(char * str);

int main()
{
    char s[1024];
    // 输入一行字符
    cin.getline(s,1024);
    // 调用extractNum函数，选出数字
    extractNum(s);
    // 输出选出的数字
    cout<<s<<endl;

    return 0;
}

// 函数extractNum：选出str指向的字符串中的数字，并写回str
// 参数：str-指向字符串
void extractNum(char * str)
{
    // 请在此添加代码，实现函数extractNum
    /********** Begin *********/
    char *p=str,*q=str;
    int fuhao=1;
    while(*q!='\0')
    {
        if(*q=='-' && fuhao)
        {
            *p++=*q++;
            fuhao=0;
        }
        else if(*q>='0' && *q<='9')
        {
            fuhao=0;
            *p++=*q++;
        }
        else
            q++;
    }
    *p='\0';
    /********** End **********/
}
```"
788,4286,C&C++指针实训,cjnh4qf5meou,大写字母好看,12433,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数toUp：将str指向的字符串中的小写字母变成对应的大写字母
// 参数：str-指向字符串
void toUp(char * str);

int main()
{
    char s[1024];
    // 输入一行字符
    cin.getline(s,1024);

    // 调用toUp函数，转换成大写字母
    toUp(s);

    // 输出变更后的字符串
    cout<<s<<endl;

    return 0;
}

// 函数toUp：将str指向的字符串中的小写字母变成对应的大写字母
// 参数：str-指向字符串
void toUp(char * str)
{
    // 请在此添加代码，实现函数toUp
    /********** Begin *********/
    char *p=str;
    while(*p)
    {
        if(*p>='a' && *p<='z')
            *p=*p+'A'-'a';
        p++;
    }
    /********** End **********/
}
```"
789,4286,C&C++指针实训,5fj3c94il72x,子串出现的次数,12434,"本关任务对应参考代码实现如下：
```cpp
// 包含字符串函数库
#include <string.h>
#include <iostream>
using namespace std;

// 函数frequency：计算子串在长串中出现的次数
// 参数：substr-指向子串，str-指向长串
// 返回值：出现的次数
int frequency(char * substr, char * str);

int main()
{
    char sub[128],str[1024];

    // 输入子串
    cin.getline(sub,128);

    // 输入长串
    cin.getline(str,1024);

    // 调用frequency函数，计算子串在长串中出现的次数
    int n = frequency(sub,str);

    // 输出次数
    cout<<n<<endl;

    return 0;
}

// 函数frequency：计算子串在长串中出现的次数
// 参数：substr-指向子串，str-指向长串
// 返回值：出现的次数
int frequency(char * substr, char * str)
{
    // 请在此添加代码，实现函数frequency
    /********** Begin *********/
    int n=strlen(substr);
    int t=0;
    char *p=str;
    while(p=strstr(p,substr))
    {
        t++;
        p=p+n;
    }
    return t;
    /********** End **********/
}
```"
790,4286,C&C++指针实训,j8nhaoqz9t7k,字符串的部分复制,12435,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数strmncpy：字符串的部分复制，将s指向字符串从第m个字符开始的n个字符复制的t中
// 参数：s-指向源字符串，t-指向目标字符串，m-起始位置，n-字符个数
// 返回值：无
void strmncpy(char *s, int m, int n, char *t);

int main()
{
    char s[128],t[128];
    int m,n;

    // 输入源串
    cin>>s;

    // 输入m和n
    cin>>m>>n;

    // 字符串复制
    strmncpy(s, m, n, t);

    // 输出复制结果
    cout<<""t:""<<t<<endl;

    return 0;
}

// 函数strmncpy：字符串的部分复制，将s指向字符串从第m个字符开始的n个字符复制的t中
// 参数：s-指向源字符串，t-指向目标字符串，m-起始位置，n-字符个数
// 返回值：无
void strmncpy(char *s, int m, int n, char *t)
{
    // 请在此添加代码，实现函数strmncpy
    /********** Begin *********/
    int k=0;
    while(s[k]!=0)k++;
    if(k<=m)
    {
        *t='\0';
        return;
    }
    char *p=s+m;
    for(int i=0;i<n;i++)
    {
        *t=*p;
        if(*t=='\0')
            return;
        t++;
        p++;
    }
    *t='\0';
    /********** End **********/
}
```"
791,100,C&C++结构实训,5nqzvc4f69es,有理数化简,181,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

struct rationalNumber{
    int fenzi; // 分子
    int fenmu; // 分母
};

// 函数reduction：有理数化简，对传入的有理数n进行化简
// 参数：n-有理数
// 返回值：化简后的有理数
rationalNumber reduction(rationalNumber n);

int main()
{
    char c;
    rationalNumber x, y;
    // 输入有理数，首先读入分子，然后是/，最后是分母
    cin >> x.fenzi >> c >> x.fenmu;

    // 有理数化简
    y = reduction(x);

    // 输出化简的结果
    if(y.fenmu == 1)
        cout << y.fenzi << endl;
    else
        cout << y.fenzi << ""/"" << y.fenmu << endl;

    return 0;
}

// 函数reduction：有理数化简，对传入的有理数n进行化简
// 参数：n-有理数
// 返回值：无化简后的有理数
rationalNumber reduction(rationalNumber n)
{
    // 请在这里补充代码，实现函数reduction
    /********** Begin *********/
    int flag = 1,k;
    if(n.fenzi == 0)
    {
        n.fenmu = 1;
        return n;
    }
    if(n.fenzi < 0)
    {
        n.fenzi = -n.fenzi;
        flag = -1;
    }
    k = (n.fenmu > n.fenzi) ? n.fenzi : n.fenmu;
    while(k > 1)
    {
        if(n.fenmu % k == 0 && n.fenzi % k == 0)
        {
            n.fenmu = n.fenmu / k;
            n.fenzi = n.fenzi / k;
        }
        k--;
    }
    n.fenzi = n.fenzi * flag;
    return n;
    /********** End **********/
}
```"
792,100,C&C++结构实训,sczmxwfuqgfn,有理数加法,182,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

struct rationalNumber{
    int fenzi; // 分子
    int fenmu; // 分母
};

// 函数rnAdd：两个有理数相加
// 参数：x,y-两个有理数
// 返回值：x+y的最简分数形式
rationalNumber rnAdd(rationalNumber x, rationalNumber y);

int main()
{
    char c;
    rationalNumber x, y, z;
    // 输入两个有理数
    cin >> x.fenzi >> c >> x.fenmu;
    cin >> y.fenzi >> c >> y.fenmu;

    // 有理数相加
    z = rnAdd(x,y);

    // 输出相加的结果
    if(z.fenmu == 1)
        cout << z.fenzi << endl;
    else
        cout << z.fenzi << ""/"" << z.fenmu << endl;

    return 0;
}

// 请在此添加代码，实现函数rnAdd
/********** Begin *********/
rationalNumber reduction(rationalNumber n)
{
    int flag = 1,k;
    if(n.fenzi == 0)
    {
        n.fenmu = 1;
        return n;
    }
    if(n.fenzi < 0)
    {
        n.fenzi = -n.fenzi;
        flag = -1;
    }
    k = (n.fenmu > n.fenzi) ? n.fenzi : n.fenmu;
    while(k > 1)
    {
        if(n.fenmu % k == 0 && n.fenzi % k == 0)
        {
            n.fenmu = n.fenmu / k;
            n.fenzi = n.fenzi / k;
        }
        k--;
    }
    n.fenzi = n.fenzi * flag;
    return n;
}

// 函数rnAdd：两个有理数相加
// 参数：x,y-两个有理数
// 返回值：x+y的最简分数形式
rationalNumber rnAdd(rationalNumber x, rationalNumber y)
{
    rationalNumber z;
    z.fenmu = x.fenmu * y.fenmu;
    z.fenzi = x.fenzi * y.fenmu + y.fenzi * x.fenmu;
    return reduction(z);
}
/********** End **********/
```"
793,100,C&C++结构实训,2ips6bk7v5wg,有理数平均数,183,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

struct rationalNumber{
    int fenzi; // 分子
    int fenmu; // 分母
};

// 函数rnMean：计算n个有理数的平均数
// 参数：a-存放有理数的数组,n-有理数的个数
// 返回值：n个有理数的平均数
rationalNumber rnMean(rationalNumber a[], int n);

int main()
{
    char c;
    rationalNumber a[100],z;
    int n, i;

    // 输入有理数个数
    cin >> n;

    // 输入n个有理数
    for(i = 0; i < n; i++)
        cin >> a[i].fenzi >> c >> a[i].fenmu;

    // 计算有理数平均数
    z = rnMean(a,n);

    // 输出平均数
    if(z.fenmu == 1)
        cout << z.fenzi << endl;
    else
        cout << z.fenzi << ""/"" << z.fenmu << endl;

    return 0;
}

// 请在此添加代码，实现函数rnMean
/********** Begin *********/
rationalNumber reduction(rationalNumber n)
{
    int flag = 1,k;
    if(n.fenzi < 0)
    {
        n.fenzi = -n.fenzi;
        flag = -1;
    }
    k = (n.fenmu > n.fenzi) ? n.fenzi : n.fenmu;
    while(k > 1)
    {
        if(n.fenmu%k == 0 && n.fenzi%k == 0)
        {
            n.fenmu = n.fenmu / k;
            n.fenzi = n.fenzi / k;
        }
        k--;
    }
    n.fenzi = n.fenzi * flag;
    return n;
}
rationalNumber rnAdd(rationalNumber x, rationalNumber y)
{
    rationalNumber z;
    z.fenmu = x.fenmu * y.fenmu;
    z.fenzi = x.fenzi * y.fenmu + y.fenzi * x.fenmu;
    return reduction(z);
}

// 函数rnMean：计算n个有理数的平均数
// 参数：a-存放有理数的数组,n-有理数的个数
// 返回值：n个有理数的平均数，最简分数
rationalNumber rnMean(rationalNumber a[], int n)
{
    rationalNumber x = {0,1};
    int i;
    for(i = 0; i < n; i++)
    {
        x = rnAdd(x,a[i]);
    }
    x.fenmu = x.fenmu * n;
    x = reduction(x);
    return x;
}
/********** End **********/
```"
794,100,C&C++结构实训,sv38hinkm6al,书籍排序,184,"本关任务对应参考代码实现如下：
```cpp
// 请在此添加代码，实现书籍数据的输入、排序和输出
/********** Begin *********/
#include <string.h>
#include <iostream>
using namespace std;

struct book{
    char name[52];  //书名
    float price;  //价格
};

int main()
{
    int n;  // 书的数量
    book bk[100];  // 书的数组
    int i,j,k;

    // 输入书的信息
    cin>>n;
    for(i=0;i<n;i++)
    {
        char s[10];
        cin.getline(s,10);  // 读取上一行的那个换行符
        cin.getline(bk[i].name,52);
        cin>>bk[i].price;
    }

    // 排序
    for(i=0;i<n-1;i++)
    {
        k=i;
        for(j=i+1;j<n;j++)
        {
            if(bk[k].price>bk[j].price)
                k=j;
            else if(bk[k].price==bk[j].price && strcmp(bk[j].name,bk[k].name)<0)
                k=j;
        }
        if(k!=i)
        {
            book t = bk[i];
            bk[i]=bk[k];
            bk[k]=t;
        }
    }

    // 输出
    for(i=0;i<n;i++)
    {
        cout<<bk[i].price<<"", ""<<bk[i].name<<endl;
    }

    return 0;
}
/********** End **********/
```"
795,4287,C&C++结构实训,mnpw6bg8sk2f,有理数化简,12436,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

struct rationalNumber{
    int fenzi; // 分子
    int fenmu; // 分母
};

// 函数reduction：有理数化简，对传入的有理数n进行化简
// 参数：n-有理数
// 返回值：化简后的有理数
rationalNumber reduction(rationalNumber n);

int main()
{
    char c;
    rationalNumber x, y;
    // 输入有理数，首先读入分子，然后是/，最后是分母
    cin >> x.fenzi >> c >> x.fenmu;

    // 有理数化简
    y = reduction(x);

    // 输出化简的结果
    if(y.fenmu == 1)
        cout << y.fenzi << endl;
    else
        cout << y.fenzi << ""/"" << y.fenmu << endl;

    return 0;
}

// 函数reduction：有理数化简，对传入的有理数n进行化简
// 参数：n-有理数
// 返回值：无化简后的有理数
rationalNumber reduction(rationalNumber n)
{
    // 请在这里补充代码，实现函数reduction
    /********** Begin *********/
    int flag = 1,k;
    if(n.fenzi == 0)
    {
        n.fenmu = 1;
        return n;
    }
    if(n.fenzi < 0)
    {
        n.fenzi = -n.fenzi;
        flag = -1;
    }
    k = (n.fenmu > n.fenzi) ? n.fenzi : n.fenmu;
    while(k > 1)
    {
        if(n.fenmu % k == 0 && n.fenzi % k == 0)
        {
            n.fenmu = n.fenmu / k;
            n.fenzi = n.fenzi / k;
        }
        k--;
    }
    n.fenzi = n.fenzi * flag;
    return n;
    /********** End **********/
}
```"
796,4287,C&C++结构实训,ac6u4s9ogmq3,有理数加法,12437,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

struct rationalNumber{
    int fenzi; // 分子
    int fenmu; // 分母
};

// 函数rnAdd：两个有理数相加
// 参数：x,y-两个有理数
// 返回值：x+y的最简分数形式
rationalNumber rnAdd(rationalNumber x, rationalNumber y);

int main()
{
    char c;
    rationalNumber x, y, z;
    // 输入两个有理数
    cin >> x.fenzi >> c >> x.fenmu;
    cin >> y.fenzi >> c >> y.fenmu;

    // 有理数相加
    z = rnAdd(x,y);

    // 输出相加的结果
    if(z.fenmu == 1)
        cout << z.fenzi << endl;
    else
        cout << z.fenzi << ""/"" << z.fenmu << endl;

    return 0;
}

// 请在此添加代码，实现函数rnAdd
/********** Begin *********/
rationalNumber reduction(rationalNumber n)
{
    int flag = 1,k;
    if(n.fenzi == 0)
    {
        n.fenmu = 1;
        return n;
    }
    if(n.fenzi < 0)
    {
        n.fenzi = -n.fenzi;
        flag = -1;
    }
    k = (n.fenmu > n.fenzi) ? n.fenzi : n.fenmu;
    while(k > 1)
    {
        if(n.fenmu % k == 0 && n.fenzi % k == 0)
        {
            n.fenmu = n.fenmu / k;
            n.fenzi = n.fenzi / k;
        }
        k--;
    }
    n.fenzi = n.fenzi * flag;
    return n;
}

// 函数rnAdd：两个有理数相加
// 参数：x,y-两个有理数
// 返回值：x+y的最简分数形式
rationalNumber rnAdd(rationalNumber x, rationalNumber y)
{
    rationalNumber z;
    z.fenmu = x.fenmu * y.fenmu;
    z.fenzi = x.fenzi * y.fenmu + y.fenzi * x.fenmu;
    return reduction(z);
}
/********** End **********/
```"
797,4287,C&C++结构实训,yvkfu8bs5zm2,有理数平均数,12438,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

struct rationalNumber{
    int fenzi; // 分子
    int fenmu; // 分母
};

// 函数rnMean：计算n个有理数的平均数
// 参数：a-存放有理数的数组,n-有理数的个数
// 返回值：n个有理数的平均数
rationalNumber rnMean(rationalNumber a[], int n);

int main()
{
    char c;
    rationalNumber a[100],z;
    int n, i;

    // 输入有理数个数
    cin >> n;

    // 输入n个有理数
    for(i = 0; i < n; i++)
        cin >> a[i].fenzi >> c >> a[i].fenmu;

    // 计算有理数平均数
    z = rnMean(a,n);

    // 输出平均数
    if(z.fenmu == 1)
        cout << z.fenzi << endl;
    else
        cout << z.fenzi << ""/"" << z.fenmu << endl;

    return 0;
}

// 请在此添加代码，实现函数rnMean
/********** Begin *********/
rationalNumber reduction(rationalNumber n)
{
    int flag = 1,k;
    if(n.fenzi < 0)
    {
        n.fenzi = -n.fenzi;
        flag = -1;
    }
    k = (n.fenmu > n.fenzi) ? n.fenzi : n.fenmu;
    while(k > 1)
    {
        if(n.fenmu%k == 0 && n.fenzi%k == 0)
        {
            n.fenmu = n.fenmu / k;
            n.fenzi = n.fenzi / k;
        }
        k--;
    }
    n.fenzi = n.fenzi * flag;
    return n;
}
rationalNumber rnAdd(rationalNumber x, rationalNumber y)
{
    rationalNumber z;
    z.fenmu = x.fenmu * y.fenmu;
    z.fenzi = x.fenzi * y.fenmu + y.fenzi * x.fenmu;
    return reduction(z);
}

// 函数rnMean：计算n个有理数的平均数
// 参数：a-存放有理数的数组,n-有理数的个数
// 返回值：n个有理数的平均数，最简分数
rationalNumber rnMean(rationalNumber a[], int n)
{
    rationalNumber x = {0,1};
    int i;
    for(i = 0; i < n; i++)
    {
        x = rnAdd(x,a[i]);
    }
    x.fenmu = x.fenmu * n;
    x = reduction(x);
    return x;
}
/********** End **********/
```"
798,4287,C&C++结构实训,xcfs6a2ybqfl,书籍排序,12439,"本关任务对应参考代码实现如下：
```cpp
// 请在此添加代码，实现书籍数据的输入、排序和输出
/********** Begin *********/
#include <string.h>
#include <iostream>
using namespace std;

struct book{
    char name[52];  //书名
    float price;  //价格
};

int main()
{
    int n;  // 书的数量
    book bk[100];  // 书的数组
    int i,j,k;

    // 输入书的信息
    cin>>n;
    for(i=0;i<n;i++)
    {
        char s[10];
        cin.getline(s,10);  // 读取上一行的那个换行符
        cin.getline(bk[i].name,52);
        cin>>bk[i].price;
    }

    // 排序
    for(i=0;i<n-1;i++)
    {
        k=i;
        for(j=i+1;j<n;j++)
        {
            if(bk[k].price>bk[j].price)
                k=j;
            else if(bk[k].price==bk[j].price && strcmp(bk[j].name,bk[k].name)<0)
                k=j;
        }
        if(k!=i)
        {
            book t = bk[i];
            bk[i]=bk[k];
            bk[k]=t;
        }
    }

    // 输出
    for(i=0;i<n;i++)
    {
        cout<<bk[i].price<<"", ""<<bk[i].name<<endl;
    }

    return 0;
}
/********** End **********/
```"
799,101,C&C++线性表实训,c4b9tjirkp38,顺序构建线性表,10907,"```cpp
#include ""linearList.h""

node *insertTail(node *h, node *t)
{
    // 请在此添加代码，补全函数insertTail
    /********** Begin *********/
    if(h == NULL) // 空链表单独处理
    {
        t->next = NULL; // 链表尾指针置为NULL
        return t; // 返回第一个结点的地址（即链表头指针）
    }
    // 非空链表的情况
    node *p = h;
    // 让p指向最后一个结点
    while(p->next)
        p = p->next;
    p->next = t; // 让最后一个结点的指针域指向结点t
    t->next = NULL; // 链表尾指针置为NULL
    return h;  // 返回第一个结点的地址（即链表头指针）

    /********** End **********/
}
```"
800,101,C&C++线性表实训,3hnowvku46mr,逆序构建线性表,10908,"```cpp
#include ""linearList.h""

node * insertHead(node *h, node *t)
{
    // 请在此添加代码，补全函数insertHead
    /********** Begin *********/
    t->next = h;
    return t;

    /********** End **********/
}
```"
801,101,C&C++线性表实训,oy76ix4wlzrc,排序构建线性表,10909,"```cpp
#include ""linearList.h""

node * insertSort(node *h, node *t)
{
    // 请在此添加代码，补全函数insertSort
    /********** Begin *********/
    node *p = NULL, *q = h;  // 定位第一个插入点：链首

    // 查找插入点
    while(q && q->data < t->data)
    {// 两个指针并行后移
        p = q;
        q = q->next;
    }

    // 插入链首
    if(p == NULL)
    {
        t->next = h;
        return t;
    }

    // 插入链尾
    if(q == NULL)
    {
        p->next = t;
        t->next = NULL;
    }

    // 插入p、q之间
    t->next = q;
    p->next = t;
    return h;

    /********** End **********/
}
```"
802,101,C&C++线性表实训,ho2fscuknjzp,查找元素,10910,"```cpp
#include ""linearList.h""

node * search(node * h, int num)
{
    // 请在此添加代码，补全函数search
    /********** Begin *********/
    while(h)
    {// h为真，即h指向的结点存在
        if(h->data == num)
            return h;
        h = h->next;  // 将该结点的指针域赋值给h，h就指向了下一个结点
    }
    return NULL; // 没找到包含num的结点

    /********** End **********/
}
```"
803,101,C&C++线性表实训,tnrxlpsgzq4h,删除指定位置的结点,10911,"```cpp
#include ""linearList.h""

node * delAt(node * h, int i)
{
    // 请在此添加代码，补全函数delAt
    /********** Begin *********/
    // 序号非法，不删除
    if(i<0)
        return h;
    node *p = NULL, *q = h; // 定位删除结点，试图让q指向要删除结点，p指向其前面的结点
    for(int k = 0; k < i; k++)
    {
        if(q->next == NULL) // 后面没有结点了，序号非法
            return h;
        p = q;
        q = q->next;
    }
    if(p) // p指向的结点存在，不是删除首结点
    {
        // 删除q指向的结点，让p指向结点的指针域指向q的后续结点
        p->next = q->next;
        // 释放空间
        delete q;
        return h;
    }
    else // 删除首结点
    {
        h = q->next; // 下一个结点成了首结点
        // 释放空间
        delete q;
        return h;
    }

    /********** End **********/
}
```"
804,101,C&C++线性表实训,kuefb2gv5onq,删除包含特定数据的结点,10912,"```cpp
#include ""linearList.h""

node * delHas(node * h, int n)
{
    // 请在此添加代码，补全函数delHas
    /********** Begin *********/
    node *p = NULL, *q = h;  // p为要删除结点的前结点，q指向要删除结点
    while(q)
    {// h为真，即h指向的结点存在
        if(q->data == n)
            break; // 找到了
        if(q->next == NULL)  // 后面没有结点了，没有结点满足条件
            return h;  // 不删除，直接返回
        // 继续往后找，两个指针一起后移
        p = q;
        q = q->next;
    }
    // 删除q指向的结点
    if(p == NULL)  // 删除头结点
    {
        h = q->next;  // 下一个结点变成头结点
        delete q;  // 删除结点
        return h;
    }
    // 不是头结点
    p->next = q->next;  // 把q指向结点的指针域（q后面结点的地址）赋值给p指向结点的指针域
    return h;

    /********** End **********/
}
```"
805,101,C&C++线性表实训,bshjzw3xgvqc,线性表长度,10913,"```cpp
#include ""linearList.h""

int listLength(node * h)
{
    // 请在此添加代码，补全函数listLength
    /********** Begin *********/
    int n = 0;
    while(h)
    {
        n++;
        h = h->next;
    }
    return n;

    /********** End **********/
}
```"
806,101,C&C++线性表实训,rnebm2pvzxyk,线性表应用一：栈,10914,"```cpp
#include ""mstack.h""

// 函数empty：判断栈sk是否为空
// 参数：sk-栈
// 返回值：true-sk为空，false-sk不为空
bool empty(intStack sk)
{
    // 请在此添加代码，补全函数empty
    /********** Begin *********/
    return (listLength(sk) == 0);  // 链表长度为0，则栈为空

    /********** End **********/
}

// 函数pop：弹栈
// 参数：sk-栈，传引用，弹栈可能会改变sk的值
// 返回值：弹栈的弹出的整数，如果栈空，返回-1
int pop(intStack &sk)
{
    // 请在此添加代码，补全函数pop
    /********** Begin *********/
    if(empty(sk))  // 栈空，返回-1
        return -1;
    int n = sk->data;  // 获取栈顶结点(链首结点)的数据
    sk = delAt(sk,0);  // 删除首结点（弹栈，第一个结点出栈）
    return n;  // 返回弹栈数据

    /********** End **********/
}

// 函数push：压栈，将整数n压入栈sk中
// 参数：sk-栈，传引用，压栈会改变sk的值，n-要压栈的整数
// 返回值：无，采用链表实现栈，只要还有内存，压栈都会成功
void push(intStack &sk, int n)
{
    // 请在此添加代码，补全函数push
    /********** Begin *********/

    // 创建要压栈的结点
    node *p = new node;
    p->data = n;

    // 压栈（插入链首）
    sk = insertHead(sk,p);

    /********** End **********/
}
```"
807,101,C&C++线性表实训,wfkscflpb72v,线性表应用二：队列,10915,"```cpp
#include ""mqueue.h""

// 函数queueEmpty：判断队列iq是否为空
// 参数：iq-整数队列
// 返回值：true-队列iq为空，false-iq不为空
bool queueEmpty(intQueue iq)
{
    // 请在此添加代码，补全函数queueEmpty
    /********** Begin *********/ 
    return (iq==NULL);  // iq为NULL，则队列为空

    /********** End **********/
}

// 函数enQueue：将整数num入列到iq
// 参数：iq-整数队列，传引用，入列有可能改变队列头指针，num-入列的整数
// 返回值：无，只要还有内存，入列总会成功
void enQueue(intQueue &iq, int num)
{
    // 请在此添加代码，补全函数enQueue
    /********** Begin *********/

    // 准备结点
    node *t=new node;
    t->data=num;
    t->next=NULL;

    // 结点插入到尾部
    iq = insertTail(iq,t);

    /********** End **********/
}

// 函数deQueue：出列
// 参数：iq-整数队列，传引用，出列有可能改变队列头指针
// 返回值：出列结点的数据，如果队列为空，返回-1
int deQueue(intQueue &iq)
{
    // 请在此添加代码，补全函数deQueue
    /********** Begin *********/
    if(queueEmpty(iq))
        return -1;

    // 获取队列头结点的数据
    int n = iq->data;

    // 删除队列头结点（出列）
    iq = delAt(iq,0);

    // 返回出列数据
    return n;

    /********** End **********/
}
```"
808,101,C&C++线性表实训,kwmnobry92sv,线性表应用三：集合,10916,"```cpp
#include ""mset.h""

// 函数unionSet：求集合a和b的并集
// 参数：a-集合，b-集合
// 返回值：集合（集合a和b的并集）
intSet unionSet(intSet a, intSet b)
{
    // 请在此添加代码，补全函数unionSet
    /********** Begin *********/

    // 准备空集合
    intSet c=NULL;

    // 把a中每一个元素加入c中
    node *p=a;
    while(p)
    {
        addElement(c,p->data);
        p=p->next;
    }

    // 把b中每一个元素加入c中
    p=b;
    while(p)
    {
        addElement(c,p->data);
        p=p->next;
    }
    return c;
    /********** End **********/
}

// 函数intersection：求集合a和b的交集
// 参数：a-集合，b-集合
// 返回值：集合（集合a和b的交集）
intSet intersection(intSet a, intSet b)
{
    // 请在此添加代码，补全函数intersection
    /********** Begin *********/

    // 准备空集合
    intSet c=NULL;
    // 查看a中每一个元素
    node *p=a;
    while(p)
    {
        if(search(b,p->data))
        {// 也在b中，则选入集合c
            addElement(c,p->data);
        }
        p=p->next;
    }
    return c;
    /********** End **********/
}

// 函数addElement：在集合is中增加元素num
// 参数：is-集合，num-要增加的元素
// 返回值：无
void addElement(intSet &is, int num)
{
    // 请在此添加代码，补全函数addElement
    /********** Begin *********/

    // 首先确认num是否在is中
    node *p=search(is,num);
    if(p!=NULL)
        return;

    // 准备结点
    p=new node;
    p->data = num;
    p->next = NULL;
    is = insertHead(is,p);
    /********** End **********/
}
```"
809,4288,C&C++线性表实训,ujfzcqrloap8,顺序构建线性表,12440,"```cpp
#include ""linearList.h""

node *insertTail(node *h, node *t)
{
    // 请在此添加代码，补全函数insertTail
    /********** Begin *********/
    if(h == NULL) // 空链表单独处理
    {
        t->next = NULL; // 链表尾指针置为NULL
        return t; // 返回第一个结点的地址（即链表头指针）
    }
    // 非空链表的情况
    node *p = h;
    // 让p指向最后一个结点
    while(p->next)
        p = p->next;
    p->next = t; // 让最后一个结点的指针域指向结点t
    t->next = NULL; // 链表尾指针置为NULL
    return h;  // 返回第一个结点的地址（即链表头指针）

    /********** End **********/
}
```"
810,4288,C&C++线性表实训,4rzfv5hg8cp7,逆序构建线性表,12441,"```cpp
#include ""linearList.h""

node * insertHead(node *h, node *t)
{
    // 请在此添加代码，补全函数insertHead
    /********** Begin *********/
    t->next = h;
    return t;

    /********** End **********/
}
```"
811,4288,C&C++线性表实训,7lvruyn6qkto,排序构建线性表,12442,"```cpp
#include ""linearList.h""

node * insertSort(node *h, node *t)
{
    // 请在此添加代码，补全函数insertSort
    /********** Begin *********/
    node *p = NULL, *q = h;  // 定位第一个插入点：链首

    // 查找插入点
    while(q && q->data < t->data)
    {// 两个指针并行后移
        p = q;
        q = q->next;
    }

    // 插入链首
    if(p == NULL)
    {
        t->next = h;
        return t;
    }

    // 插入链尾
    if(q == NULL)
    {
        p->next = t;
        t->next = NULL;
    }

    // 插入p、q之间
    t->next = q;
    p->next = t;
    return h;

    /********** End **********/
}
```"
812,4288,C&C++线性表实训,r67wlcykvzap,查找元素,12443,"```cpp
#include ""linearList.h""

node * search(node * h, int num)
{
    // 请在此添加代码，补全函数search
    /********** Begin *********/
    while(h)
    {// h为真，即h指向的结点存在
        if(h->data == num)
            return h;
        h = h->next;  // 将该结点的指针域赋值给h，h就指向了下一个结点
    }
    return NULL; // 没找到包含num的结点

    /********** End **********/
}
```"
813,4288,C&C++线性表实训,fklab26w5vio,删除指定位置的结点,12444,"```cpp
#include ""linearList.h""

node * delAt(node * h, int i)
{
    // 请在此添加代码，补全函数delAt
    /********** Begin *********/
    // 序号非法，不删除
    if(i<0)
        return h;
    node *p = NULL, *q = h; // 定位删除结点，试图让q指向要删除结点，p指向其前面的结点
    for(int k = 0; k < i; k++)
    {
        if(q->next == NULL) // 后面没有结点了，序号非法
            return h;
        p = q;
        q = q->next;
    }
    if(p) // p指向的结点存在，不是删除首结点
    {
        // 删除q指向的结点，让p指向结点的指针域指向q的后续结点
        p->next = q->next;
        // 释放空间
        delete q;
        return h;
    }
    else // 删除首结点
    {
        h = q->next; // 下一个结点成了首结点
        // 释放空间
        delete q;
        return h;
    }

    /********** End **********/
}
```"
814,4288,C&C++线性表实训,fnjc2srvz4ht,删除包含特定数据的结点,12445,"```cpp
#include ""linearList.h""

node * delHas(node * h, int n)
{
    // 请在此添加代码，补全函数delHas
    /********** Begin *********/
    node *p = NULL, *q = h;  // p为要删除结点的前结点，q指向要删除结点
    while(q)
    {// h为真，即h指向的结点存在
        if(q->data == n)
            break; // 找到了
        if(q->next == NULL)  // 后面没有结点了，没有结点满足条件
            return h;  // 不删除，直接返回
        // 继续往后找，两个指针一起后移
        p = q;
        q = q->next;
    }
    // 删除q指向的结点
    if(p == NULL)  // 删除头结点
    {
        h = q->next;  // 下一个结点变成头结点
        delete q;  // 删除结点
        return h;
    }
    // 不是头结点
    p->next = q->next;  // 把q指向结点的指针域（q后面结点的地址）赋值给p指向结点的指针域
    return h;

    /********** End **********/
}
```"
815,4288,C&C++线性表实训,jxpm5igzv3ny,线性表长度,12446,"```cpp
#include ""linearList.h""

int listLength(node * h)
{
    // 请在此添加代码，补全函数listLength
    /********** Begin *********/
    int n = 0;
    while(h)
    {
        n++;
        h = h->next;
    }
    return n;

    /********** End **********/
}
```"
816,4288,C&C++线性表实训,ue36vpfs5gbh,线性表应用一：栈,12447,"```cpp
#include ""mstack.h""

// 函数empty：判断栈sk是否为空
// 参数：sk-栈
// 返回值：true-sk为空，false-sk不为空
bool empty(intStack sk)
{
    // 请在此添加代码，补全函数empty
    /********** Begin *********/
    return (listLength(sk) == 0);  // 链表长度为0，则栈为空

    /********** End **********/
}

// 函数pop：弹栈
// 参数：sk-栈，传引用，弹栈可能会改变sk的值
// 返回值：弹栈的弹出的整数，如果栈空，返回-1
int pop(intStack &sk)
{
    // 请在此添加代码，补全函数pop
    /********** Begin *********/
    if(empty(sk))  // 栈空，返回-1
        return -1;
    int n = sk->data;  // 获取栈顶结点(链首结点)的数据
    sk = delAt(sk,0);  // 删除首结点（弹栈，第一个结点出栈）
    return n;  // 返回弹栈数据

    /********** End **********/
}

// 函数push：压栈，将整数n压入栈sk中
// 参数：sk-栈，传引用，压栈会改变sk的值，n-要压栈的整数
// 返回值：无，采用链表实现栈，只要还有内存，压栈都会成功
void push(intStack &sk, int n)
{
    // 请在此添加代码，补全函数push
    /********** Begin *********/

    // 创建要压栈的结点
    node *p = new node;
    p->data = n;

    // 压栈（插入链首）
    sk = insertHead(sk,p);

    /********** End **********/
}
```"
817,4288,C&C++线性表实训,znfl39jmx2gq,线性表应用二：队列,12448,"```cpp
#include ""mqueue.h""

// 函数queueEmpty：判断队列iq是否为空
// 参数：iq-整数队列
// 返回值：true-队列iq为空，false-iq不为空
bool queueEmpty(intQueue iq)
{
    // 请在此添加代码，补全函数queueEmpty
    /********** Begin *********/ 
    return (iq==NULL);  // iq为NULL，则队列为空

    /********** End **********/
}

// 函数enQueue：将整数num入列到iq
// 参数：iq-整数队列，传引用，入列有可能改变队列头指针，num-入列的整数
// 返回值：无，只要还有内存，入列总会成功
void enQueue(intQueue &iq, int num)
{
    // 请在此添加代码，补全函数enQueue
    /********** Begin *********/

    // 准备结点
    node *t=new node;
    t->data=num;
    t->next=NULL;

    // 结点插入到尾部
    iq = insertTail(iq,t);

    /********** End **********/
}

// 函数deQueue：出列
// 参数：iq-整数队列，传引用，出列有可能改变队列头指针
// 返回值：出列结点的数据，如果队列为空，返回-1
int deQueue(intQueue &iq)
{
    // 请在此添加代码，补全函数deQueue
    /********** Begin *********/
    if(queueEmpty(iq))
        return -1;

    // 获取队列头结点的数据
    int n = iq->data;

    // 删除队列头结点（出列）
    iq = delAt(iq,0);

    // 返回出列数据
    return n;

    /********** End **********/
}
```"
818,4288,C&C++线性表实训,v4gaou6mw7pq,线性表应用三：集合,12449,"```cpp
#include ""mset.h""

// 函数unionSet：求集合a和b的并集
// 参数：a-集合，b-集合
// 返回值：集合（集合a和b的并集）
intSet unionSet(intSet a, intSet b)
{
    // 请在此添加代码，补全函数unionSet
    /********** Begin *********/

    // 准备空集合
    intSet c=NULL;

    // 把a中每一个元素加入c中
    node *p=a;
    while(p)
    {
        addElement(c,p->data);
        p=p->next;
    }

    // 把b中每一个元素加入c中
    p=b;
    while(p)
    {
        addElement(c,p->data);
        p=p->next;
    }
    return c;
    /********** End **********/
}

// 函数intersection：求集合a和b的交集
// 参数：a-集合，b-集合
// 返回值：集合（集合a和b的交集）
intSet intersection(intSet a, intSet b)
{
    // 请在此添加代码，补全函数intersection
    /********** Begin *********/

    // 准备空集合
    intSet c=NULL;
    // 查看a中每一个元素
    node *p=a;
    while(p)
    {
        if(search(b,p->data))
        {// 也在b中，则选入集合c
            addElement(c,p->data);
        }
        p=p->next;
    }
    return c;
    /********** End **********/
}

// 函数addElement：在集合is中增加元素num
// 参数：is-集合，num-要增加的元素
// 返回值：无
void addElement(intSet &is, int num)
{
    // 请在此添加代码，补全函数addElement
    /********** Begin *********/

    // 首先确认num是否在is中
    node *p=search(is,num);
    if(p!=NULL)
        return;

    // 准备结点
    p=new node;
    p->data = num;
    p->next = NULL;
    is = insertHead(is,p);
    /********** End **********/
}
```"
819,102,C&C++文件实训,pliqffmozv3y,使用FILE结构操作文本文件,10918,"```cpp
#include <stdio.h>

// 函数extractDigit的功能：从文件a.txt中提取数值写入文件b.txt中
void extractDigit();

// 请在此添加代码，实现extractDigit函数
/********** Begin *********/

char readADigit(FILE *fi)
{
    char c = fgetc(fi);  // 从文件读取一个字符
    if(c==EOF)  // 是结束符则返回
        return EOF;
    while(c>'9' || c<'0')  // 如果不是数字字符，则继续读取下一个字符
    {
        c = fgetc(fi);  // 读取下一个字符
        if(c==EOF)  // 是结束符则返回
            return EOF;
    }
    return c;  // 返回读取的数字字符
}

// 函数extractDigit的功能：从文件a.txt中提取数值写入文件b.txt中
void extractDigit()
{
    FILE *fi = fopen(""a.txt"",""r"");  // 以读的方式打开文件a.txt
    FILE *fo = fopen(""b.txt"",""w"");  // 以写的方式打开文件b.txt
    if(fi==NULL || fo==NULL)  // 如果某个文件打开失败，则返回
        return;
    char c;
    int num=0,k=0;
    c = readADigit(fi);  // 读取一个数字字符
    while(c!=EOF)
    {
        num=num*10+c-'0';  // 计算数字字符构成的整数
        k++;
        if(k==3)  // 已经三位了
        {
            fprintf(fo,""%d "",num);  // 将计算的整数写入文件指针fo指向的文件
            k=0;  // 重新计数
            num=0;  // 重新计算
    }
        c = readADigit(fi);  // 读取下一个数字字符
    }
    if(k!=0)  // 如果有不到三位的数值，则写入文件b.txt
    {
        fprintf(fo,""%d "",num);
    }
    fclose(fi);  // 关闭文件fi
    fclose(fo);  // 关闭文件fo
}
/********** End **********/
```"
820,102,C&C++文件实训,chiw58fnt9ue,使用FILE结构操作二进制文件,10925,"```cpp
int readClothing(FILE *fp, clothing cloth[])
{
    // 请在此添加代码，补全函数readClothing
    /********** Begin *********/
    int n;
    // 读一个整数（服装信息数）
    fread(&n,sizeof(n),1,fp);

    // 读出n种服装信息到cloth中
    fread(cloth,sizeof(clothing),n,fp);
    return n;

    /********** End **********/
}
```"
821,102,C&C++文件实训,ft8jbhps2km3,使用文件流操作文本文件,10926,"```cpp
#include <iostream>
#include <fstream>
using namespace std;

//函数count：统计文件fin中每种服装的销售总额，并写入文件fout中
//参数fin：文件每种服装的销售情况，fout：每种服装销售总额的写入文件
//返回值：无
//说明：文件fin中，每种服装信息占一行，分别为服装编号，销售件数，每件的销售价格（整型）。
//文件fout：每种服装统计信息占一行，分别为服装编号，销售总额（整型）,中间用一个空格隔开。

void count(ifstream & fin, ofstream & fout)
{
    // 请在此添加代码，补全函数count
    /********** Begin *********/
    char s[100];
    fin>>s;
    while(!fin.eof())
    {
        int i,n,c=0,t;
        fin>>n;
        for(i=0;i<n;i++)
        {
            fin>>t;
            c+=t;
        }
        fout<<s<<"" ""<<c<<endl;
        fin>>s;
    }

    /********** End **********/
}
```"
822,102,C&C++文件实训,aj6yicmr7eo5,使用文件流操作二进制文件,10927,"```cpp
int getNumber(ifstream &ifile, char *label)
{
    // 请在此添加代码，补全函数getNumber
    /********** Begin *********/
    clothing  t;
    // 读出种服装信息到t中
    ifile.read((char*)&t,sizeof(clothing));
    while(!ifile.eof())
    {
        if(strcmp(label, t.label)==0)
            return t.numberRemaining;
        ifile.read((char*)&t,sizeof(clothing));
    }
    return 0;
    /********** End **********/
}
```"
823,4289,C&C++文件实训,lmknjh37v8pg,使用FILE结构操作文本文件,12450,"```cpp
#include <stdio.h>

// 函数extractDigit的功能：从文件a.txt中提取数值写入文件b.txt中
void extractDigit();

// 请在此添加代码，实现extractDigit函数
/********** Begin *********/

char readADigit(FILE *fi)
{
    char c = fgetc(fi);  // 从文件读取一个字符
    if(c==EOF)  // 是结束符则返回
        return EOF;
    while(c>'9' || c<'0')  // 如果不是数字字符，则继续读取下一个字符
    {
        c = fgetc(fi);  // 读取下一个字符
        if(c==EOF)  // 是结束符则返回
            return EOF;
    }
    return c;  // 返回读取的数字字符
}

// 函数extractDigit的功能：从文件a.txt中提取数值写入文件b.txt中
void extractDigit()
{
    FILE *fi = fopen(""a.txt"",""r"");  // 以读的方式打开文件a.txt
    FILE *fo = fopen(""b.txt"",""w"");  // 以写的方式打开文件b.txt
    if(fi==NULL || fo==NULL)  // 如果某个文件打开失败，则返回
        return;
    char c;
    int num=0,k=0;
    c = readADigit(fi);  // 读取一个数字字符
    while(c!=EOF)
    {
        num=num*10+c-'0';  // 计算数字字符构成的整数
        k++;
        if(k==3)  // 已经三位了
        {
            fprintf(fo,""%d "",num);  // 将计算的整数写入文件指针fo指向的文件
            k=0;  // 重新计数
            num=0;  // 重新计算
    }
        c = readADigit(fi);  // 读取下一个数字字符
    }
    if(k!=0)  // 如果有不到三位的数值，则写入文件b.txt
    {
        fprintf(fo,""%d "",num);
    }
    fclose(fi);  // 关闭文件fi
    fclose(fo);  // 关闭文件fo
}
/********** End **********/
```"
824,4289,C&C++文件实训,9azcrkxu3eyo,使用FILE结构操作二进制文件,12451,"```cpp
int readClothing(FILE *fp, clothing cloth[])
{
    // 请在此添加代码，补全函数readClothing
    /********** Begin *********/
    int n;
    // 读一个整数（服装信息数）
    fread(&n,sizeof(n),1,fp);

    // 读出n种服装信息到cloth中
    fread(cloth,sizeof(clothing),n,fp);
    return n;

    /********** End **********/
}
```"
825,4289,C&C++文件实训,oix48mvlhn2b,使用文件流操作文本文件,12452,"```cpp
#include <iostream>
#include <fstream>
using namespace std;

//函数count：统计文件fin中每种服装的销售总额，并写入文件fout中
//参数fin：文件每种服装的销售情况，fout：每种服装销售总额的写入文件
//返回值：无
//说明：文件fin中，每种服装信息占一行，分别为服装编号，销售件数，每件的销售价格（整型）。
//文件fout：每种服装统计信息占一行，分别为服装编号，销售总额（整型）,中间用一个空格隔开。

void count(ifstream & fin, ofstream & fout)
{
    // 请在此添加代码，补全函数count
    /********** Begin *********/
    char s[100];
    fin>>s;
    while(!fin.eof())
    {
        int i,n,c=0,t;
        fin>>n;
        for(i=0;i<n;i++)
        {
            fin>>t;
            c+=t;
        }
        fout<<s<<"" ""<<c<<endl;
        fin>>s;
    }

    /********** End **********/
}
```"
826,4289,C&C++文件实训,jriz8ymk7vua,使用文件流操作二进制文件,12453,"```cpp
int getNumber(ifstream &ifile, char *label)
{
    // 请在此添加代码，补全函数getNumber
    /********** Begin *********/
    clothing  t;
    // 读出种服装信息到t中
    ifile.read((char*)&t,sizeof(clothing));
    while(!ifile.eof())
    {
        if(strcmp(label, t.label)==0)
            return t.numberRemaining;
        ifile.read((char*)&t,sizeof(clothing));
    }
    return 0;
    /********** End **********/
}
```"
827,76,C&C++函数实训,i5gs4njvroxm,登月纸桥,110,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// foldTimes-计算建纸桥的折叠次数
// 参数：dis-星际距离（千米），thick-纸的厚度（毫米）
// 返回值：建桥需要折叠的次数）
int foldTimes(double dis, double thick);

int main()
{
    double dis, thick;
    cin >> dis >> thick;
    cout << ""需要折叠"" << foldTimes(dis,thick) << ""次"" << endl;

    return 0;
}

int foldTimes(double dis, double thick)
{
    // 请在这里补充代码，实现函数foldTimes
    /********** Begin *********/
    // 调整单位为米
    thick = thick / 1000.0;

    // 调整单位为米
    dis = dis * 1000.0;

    // 折叠次数
    int t = 0;
    while(thick < dis)
    {
        t++;
        thick *= 2;
    }
    return t;
    /********** End **********/
}
```"
828,76,C&C++函数实训,i52ob6zj4wnf,几点几分了？,111,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

void whatTime(int secs, int &h, int &m, int &s)
{
    // 请在这里补充代码，设计并实现函数whatTime,使main函数中的函数调用正确
    /********** Begin *********/
    h = secs / 3600;
    secs = secs % 3600;
    m = secs / 60;
    s = secs % 60;
    /********** End **********/
}

int main()
{
    // secs秒表上的秒数
    int secs;

    // 当前时间:h-小时，m-分，s-秒
    int h, m, s;

    // 输入秒表上的秒数
    cin >> secs;

    // 计算当前时间
    whatTime(secs,h,m,s);

    // 输出当前时间
    cout << h << "":"" << m << "":"" << s << endl;

    return 0;
}
```"
829,76,C&C++函数实训,ha5uplmyw6t4,这天星期几?,112,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数leapYear
int leapYear(int y)
{
    if(y % 4 == 0 && y % 100 != 0 || y % 400 == 0)
        return 1;
    return 0;
}

// 函数whatDay：计算某年某月的号是星期几
// 参数：year-年，month-月
// 返回值：--7分别表示星期一到星期日
int whatDay(int year, int month)
{
    // 请在这里补充代码，实现函数whatDay
    /********** Begin *********/

    // 1年月日是星期一
    int w = 1;
    int i;

    // 1到year-1都是全年
    for(i = 1; i < year; i++)
    {
        if(leapYear(i))
            w += 366;
        else
            w += 365;
    }
    switch(month)
    {
    case 12: // 加月的
        w += 30;
    case 11: // 加月的
        w += 31;
    case 10: // 加月的
        w += 30;
    case 9:  // 加月的
        w += 31;
    case 8:  // 加月的
        w += 31;
    case 7:  // 加月的
        w += 30;
    case 6:  // 加月的
        w += 31;
    case 5:  // 加月的
        w += 30;
    case 4:  // 加月的
        w += 31;
    case 3:  // 加月的
        if(leapYear(year))
            w += 29;
        else
            w += 28;
    case 2:  // 加月的天
        w += 31;
    case 1:  // 1月不加了
        ;
    }

    // 得到-6，其中为星期天
    w = w % 7;

    // 调整星期天
    if(w == 0)
        w = 7;
    return w;

    /********** End **********/
}

int main()
{
    // 年、月、星期几
    int y, m, xq;

    // 输入年月
    cin >> y >> m;

    // 计算星期几
    xq = whatDay(y,m);

    // 输出星期
    cout << y << ""年"" << m << ""月1日是星期"";
    if(xq == 7)
        cout << ""日"" << endl;
    else
        cout << xq << endl;

    return 0;
}
```"
830,76,C&C++函数实训,t7rgsbopj3xv,打印日历,113,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

// 函数printMonth：按要求的格式打印某年某月的日历
// 参数：year-年，month-月
// 返回值：无
void printMonth(int year, int month);

// leapYear：判断闰年
// 参数：y-年
// 返回值：1-是闰年，0-不是闰年
int leapYear(int y)
{
    if(y % 4 == 0 && y % 100 != 0 || y % 400 == 0)
        return 1;
    return 0;
}

// 函数whatDay:计算某年某月的1号是星期几
// 参数：year-年，month-月
// 返回值：1到7--星期1到星期日
int whatDay(int year, int month)
{
    // 1年月日是星期一
    int w = 1;
    int i;

    // 1到year-1都是全年
    for(i = 1; i < year; i++)
    {
        if(leapYear(i))
            w += 366;
        else
            w += 365;
    }
    switch(month)
    {
    case 12: // 加月的
        w += 30;
    case 11: // 加月的
        w += 31;
    case 10: // 加月的
        w += 30;
    case 9:  // 加月的
        w += 31;
    case 8:  // 加月的
        w += 31;
    case 7:  // 加月的
        w += 30;
    case 6:  // 加月的
        w += 31;
    case 5:  // 加月的
        w += 30;
    case 4:  // 加月的
        w += 31;
    case 3:  // 加月的
        if(leapYear(year))
            w += 29;
        else
            w += 28;
    case 2:  // 加月的天
        w += 31;
    case 1:  // 1月不加了
        ;
    }

    // 得到-6，其中为星期天
    w = w % 7;

    // 调整星期天
    if(w == 0)
        w = 7;
    return w;
}

// 请在下面补充代码，实现函数printMonth
/*************** Begin **************/

// 函数days：计算某年某月有多少天
// 参数：year-年，month-月
// 返回值：该年该月的天数
int days(int year, int month)
{
    switch(month)
    {
    case 1:case 3:case 5:case 7: case 8:case 10: case 12:
        return 31;
    case 2: // 考虑闰年
        if(leapYear(year))
            return 29;
        return 28;
    default:
        return 30;
	}
}

// 函数printMonth
void printMonth(int year, int month)
{
    // 输出头部信息
    printf(""  一  二  三  四  五  六  日\n"");

    // 这个月的1号是星期几
    int w = whatDay(year, month);
    int i;

    // 1号前输出w-1个空位
    for(i = 0; i < w - 1; i++)
        printf(""%4c"",' ');

    // 输出每一个日期
    for(i = 1; i <= days(year,month); i++)
    {
        printf(""%4d"",i);
        // 空位数加日期数是7的倍数则输出换行符
        if((i + w - 1) % 7 == 0)
            printf(""\n"");
    }
    // 如果最后没有输出换行符，则输出一个
    if((i + w - 1) % 7 != 0)
        printf(""\n"");
}

/*************** End **************/

int main()
{
    // 年、月
    int y, m;

    // 输入年月
    cin >> y >> m;

    // 输出该年月的日历
    printMonth(y,m);

    return 0;
}
```"
831,76,C&C++函数实训,kabmesfgil4y,拆开了输出整数,114,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 递归函数splitNum：顺序输出n的各位数字，每个数字占一行
// 返回值：无
void splitNum(unsigned int n)
{
    // 请在这里补充代码，实现递归函数splitNum
    /********** Begin *********/
    if(n>9)
        splitNum(n/10);
    cout<<n%10<<endl;

    /********** End **********/
}

int main()
{
    unsigned n;
    // 输入正整数n
    cin >> n;

    // 调用splitNum函数，顺序输出n的各位数字
    splitNum(n);

    return 0;
}
```"
832,76,C&C++函数实训,u3wmy4lr2pns,递归求P函数,115,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数funP：实现数学函数P函数
// 返回值：返回P(n,x)的值
double funP(int n, double x)
{
    // 请在这里补充代码，实现递归函数funP
    /********** Begin *********/
    if(n == 0)
        return 1;
    if(n == 1)
        return x;
    return ((2 * n - 1) * funP(n - 1, x) - (n - 1) * funP(n - 2, x)) / n;

    /********** End **********/
}

int main()
{
    int n;
    double x;
    // 输入n、x
    cin >> n >> x;

    // 输出P(n,x)
    cout << ""P(""<<n<<"", ""<<x<<"")="" << funP(n,x) << endl;

    return 0;
}
```"
833,4284,C&C++函数实训,yco4z2qeltrb,登月纸桥,12418,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// foldTimes-计算建纸桥的折叠次数
// 参数：dis-星际距离（千米），thick-纸的厚度（毫米）
// 返回值：建桥需要折叠的次数）
int foldTimes(double dis, double thick);

int main()
{
    double dis, thick;
    cin >> dis >> thick;
    cout << ""需要折叠"" << foldTimes(dis,thick) << ""次"" << endl;

    return 0;
}

int foldTimes(double dis, double thick)
{
    // 请在这里补充代码，实现函数foldTimes
    /********** Begin *********/
    // 调整单位为米
    thick = thick / 1000.0;

    // 调整单位为米
    dis = dis * 1000.0;

    // 折叠次数
    int t = 0;
    while(thick < dis)
    {
        t++;
        thick *= 2;
    }
    return t;
    /********** End **********/
}
```"
834,4284,C&C++函数实训,jlnis42zyfxt,几点几分了？,12419,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

void whatTime(int secs, int &h, int &m, int &s)
{
    // 请在这里补充代码，设计并实现函数whatTime,使main函数中的函数调用正确
    /********** Begin *********/
    h = secs / 3600;
    secs = secs % 3600;
    m = secs / 60;
    s = secs % 60;
    /********** End **********/
}

int main()
{
    // secs秒表上的秒数
    int secs;

    // 当前时间:h-小时，m-分，s-秒
    int h, m, s;

    // 输入秒表上的秒数
    cin >> secs;

    // 计算当前时间
    whatTime(secs,h,m,s);

    // 输出当前时间
    cout << h << "":"" << m << "":"" << s << endl;

    return 0;
}
```"
835,4284,C&C++函数实训,klf4i3n5ujzy,这天星期几?,12420,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数leapYear
int leapYear(int y)
{
    if(y % 4 == 0 && y % 100 != 0 || y % 400 == 0)
        return 1;
    return 0;
}

// 函数whatDay：计算某年某月的号是星期几
// 参数：year-年，month-月
// 返回值：--7分别表示星期一到星期日
int whatDay(int year, int month)
{
    // 请在这里补充代码，实现函数whatDay
    /********** Begin *********/

    // 1年月日是星期一
    int w = 1;
    int i;

    // 1到year-1都是全年
    for(i = 1; i < year; i++)
    {
        if(leapYear(i))
            w += 366;
        else
            w += 365;
    }
    switch(month)
    {
    case 12: // 加月的
        w += 30;
    case 11: // 加月的
        w += 31;
    case 10: // 加月的
        w += 30;
    case 9:  // 加月的
        w += 31;
    case 8:  // 加月的
        w += 31;
    case 7:  // 加月的
        w += 30;
    case 6:  // 加月的
        w += 31;
    case 5:  // 加月的
        w += 30;
    case 4:  // 加月的
        w += 31;
    case 3:  // 加月的
        if(leapYear(year))
            w += 29;
        else
            w += 28;
    case 2:  // 加月的天
        w += 31;
    case 1:  // 1月不加了
        ;
    }

    // 得到-6，其中为星期天
    w = w % 7;

    // 调整星期天
    if(w == 0)
        w = 7;
    return w;

    /********** End **********/
}

int main()
{
    // 年、月、星期几
    int y, m, xq;

    // 输入年月
    cin >> y >> m;

    // 计算星期几
    xq = whatDay(y,m);

    // 输出星期
    cout << y << ""年"" << m << ""月1日是星期"";
    if(xq == 7)
        cout << ""日"" << endl;
    else
        cout << xq << endl;

    return 0;
}
```"
836,4284,C&C++函数实训,nb28ow6pgvts,打印日历,12421,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

// 函数printMonth：按要求的格式打印某年某月的日历
// 参数：year-年，month-月
// 返回值：无
void printMonth(int year, int month);

// leapYear：判断闰年
// 参数：y-年
// 返回值：1-是闰年，0-不是闰年
int leapYear(int y)
{
    if(y % 4 == 0 && y % 100 != 0 || y % 400 == 0)
        return 1;
    return 0;
}

// 函数whatDay:计算某年某月的1号是星期几
// 参数：year-年，month-月
// 返回值：1到7--星期1到星期日
int whatDay(int year, int month)
{
    // 1年月日是星期一
    int w = 1;
    int i;

    // 1到year-1都是全年
    for(i = 1; i < year; i++)
    {
        if(leapYear(i))
            w += 366;
        else
            w += 365;
    }
    switch(month)
    {
    case 12: // 加月的
        w += 30;
    case 11: // 加月的
        w += 31;
    case 10: // 加月的
        w += 30;
    case 9:  // 加月的
        w += 31;
    case 8:  // 加月的
        w += 31;
    case 7:  // 加月的
        w += 30;
    case 6:  // 加月的
        w += 31;
    case 5:  // 加月的
        w += 30;
    case 4:  // 加月的
        w += 31;
    case 3:  // 加月的
        if(leapYear(year))
            w += 29;
        else
            w += 28;
    case 2:  // 加月的天
        w += 31;
    case 1:  // 1月不加了
        ;
    }

    // 得到-6，其中为星期天
    w = w % 7;

    // 调整星期天
    if(w == 0)
        w = 7;
    return w;
}

// 请在下面补充代码，实现函数printMonth
/*************** Begin **************/

// 函数days：计算某年某月有多少天
// 参数：year-年，month-月
// 返回值：该年该月的天数
int days(int year, int month)
{
    switch(month)
    {
    case 1:case 3:case 5:case 7: case 8:case 10: case 12:
        return 31;
    case 2: // 考虑闰年
        if(leapYear(year))
            return 29;
        return 28;
    default:
        return 30;
	}
}

// 函数printMonth
void printMonth(int year, int month)
{
    // 输出头部信息
    printf(""  一  二  三  四  五  六  日\n"");

    // 这个月的1号是星期几
    int w = whatDay(year, month);
    int i;

    // 1号前输出w-1个空位
    for(i = 0; i < w - 1; i++)
        printf(""%4c"",' ');

    // 输出每一个日期
    for(i = 1; i <= days(year,month); i++)
    {
        printf(""%4d"",i);
        // 空位数加日期数是7的倍数则输出换行符
        if((i + w - 1) % 7 == 0)
            printf(""\n"");
    }
    // 如果最后没有输出换行符，则输出一个
    if((i + w - 1) % 7 != 0)
        printf(""\n"");
}

/*************** End **************/

int main()
{
    // 年、月
    int y, m;

    // 输入年月
    cin >> y >> m;

    // 输出该年月的日历
    printMonth(y,m);

    return 0;
}
```"
837,4284,C&C++函数实训,z8wog34f57i2,拆开了输出整数,12422,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 递归函数splitNum：顺序输出n的各位数字，每个数字占一行
// 返回值：无
void splitNum(unsigned int n)
{
    // 请在这里补充代码，实现递归函数splitNum
    /********** Begin *********/
    if(n>9)
        splitNum(n/10);
    cout<<n%10<<endl;

    /********** End **********/
}

int main()
{
    unsigned n;
    // 输入正整数n
    cin >> n;

    // 调用splitNum函数，顺序输出n的各位数字
    splitNum(n);

    return 0;
}
```"
838,4284,C&C++函数实训,p2lftejbzw39,递归求P函数,12423,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数funP：实现数学函数P函数
// 返回值：返回P(n,x)的值
double funP(int n, double x)
{
    // 请在这里补充代码，实现递归函数funP
    /********** Begin *********/
    if(n == 0)
        return 1;
    if(n == 1)
        return x;
    return ((2 * n - 1) * funP(n - 1, x) - (n - 1) * funP(n - 2, x)) / n;

    /********** End **********/
}

int main()
{
    int n;
    double x;
    // 输入n、x
    cin >> n >> x;

    // 输出P(n,x)
    cout << ""P(""<<n<<"", ""<<x<<"")="" << funP(n,x) << endl;

    return 0;
}
```"
839,4865,数据结构与算法 - 栈,o4wn2ti7lyxk,实现一个顺序存储的栈,14337,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: July 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**************************************************************/
//顺序存储的栈 实现文件
/////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""SeqStack.h""

/*创建一个栈*/
SeqStack* SS_Create(int maxlen)
{
	SeqStack* ss=(SeqStack*)malloc(sizeof(SeqStack));
	ss->data=(T*)malloc(maxlen*sizeof(T));
	ss->top=-1;
	ss->max=maxlen;
	return ss;
}

/*释放一个栈*/
void SS_Free(SeqStack* ss)
{
	free(ss->data);
	free(ss);
}

/*清空一个栈*/
void SS_MakeEmpty(SeqStack* ss)
{
	ss->top=-1;
}

bool SS_IsFull(SeqStack* stack)
// 判断栈是否为满。为满返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top+1>=stack->max;
    /********** End **********/
}
bool SS_IsEmpty(SeqStack* stack)
// 判断栈是否为空。为空返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top<0;
    /********** End **********/
}
int SS_Length(SeqStack* stack)
// 获取栈元素个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top+1;
    /********** End **********/
}
bool SS_Push(SeqStack* stack, T x)
// 将元素x进栈，若满栈则无法进栈，返回false，否则返回true
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (SS_IsFull(stack)) {
        return false;
    }
    stack->top++;
    stack->data[stack->top]=x;
    return true;
    /********** End **********/
}
bool SS_Pop(SeqStack* stack, T &item)
// 出栈的元素放入item。若出栈成功(栈不为空)，则返回true；否则(空栈)，返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (SS_IsEmpty(stack)) {
        return false;
    }
    item = stack->data[stack->top];
    stack->top--;
    return true;
    /********** End **********/
}

/*获取栈顶元素放入item中,空栈则返回false*/
bool SS_Top(SeqStack* ss, T & item)
{
	if (SS_IsEmpty(ss)) {
		return false;
	}
	item = ss->data[ss->top];
	return true;
}

/*从栈底到栈顶打印出所有元素*/
void SS_Print(SeqStack* ss)
{
	if (SS_IsEmpty(ss)) {
		printf(""stack data: Empty!\n"");
		return;
	}
	printf(""stack data (from bottom to top):"");
	int curr=0;
	while(curr<=ss->top) {
		printf("" %d"", ss->data[curr]);
		curr++;
	}
	//printf(""\n"");
}

```"
840,4865,数据结构与算法 - 栈,mxzpfhioj4tc,实现一个链接存储的栈,14338,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: June 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**************************************************************/
// 链接存储的栈实现文件

#include <stdio.h>
#include <stdlib.h>
#include ""LnkStack.h""

/*创建栈*/
LinkStack* LS_Create()
{
    LinkStack* ls=(LinkStack*)malloc(sizeof(LinkStack));
    ls->top = NULL;
    ls->len = 0;
    return ls;
}

/*释放栈*/
void LS_Free(LinkStack* ls)
{
    LNode* curr = ls->top;
    while(curr) {
        LNode* next = curr->next;
        free(curr);
        curr=next;
    }
    free(ls);
}

/*将栈变为空栈*/
void LS_MakeEmpty(LinkStack* ls)
{
    LNode* curr = ls->top;
    while(curr) {
        LNode* next = curr->next;
        free(curr);
        curr=next;
    }
    ls->top = NULL;
    ls->len = 0;
}

/*判断栈是否为空*/
/*判断栈是否为空*/
bool LS_IsEmpty(LinkStack* ls)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return ls->len == 0;
    /********** End **********/
}
/*获取栈的长度*/
int LS_Length(LinkStack* ls)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return ls->len;
    /********** End **********/
}
/*将x进栈*/
void LS_Push(LinkStack* ls, T x)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=(LNode*)malloc(sizeof(LNode));
    node->data=x;
    node->next=ls->top;
    ls->top = node;
    ls->len ++;
    /********** End **********/
}
/*出栈。出栈元素放入item；如果空栈，将返回false*/
bool LS_Pop(LinkStack* ls, T& item)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=ls->top;
    if (node==NULL) {
        return false;
    }
    item = node->data;
    ls->top = node->next;
    ls->len --;
    free(node);
    return true;
    /********** End **********/
}
/*读栈顶元素放入item。如果空栈，将返回false*/
bool LS_Top(LinkStack* ls, T& item)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=ls->top;
    if (node==NULL) {
        return false;
    }
    item = node->data;
    return true;
    /********** End **********/
}

/*从栈顶到栈底打印各结点数据*/
void LS_Print(LinkStack* ls)
{
    if (ls->len==0){ 
        printf(""The stack: Empty!"");
        return;
    }
    printf(""The stack (from top to bottom):"");
    LNode* curr=ls->top;
    while(curr) {
        printf("" %d"", curr->data);
         
        curr=curr->next;
    }
   // printf(""\n"");
}

```"
841,118,数据结构与算法 - 栈,iwufr4lynco6,实现一个顺序存储的栈,10970,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: July 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**************************************************************/
//顺序存储的栈 实现文件
/////////////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include ""SeqStack.h""

/*创建一个栈*/
SeqStack* SS_Create(int maxlen)
{
	SeqStack* ss=(SeqStack*)malloc(sizeof(SeqStack));
	ss->data=(T*)malloc(maxlen*sizeof(T));
	ss->top=-1;
	ss->max=maxlen;
	return ss;
}

/*释放一个栈*/
void SS_Free(SeqStack* ss)
{
	free(ss->data);
	free(ss);
}

/*清空一个栈*/
void SS_MakeEmpty(SeqStack* ss)
{
	ss->top=-1;
}

bool SS_IsFull(SeqStack* stack)
// 判断栈是否为满。为满返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top+1>=stack->max;
    /********** End **********/
}
bool SS_IsEmpty(SeqStack* stack)
// 判断栈是否为空。为空返回true，否则返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top<0;
    /********** End **********/
}
int SS_Length(SeqStack* stack)
// 获取栈元素个数
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return stack->top+1;
    /********** End **********/
}
bool SS_Push(SeqStack* stack, T x)
// 将元素x进栈，若满栈则无法进栈，返回false，否则返回true
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (SS_IsFull(stack)) {
        return false;
    }
    stack->top++;
    stack->data[stack->top]=x;
    return true;
    /********** End **********/
}
bool SS_Pop(SeqStack* stack, T &item)
// 出栈的元素放入item。若出栈成功(栈不为空)，则返回true；否则(空栈)，返回false。
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if (SS_IsEmpty(stack)) {
        return false;
    }
    item = stack->data[stack->top];
    stack->top--;
    return true;
    /********** End **********/
}

/*获取栈顶元素放入item中,空栈则返回false*/
bool SS_Top(SeqStack* ss, T & item)
{
	if (SS_IsEmpty(ss)) {
		return false;
	}
	item = ss->data[ss->top];
	return true;
}

/*从栈底到栈顶打印出所有元素*/
void SS_Print(SeqStack* ss)
{
	if (SS_IsEmpty(ss)) {
		printf(""stack data: Empty!\n"");
		return;
	}
	printf(""stack data (from bottom to top):"");
	int curr=0;
	while(curr<=ss->top) {
		printf("" %d"", ss->data[curr]);
		curr++;
	}
	//printf(""\n"");
}

```"
842,118,数据结构与算法 - 栈,7efk853tmbjx,实现一个链接存储的栈,10971,"本关任务对应参考代码实现如下：
```cpp
/*************************************************************
    date: June 2017
    copyright: Zhu En（祝恩）
    DO NOT distribute this code.
**************************************************************/
// 链接存储的栈实现文件

#include <stdio.h>
#include <stdlib.h>
#include ""LnkStack.h""

/*创建栈*/
LinkStack* LS_Create()
{
    LinkStack* ls=(LinkStack*)malloc(sizeof(LinkStack));
    ls->top = NULL;
    ls->len = 0;
    return ls;
}

/*释放栈*/
void LS_Free(LinkStack* ls)
{
    LNode* curr = ls->top;
    while(curr) {
        LNode* next = curr->next;
        free(curr);
        curr=next;
    }
    free(ls);
}

/*将栈变为空栈*/
void LS_MakeEmpty(LinkStack* ls)
{
    LNode* curr = ls->top;
    while(curr) {
        LNode* next = curr->next;
        free(curr);
        curr=next;
    }
    ls->top = NULL;
    ls->len = 0;
}

/*判断栈是否为空*/
/*判断栈是否为空*/
bool LS_IsEmpty(LinkStack* ls)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return ls->len == 0;
    /********** End **********/
}
/*获取栈的长度*/
int LS_Length(LinkStack* ls)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    return ls->len;
    /********** End **********/
}
/*将x进栈*/
void LS_Push(LinkStack* ls, T x)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=(LNode*)malloc(sizeof(LNode));
    node->data=x;
    node->next=ls->top;
    ls->top = node;
    ls->len ++;
    /********** End **********/
}
/*出栈。出栈元素放入item；如果空栈，将返回false*/
bool LS_Pop(LinkStack* ls, T& item)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=ls->top;
    if (node==NULL) {
        return false;
    }
    item = node->data;
    ls->top = node->next;
    ls->len --;
    free(node);
    return true;
    /********** End **********/
}
/*读栈顶元素放入item。如果空栈，将返回false*/
bool LS_Top(LinkStack* ls, T& item)
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    LNode* node=ls->top;
    if (node==NULL) {
        return false;
    }
    item = node->data;
    return true;
    /********** End **********/
}

/*从栈顶到栈底打印各结点数据*/
void LS_Print(LinkStack* ls)
{
    if (ls->len==0){ 
        printf(""The stack: Empty!"");
        return;
    }
    printf(""The stack (from top to bottom):"");
    LNode* curr=ls->top;
    while(curr) {
        printf("" %d"", curr->data);
         
        curr=curr->next;
    }
   // printf(""\n"");
}

```"
843,80,C&C++数组实训,f3yg6k2zhpjw,销售波动统计,130,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // 定义变量及数组，n-销售额个数，a-销售额
    int n, a[30], i;

    // 输入销售额数量，n <= 30
    cin >> n;

    // 输入n个销售额，分别存入a[0]到a[n-1]
    for(i = 0; i < n; i++)
        cin >> a[i];

    // 请在此添加代码，计算并输出销售额的波动情况
    /********** Begin *********/
    for(i = 0; i < n - 1; i++)
    {
        if(i == 0)
            cout << a[i + 1] - a[i];
        else
            cout << "" "" << a[i + 1] - a[i];
    }
    cout << endl;

    /********** End **********/

    return 0;
}
```"
844,80,C&C++数组实训,gq5wpu3nk8h2,最大销售增幅,131,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数maxIncrease：计算销售额增幅
// 参数：s-销售额数组，n-销售额数组长度，n>1
// 返回值：销售额最大增幅
int maxIncrease(int s[], int n);

int main()
{
    // 定义变量及数组，n-销售额个数，a-销售额数组
    int n, a[30], i;

    // 输入销售额数量，n>1
    cin >> n;

    // 输入n个销售额，分别存入a[0]到a[n-1]
    for(i = 0; i < n; i++)
        cin >> a[i];

    i = maxIncrease(a,n);
    cout << ""最大销售增幅为："" << i << endl;

    return 0;
}

int maxIncrease(int s[], int n)
{
    //请在此添加代码，实现函数maxIncrease
    /********** Begin *********/
    int i, j, cha = 0;
    for(i = 0; i < n; i++)
    {
        for(j = i; j < n; j++)
        {
            if(s[j] - s[i] > cha)
                cha = s[j] - s[i];
        }
    }
    return cha;
    /********** End **********/
}
```"
845,80,C&C++数组实训,fsz43ypx9umn,猴子选大王,132,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数king：猴子选大王
// 参数：a-猴子数组n-1个猴子分别占据下标为~n-1的位置，n-数组长度
// 返回值：新猴王的下标序号
int king(int a[], int n);

int main()
{
    // 定义变量及数组，n-猴子数量，a-猴子数组
    int n, a[1000], i;

    // 输入猴子数量，n>0
    cin >> n;

    // 初始化猴子数组,n个猴子分别占据~n的位置
    a[0] = 0; // 0号位置没有猴子
    for(i = 1;i <= n; i++)
        a[i] = i;

    // 选大王啦
    i = king(a, n );
    cout << i << ""号猴子是大王。"" << endl;

    return 0;
}

int king(int a[], int n)
{
    // 请在此添加代码，实现函数king
    /********** Begin *********/
    int out = 0; // 出去了几个
    int k = 0; // 报数号
    int next = 1; // 下一个

    // 循环n-1次,每次出去一个
    while(out < n - 1)
    {
        while(a[next] == 0)
        {// 这个位置的猴子已经出去了
            next++;  // 看下一个位置的猴子
            if(next == n + 1) // 到尾部了，再回到头部
                next = 1;
        }
        k++; // 报数号加
        if(k == 3) // 要出去了
        {
            a[next] = 0;
            next = next + 1;
            if(next == n + 1)
                next = 1;
            k = 0;
            out++;
        }
        else
        {
            next = next + 1;
            if(next == n + 1)
                next = 1;
        }
    }
    // 找唯一的猴子
    int i;
    for(i = 1; i < n + 1; i++)
        if(a[i] != 0)
            return i;
    return 0;

    /********** End **********/
}
```"
846,80,C&C++数组实训,f2hl6ncx5ypm,犯二的程度,133,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数silly：计算数值有多二
// 参数：a-存储数值的字符数组，以'\0'结束，所以不需要另一个参数告诉函数数组有多长
// 返回值：数值犯二的程度
double silly(char a[]);

int main()
{
    // 定义存储数值的数组
    char s[102];

    // 输入不超过位的整数
    cin >> s;

    // 计算犯二的程度
    double sy = silly(s);

    // 输出犯二的程度
    cout << sy << endl;

    return 0;
}

double silly(char a[])
{
    // 请在此添加代码，实现函数silly
    /********** Begin *********/
    double bs=1; // 倍数
    int s=0; // 第一个数字开始的位置
    int n2=0,na=0; // 2的数量，全部位数

    // 第一位为'-'的情况
    if(a[0] == '-')
    {
        bs = bs * 1.5;
        s++;
    }

    // 判断整数的每一位
    while(a[s] != '\0')
    {
        // 判断是否为
        if(a[s] == '2')
            n2++;
        na++;
        s++;
    }

    // 判断最后一位是否为偶数
    if((a[s-1] - '0') % 2 == 0)
        bs = bs * 2;

    // 计算并返回犯二的程度
    return (double)n2 / na * bs;

    /********** End **********/
}
```"
847,80,C&C++数组实训,fui2mec5zjha,队列变换,134,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数rotateLeft：矩阵循环左移
// 参数：a-100*100的二维数组，用来存储n行n列的数组（<n<100)，存储在其~n-1行和~n-1列，
// m-循环左移的位数(0<m<n)
// 返回值：无，循环左移的结果写入原二维数组中
// 说明：传递多维数组时，形式参数中，除了第一维外，其它维的大小必须给出
// 方便编译器计算每个数组元素的地址
void rotateLeft(int a[][100],int n,int m);

int main()
{
    // 定义存储二维数组的空间
    int a[100][100];
    int n, m;

    // 输入n和m
    cin >> n >> m;

    // 输入n*n的矩阵，存储在数组a的~n-1行和~n-1列
    int i, j;
    for(i = 0; i < n; i++)
        for(j = 0; j < n; j++)
            cin >> a[i][j];

    // 循环左移
    // 说明：传递多维数组时，实在参数只需要给出数组名就可以了
    rotateLeft(a,n,m);

    // 输出循环右移的结果
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < n; j++)
            cout << "" "" << a[i][j];
        cout << endl;
    }

    return 0;
}

void rotateLeft(int a[][100],int n,int m)
{
    // 请在此添加代码，实现函数rotateLeft
    /********** Begin *********/
    int t[100];
    int i, j, k;
    for(i = 0; i < m; i++)
    {
        // 缓存第一列
        for(k = 0; k < n; k++)
            t[k] = a[k][0];

        // 左移
        for(j = 0; j < n - 1; j++)   // 列
            for(k = 0; k < n; k++) // 行
                a[k][j] = a[k][j+1];

        // t放回最后一列
        for(k = 0; k < n; k++)
            a[k][n-1] = t[k];
    }
    /********** End **********/
}
```"
848,80,C&C++数组实训,6i42mbwgtfy3,朋友圈点赞,135,"本关任务对应参考代码实现如下：
```cpp
// 请在此添加代码，写完成upvote.cpp文件
/********** Begin *********/
#include <iostream>
using namespace std;

int main()
{
    int i, j, t;
    // 定义标签表，bq[i]存放标签i出现的次数,开始都是次
    int bq[1001] = {0};
    int N, K;

    // 输入点赞文章数
    cin >> N;

    // 逐个处理每篇文章
    for(i = 0; i < N; i++)
    {
        // 输入文章标签数
        cin >> K;
        for(j = 0; j < K; j++)
        {
            // 读入一个标签
            cin >> t;
            // 加到标签表中
            bq[t]++;
        }
    }

    // 查找出现最多的最大标签
    int maxx = 0, index = -1;
    for(i = 0; i < 1001; i++)
    {
        if(bq[i] >= maxx)
        {
            maxx = bq[i];
            index = i;
        }
    }

    // 输出标签及次数
    cout << index << "" "" << maxx << endl;

    return 0;
}

// 参数：a-100*100的二维数组，用来存储n行n列的数组（<n<100)，存储在其~n-1行和~n-1列，
// m-循环右移的位数(0<m<n)
// 返回值：无，循环右移的结果写入原二维数组中
void rotateLeft(int a[][100],int n,int m)
{
    int t[100];
    int i, j, k;
    for(i = 0; i < m; i++)
    {
        // 缓存第一列
        for(k = 0; k < n;k++)
            t[k] = a[k][0];
        // 左移
        for(j = 0; j < n - 1; j++)//列
            for(k = 0; k < n; k++)//行
                a[k][j] = a[k][j+1];
        // t放回最后一列
        for(k = 0; k < n; k++)
            a[k][n-1] = t[k];
    }
}
/********** End **********/
```"
849,4285,C&C++数组实训,viw46pj2f3rf,销售波动统计,12424,"本关任务对应参考代码实现如下：
```cpp
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // 定义变量及数组，n-销售额个数，a-销售额
    int n, a[30], i;

    // 输入销售额数量，n <= 30
    cin >> n;

    // 输入n个销售额，分别存入a[0]到a[n-1]
    for(i = 0; i < n; i++)
        cin >> a[i];

    // 请在此添加代码，计算并输出销售额的波动情况
    /********** Begin *********/
    for(i = 0; i < n - 1; i++)
    {
        if(i == 0)
            cout << a[i + 1] - a[i];
        else
            cout << "" "" << a[i + 1] - a[i];
    }
    cout << endl;

    /********** End **********/

    return 0;
}
```"
850,4285,C&C++数组实训,xkhr5cpa92gb,最大销售增幅,12425,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数maxIncrease：计算销售额增幅
// 参数：s-销售额数组，n-销售额数组长度，n>1
// 返回值：销售额最大增幅
int maxIncrease(int s[], int n);

int main()
{
    // 定义变量及数组，n-销售额个数，a-销售额数组
    int n, a[30], i;

    // 输入销售额数量，n>1
    cin >> n;

    // 输入n个销售额，分别存入a[0]到a[n-1]
    for(i = 0; i < n; i++)
        cin >> a[i];

    i = maxIncrease(a,n);
    cout << ""最大销售增幅为："" << i << endl;

    return 0;
}

int maxIncrease(int s[], int n)
{
    //请在此添加代码，实现函数maxIncrease
    /********** Begin *********/
    int i, j, cha = 0;
    for(i = 0; i < n; i++)
    {
        for(j = i; j < n; j++)
        {
            if(s[j] - s[i] > cha)
                cha = s[j] - s[i];
        }
    }
    return cha;
    /********** End **********/
}
```"
851,4285,C&C++数组实训,ob3vcmurtswz,猴子选大王,12426,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数king：猴子选大王
// 参数：a-猴子数组n-1个猴子分别占据下标为~n-1的位置，n-数组长度
// 返回值：新猴王的下标序号
int king(int a[], int n);

int main()
{
    // 定义变量及数组，n-猴子数量，a-猴子数组
    int n, a[1000], i;

    // 输入猴子数量，n>0
    cin >> n;

    // 初始化猴子数组,n个猴子分别占据~n的位置
    a[0] = 0; // 0号位置没有猴子
    for(i = 1;i <= n; i++)
        a[i] = i;

    // 选大王啦
    i = king(a, n );
    cout << i << ""号猴子是大王。"" << endl;

    return 0;
}

int king(int a[], int n)
{
    // 请在此添加代码，实现函数king
    /********** Begin *********/
    int out = 0; // 出去了几个
    int k = 0; // 报数号
    int next = 1; // 下一个

    // 循环n-1次,每次出去一个
    while(out < n - 1)
    {
        while(a[next] == 0)
        {// 这个位置的猴子已经出去了
            next++;  // 看下一个位置的猴子
            if(next == n + 1) // 到尾部了，再回到头部
                next = 1;
        }
        k++; // 报数号加
        if(k == 3) // 要出去了
        {
            a[next] = 0;
            next = next + 1;
            if(next == n + 1)
                next = 1;
            k = 0;
            out++;
        }
        else
        {
            next = next + 1;
            if(next == n + 1)
                next = 1;
        }
    }
    // 找唯一的猴子
    int i;
    for(i = 1; i < n + 1; i++)
        if(a[i] != 0)
            return i;
    return 0;

    /********** End **********/
}
```"
852,4285,C&C++数组实训,gxh8sbwq7rnk,犯二的程度,12427,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数silly：计算数值有多二
// 参数：a-存储数值的字符数组，以'\0'结束，所以不需要另一个参数告诉函数数组有多长
// 返回值：数值犯二的程度
double silly(char a[]);

int main()
{
    // 定义存储数值的数组
    char s[102];

    // 输入不超过位的整数
    cin >> s;

    // 计算犯二的程度
    double sy = silly(s);

    // 输出犯二的程度
    cout << sy << endl;

    return 0;
}

double silly(char a[])
{
    // 请在此添加代码，实现函数silly
    /********** Begin *********/
    double bs=1; // 倍数
    int s=0; // 第一个数字开始的位置
    int n2=0,na=0; // 2的数量，全部位数

    // 第一位为'-'的情况
    if(a[0] == '-')
    {
        bs = bs * 1.5;
        s++;
    }

    // 判断整数的每一位
    while(a[s] != '\0')
    {
        // 判断是否为
        if(a[s] == '2')
            n2++;
        na++;
        s++;
    }

    // 判断最后一位是否为偶数
    if((a[s-1] - '0') % 2 == 0)
        bs = bs * 2;

    // 计算并返回犯二的程度
    return (double)n2 / na * bs;

    /********** End **********/
}
```"
853,4285,C&C++数组实训,fg7y9sqofhwb,队列变换,12428,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
using namespace std;

// 函数rotateLeft：矩阵循环左移
// 参数：a-100*100的二维数组，用来存储n行n列的数组（<n<100)，存储在其~n-1行和~n-1列，
// m-循环左移的位数(0<m<n)
// 返回值：无，循环左移的结果写入原二维数组中
// 说明：传递多维数组时，形式参数中，除了第一维外，其它维的大小必须给出
// 方便编译器计算每个数组元素的地址
void rotateLeft(int a[][100],int n,int m);

int main()
{
    // 定义存储二维数组的空间
    int a[100][100];
    int n, m;

    // 输入n和m
    cin >> n >> m;

    // 输入n*n的矩阵，存储在数组a的~n-1行和~n-1列
    int i, j;
    for(i = 0; i < n; i++)
        for(j = 0; j < n; j++)
            cin >> a[i][j];

    // 循环左移
    // 说明：传递多维数组时，实在参数只需要给出数组名就可以了
    rotateLeft(a,n,m);

    // 输出循环右移的结果
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < n; j++)
            cout << "" "" << a[i][j];
        cout << endl;
    }

    return 0;
}

void rotateLeft(int a[][100],int n,int m)
{
    // 请在此添加代码，实现函数rotateLeft
    /********** Begin *********/
    int t[100];
    int i, j, k;
    for(i = 0; i < m; i++)
    {
        // 缓存第一列
        for(k = 0; k < n; k++)
            t[k] = a[k][0];

        // 左移
        for(j = 0; j < n - 1; j++)   // 列
            for(k = 0; k < n; k++) // 行
                a[k][j] = a[k][j+1];

        // t放回最后一列
        for(k = 0; k < n; k++)
            a[k][n-1] = t[k];
    }
    /********** End **********/
}
```"
854,4285,C&C++数组实训,fb6fvqp8kxra,朋友圈点赞,12429,"本关任务对应参考代码实现如下：
```cpp
// 请在此添加代码，写完成upvote.cpp文件
/********** Begin *********/
#include <iostream>
using namespace std;

int main()
{
    int i, j, t;
    // 定义标签表，bq[i]存放标签i出现的次数,开始都是次
    int bq[1001] = {0};
    int N, K;

    // 输入点赞文章数
    cin >> N;

    // 逐个处理每篇文章
    for(i = 0; i < N; i++)
    {
        // 输入文章标签数
        cin >> K;
        for(j = 0; j < K; j++)
        {
            // 读入一个标签
            cin >> t;
            // 加到标签表中
            bq[t]++;
        }
    }

    // 查找出现最多的最大标签
    int maxx = 0, index = -1;
    for(i = 0; i < 1001; i++)
    {
        if(bq[i] >= maxx)
        {
            maxx = bq[i];
            index = i;
        }
    }

    // 输出标签及次数
    cout << index << "" "" << maxx << endl;

    return 0;
}

// 参数：a-100*100的二维数组，用来存储n行n列的数组（<n<100)，存储在其~n-1行和~n-1列，
// m-循环右移的位数(0<m<n)
// 返回值：无，循环右移的结果写入原二维数组中
void rotateLeft(int a[][100],int n,int m)
{
    int t[100];
    int i, j, k;
    for(i = 0; i < m; i++)
    {
        // 缓存第一列
        for(k = 0; k < n;k++)
            t[k] = a[k][0];
        // 左移
        for(j = 0; j < n - 1; j++)//列
            for(k = 0; k < n; k++)//行
                a[k][j] = a[k][j+1];
        // t放回最后一列
        for(k = 0; k < n; k++)
            a[k][n-1] = t[k];
    }
}
/********** End **********/
```"
855,71,C&C++控制结构实训,psqw6kg7tmur,分支结构：是闰年吗,86,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    int year;

    // 请在此添加代码，输入年份，并判断是否是闰年，是则输出""Yes""，否则输出""No""
    /********** Begin *********/
    cin >> year;
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
        cout << ""Yes"";
    else
        cout << ""No"";
    /********** End **********/

    return 0;
}
```"
856,71,C&C++控制结构实训,7wlorapc26u3,分支结构：一年中的第几天,10932,"```
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // y-年，m-月,d-日，n-第几天
    int y, m, d, n;

    // 请在此添加代码，输入年月日，计算并输出这天是第几天
    /********** Begin *********/
    cin >> y >> m >> d;

    n = d;
    switch(m)
    {
        case 12:
            n += 30;
        case 11:
            n += 31;
        case 10:
            n += 30;
        case 9:
            n += 31;
        case 8:
            n += 31;
        case 7:
            n += 30;
        case 6:
            n += 31;
        case 5:
            n += 30;
        case 4:
            n += 31;
        case 3:
            if((y % 4 == 0 && y % 100 != 0) || y % 400 == 0)
                n += 29;
            else
                n += 28;
        case 2:
            n += 31;
        case 1:;
    }
    /********** End **********/

    printf(""%d-%d-%d是第%d天\n"",y,m,d,n);
    return 0;
}
```"
857,71,C&C++控制结构实训,j3nyhmboafvs,分支结构：重排最大数,10933,"```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;
int main()
{
    // n-输入的数，m-重排后的数
    int n, m;
    // 请在此添加代码，输入一个小于1000的正整数，重排出最大的数存入m中
    /********** Begin *********/
    cin >> n;
    int a = n % 10, b, c, t;
    n = n / 10;
    b = n % 10;
    c = n / 10;
    if (a < b)
    {
        t = a; a = b; b = t;
    }
    if (a < c)
    {
        t = a; a = c; c = t;
    }
    if (b < c)
    {
        t = b; b = c; c = t;
    }
    m = a * 100 + b * 10 + c;
    /********** End **********/
    // 输出重排后的数
    cout << m << endl;
    return 0;
}
```"
858,71,C&C++控制结构实训,c53muf7bw62h,循环结构：黑洞陷阱,101,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    int n;
    // 请在此添加代码，输入一个各位数字不全相同的三位整数(也可以是位数或者两位数)，输出进入黑洞过程
    /********** Begin *********/
    cin >> n;
    int k = 1;
    while(1)
    {
        int a = n % 10, b, c, t;
        n = n / 10;
        b = n % 10;
        c = n / 10;
        if(a < b)
        {
            t = a; a = b; b = t;
        }
        if(a < c)
        {
            t = a; a = c; c = t;
        }
        if(b < c)
        {
            t = b; b = c; c = t;
        }
        t = a * 100 + c - c * 100 - a;
		if(t != 495)
          cout << k << "":"" << a * 100 + b * 10 + c <<""-"" << a + b * 10 + c * 100 << ""="" << t << endl;
		if( t == 495)
		  cout << k << "":"" << a * 100 + b * 10 + c <<""-"" << a + b * 10 + c * 100 << ""="" << t << endl;
        k++;
        n = t;
        if(t == 495)
            break;
    }
    /********** End **********/

    return 0;
}
```"
859,71,C&C++控制结构实训,5c362ugkynj9,循环结构：是素数吗,102,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    int n;

    // 请在此添加代码，输入正整数n，如果n是素数则输出“Yes”，否则输出“No”
    /********** Begin *********/
    cin >> n;
    if(n == 1)
    {
        cout << ""No"";
        return 0;
    }
    int flag = 1;
    for(int i = 2; i * i <= n; i++)
        if(n % i == 0)
        {
            flag = 0;
            break;
        }
    if(flag)
        cout << ""Yes"";
    else
        cout << ""No"";
    /********** End **********/

    return 0;
}
```
"
860,71,C&C++控制结构实训,afztk93eby5h,循环结构：素数和,103,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    int n, k;
    // 请在此添加代码，输入n和k，并输出n以内k个素数以及它们的和
    /********** Begin *********/
    cin >> n >> k;
    int t, m = 0, sum = 0;
    for(t = n; t >= 2; t--)
    {
        int flag = 1;
        for(int i = 2; i * i <= t; i++)
            if(t % i == 0)
            {
                flag = 0;
                break;
            }
        if(flag)
        {
            cout << t << "" "";
            m++;
            sum += t;
            if(m == k)
                break;
        }
    }
    cout << sum;
    /********** End **********/

    return 0;
}
```"
861,4283,C&C++控制结构实训,fo8f29m4g6ne,分支结构：是闰年吗,12412,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    int year;

    // 请在此添加代码，输入年份，并判断是否是闰年，是则输出""Yes""，否则输出""No""
    /********** Begin *********/
    cin >> year;
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
        cout << ""Yes"";
    else
        cout << ""No"";
    /********** End **********/

    return 0;
}
```"
862,4283,C&C++控制结构实训,k3lpu4ngmwfs,分支结构：一年中的第几天,12413,"```
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // y-年，m-月,d-日，n-第几天
    int y, m, d, n;

    // 请在此添加代码，输入年月日，计算并输出这天是第几天
    /********** Begin *********/
    cin >> y >> m >> d;

    n = d;
    switch(m)
    {
        case 12:
            n += 30;
        case 11:
            n += 31;
        case 10:
            n += 30;
        case 9:
            n += 31;
        case 8:
            n += 31;
        case 7:
            n += 30;
        case 6:
            n += 31;
        case 5:
            n += 30;
        case 4:
            n += 31;
        case 3:
            if((y % 4 == 0 && y % 100 != 0) || y % 400 == 0)
                n += 29;
            else
                n += 28;
        case 2:
            n += 31;
        case 1:;
    }
    /********** End **********/

    printf(""%d-%d-%d是第%d天\n"",y,m,d,n);
    return 0;
}
```"
863,4283,C&C++控制结构实训,w53rfsoxkgc8,分支结构：重排最大数,12414,"```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;
int main()
{
    // n-输入的数，m-重排后的数
    int n, m;
    // 请在此添加代码，输入一个小于1000的正整数，重排出最大的数存入m中
    /********** Begin *********/
    cin >> n;
    int a = n % 10, b, c, t;
    n = n / 10;
    b = n % 10;
    c = n / 10;
    if (a < b)
    {
        t = a; a = b; b = t;
    }
    if (a < c)
    {
        t = a; a = c; c = t;
    }
    if (b < c)
    {
        t = b; b = c; c = t;
    }
    m = a * 100 + b * 10 + c;
    /********** End **********/
    // 输出重排后的数
    cout << m << endl;
    return 0;
}
```"
864,4283,C&C++控制结构实训,68exs32fgfyr,循环结构：黑洞陷阱,12415,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    int n;
    // 请在此添加代码，输入一个各位数字不全相同的三位整数(也可以是位数或者两位数)，输出进入黑洞过程
    /********** Begin *********/
    cin >> n;
    int k = 1;
    while(1)
    {
        int a = n % 10, b, c, t;
        n = n / 10;
        b = n % 10;
        c = n / 10;
        if(a < b)
        {
            t = a; a = b; b = t;
        }
        if(a < c)
        {
            t = a; a = c; c = t;
        }
        if(b < c)
        {
            t = b; b = c; c = t;
        }
        t = a * 100 + c - c * 100 - a;
		if(t != 495)
          cout << k << "":"" << a * 100 + b * 10 + c <<""-"" << a + b * 10 + c * 100 << ""="" << t << endl;
		if( t == 495)
		  cout << k << "":"" << a * 100 + b * 10 + c <<""-"" << a + b * 10 + c * 100 << ""="" << t << endl;
        k++;
        n = t;
        if(t == 495)
            break;
    }
    /********** End **********/

    return 0;
}
```"
865,4283,C&C++控制结构实训,l3msfva46pcg,循环结构：是素数吗,12416,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    int n;

    // 请在此添加代码，输入正整数n，如果n是素数则输出“Yes”，否则输出“No”
    /********** Begin *********/
    cin >> n;
    if(n == 1)
    {
        cout << ""No"";
        return 0;
    }
    int flag = 1;
    for(int i = 2; i * i <= n; i++)
        if(n % i == 0)
        {
            flag = 0;
            break;
        }
    if(flag)
        cout << ""Yes"";
    else
        cout << ""No"";
    /********** End **********/

    return 0;
}
```
"
866,4283,C&C++控制结构实训,47n56gku9fs3,循环结构：素数和,12417,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    int n, k;
    // 请在此添加代码，输入n和k，并输出n以内k个素数以及它们的和
    /********** Begin *********/
    cin >> n >> k;
    int t, m = 0, sum = 0;
    for(t = n; t >= 2; t--)
    {
        int flag = 1;
        for(int i = 2; i * i <= t; i++)
            if(t % i == 0)
            {
                flag = 0;
                break;
            }
        if(flag)
        {
            cout << t << "" "";
            m++;
            sum += t;
            if(m == k)
                break;
        }
    }
    cout << sum;
    /********** End **********/

    return 0;
}
```"
867,67,C&C++表达式语句实训,zbeoy3nawclh,整型数据的运算：剩下的苹果哪去了,77,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    // 定义变量，m-苹果数，n-人数，x-人均苹果数
    int m, n, x;

    // 请在此添加代码，输入苹果数、人数，并计算人均苹果数
    /********** Begin *********/
    scanf(""%d%d"",&m,&n);
    x = m / n;
    /********** End **********/

    // 输出人均苹果数
    printf(""人均苹果数为：%d"",x);
    return 0;
}
```"
868,67,C&C++表达式语句实训,3zc7i8obfmkf,浮点型数据的运算：你的身材标准吗,78,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    float up, low;
    // 请在此添加代码，输入身高，计算标准身材的体重上下限
    /********** Begin *********/
    float h, w;
    scanf(""%f"",&h);
    w = (h - 100) * 0.9;
    low = w * 0.9;
    up = w * 1.1;
    /********** End **********/

    // 输出标准身材的体重上下限
    printf(""体重范围为：%.2f -- %.2f\n"",low,up);
    return 0;
}
```"
869,67,C&C++表达式语句实训,b7hqr2uplnk6,字符型数据的运算：循环加密是怎么实现的,79,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // c-存储输入的大写字母,d-存储加密后的大写字母
    char c, d;

    // step-秘钥，往前走的步数，大于等于，小于
    int step;

    // 请在此添加代码，输入明文、秘钥，计算密文存入d中
    /********** Begin *********/
    cin >> c >> step;
    d = c + step;
    d = (d > 'Z') ? (d - 26) : d;
    /********** End **********/

    // 输出密文
    cout << d;
    return 0;
}
```"
870,67,C&C++表达式语句实训,qienyasub2fw,二进制数据的位运算：字符是怎么存储的,80,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // c是存储输入的字符
    char c;

    // 输入字符
    cin >> c;

    // 请在此添加代码，输出c的位二进制表示
    /********** Begin *********/
    cout << (int)(bool)(c & 0x80);
    cout << (int)(bool)(c & 0x40);
    cout << (int)(bool)(c & 0x20);
    cout << (int)(bool)(c & 0x10);
    cout << (int)(bool)(c & 0x08);
    cout << (int)(bool)(c & 0x04);
    cout << (int)(bool)(c & 0x02);
    cout << (int)(bool)(c & 0x01);
    /********** End **********/

    return 0;
}
```"
871,4282,C&C++表达式语句实训,qhltcjb8we5y,整型数据的运算：剩下的苹果哪去了,12408,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    // 定义变量，m-苹果数，n-人数，x-人均苹果数
    int m, n, x;

    // 请在此添加代码，输入苹果数、人数，并计算人均苹果数
    /********** Begin *********/
    scanf(""%d%d"",&m,&n);
    x = m / n;
    /********** End **********/

    // 输出人均苹果数
    printf(""人均苹果数为：%d"",x);
    return 0;
}
```"
872,4282,C&C++表达式语句实训,xz8vapjfk7sq,浮点型数据的运算：你的身材标准吗,12409,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    float up, low;
    // 请在此添加代码，输入身高，计算标准身材的体重上下限
    /********** Begin *********/
    float h, w;
    scanf(""%f"",&h);
    w = (h - 100) * 0.9;
    low = w * 0.9;
    up = w * 1.1;
    /********** End **********/

    // 输出标准身材的体重上下限
    printf(""体重范围为：%.2f -- %.2f\n"",low,up);
    return 0;
}
```"
873,4282,C&C++表达式语句实训,4o3u9xgv7wy8,字符型数据的运算：循环加密是怎么实现的,12410,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // c-存储输入的大写字母,d-存储加密后的大写字母
    char c, d;

    // step-秘钥，往前走的步数，大于等于，小于
    int step;

    // 请在此添加代码，输入明文、秘钥，计算密文存入d中
    /********** Begin *********/
    cin >> c >> step;
    d = c + step;
    d = (d > 'Z') ? (d - 26) : d;
    /********** End **********/

    // 输出密文
    cout << d;
    return 0;
}
```"
874,4282,C&C++表达式语句实训,pjr4tn8lhifq,二进制数据的位运算：字符是怎么存储的,12411,"本关任务对应参考代码实现如下：
```cpp
// 包含两种I/O库，可以使用任一种输入输出方式
#include <stdio.h>
#include <iostream>
using namespace std;

int main()
{
    // c是存储输入的字符
    char c;

    // 输入字符
    cin >> c;

    // 请在此添加代码，输出c的位二进制表示
    /********** Begin *********/
    cout << (int)(bool)(c & 0x80);
    cout << (int)(bool)(c & 0x40);
    cout << (int)(bool)(c & 0x20);
    cout << (int)(bool)(c & 0x10);
    cout << (int)(bool)(c & 0x08);
    cout << (int)(bool)(c & 0x04);
    cout << (int)(bool)(c & 0x02);
    cout << (int)(bool)(c & 0x01);
    /********** End **********/

    return 0;
}
```"
875,60,C&C++基本输入输出实训,qeygi2ounztm,重要的事情说三遍,56,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    // 请在此添加‘重要的事情说三遍’的代码
    /********** Begin *********/
    char x = getchar();
    putchar(x);
    putchar(x);
    putchar(x);
    putchar('!');
    /********** End **********/

    return 0;
}
```"
876,60,C&C++基本输入输出实训,iwj6nfyct4le,整数四则运算表达式的输出格式控制,57,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

int main()
{
    // 声明两个整型变量，用于存储输入的两个整数
    int x, y;

    // 请在此添加你的代码，输入两个整数到x、y中，然后按要求格式输出四则运算式子
    /********** Begin *********/
    scanf(""%d%d"",&x,&y);

    printf(""%5d + %-5d = %10d\n"", x, y, x + y);
    printf(""%5d - %-5d = %10d\n"", x, y, x - y);
    printf(""%5d * %-5d = %10d\n"", x, y, x * y);
    printf(""%5d / %-5d = %10d"", x, y, x / y);
    /********** End **********/

    return 0;
}
```"
877,60,C&C++基本输入输出实训,rycojq73ef29,你好，生日,58,"本关任务对应参考代码实现如下：
```cpp
// 包含I/O流库iostream
#include <iostream>

// 加载名字空间std
using namespace std;

int main()
{
    // 声明三个变量，分别用来存储年、月、日
    int y, m, d;

    // 请在此添加你的代码，输入你的生日，并按指定格式输出信息
    /********** Begin *********/
    cin >> y >> m >> d;
    cout << ""Hello! "" << m << "" "" << d << "" "" << y;
    /********** End **********/

    return 0;
}
```"
878,60,C&C++基本输入输出实训,p56sgtmfwhj9,不同精度的PI,59,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>

// 包含流操作算子库
#include <iomanip>
using namespace std;

// 定义常量PI，后面可以直接用PI代替后面的数值
#define PI 3.14159265358979323846

int main()
{
    int n;
    // 请在此添加你的代码，输入n，按不同的精度输出PI
    /********** Begin *********/
    // 输入n
    cin >> n;

    // 输出PI
    cout << setiosflags(ios::fixed) << setprecision(n) << PI << endl;
    cout << setprecision(n + 1) << PI << endl;
    cout << setprecision(n + 2) << PI << endl;
    cout << setprecision(n + 3) << PI << endl;
    cout << setprecision(n + 4) << PI;
    /********** End **********/

    return 0;
}
```"
879,4281,C&C++基本输入输出实训,g37whmivbozl,重要的事情说三遍,12404,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

// 定义main函数
int main()
{
    // 请在此添加‘重要的事情说三遍’的代码
    /********** Begin *********/
    char x = getchar();
    putchar(x);
    putchar(x);
    putchar(x);
    putchar('!');
    /********** End **********/

    return 0;
}
```"
880,4281,C&C++基本输入输出实训,kgiur9zwsc6h,整数四则运算表达式的输出格式控制,12405,"本关任务对应参考代码实现如下：
```cpp
// 包含标准输入输出函数库
#include <stdio.h>

int main()
{
    // 声明两个整型变量，用于存储输入的两个整数
    int x, y;

    // 请在此添加你的代码，输入两个整数到x、y中，然后按要求格式输出四则运算式子
    /********** Begin *********/
    scanf(""%d%d"",&x,&y);

    printf(""%5d + %-5d = %10d\n"", x, y, x + y);
    printf(""%5d - %-5d = %10d\n"", x, y, x - y);
    printf(""%5d * %-5d = %10d\n"", x, y, x * y);
    printf(""%5d / %-5d = %10d"", x, y, x / y);
    /********** End **********/

    return 0;
}
```"
881,4281,C&C++基本输入输出实训,fx47tahplirf,你好，生日,12406,"本关任务对应参考代码实现如下：
```cpp
// 包含I/O流库iostream
#include <iostream>

// 加载名字空间std
using namespace std;

int main()
{
    // 声明三个变量，分别用来存储年、月、日
    int y, m, d;

    // 请在此添加你的代码，输入你的生日，并按指定格式输出信息
    /********** Begin *********/
    cin >> y >> m >> d;
    cout << ""Hello! "" << m << "" "" << d << "" "" << y;
    /********** End **********/

    return 0;
}
```"
882,4281,C&C++基本输入输出实训,4ymfro8xzvps,不同精度的PI,12407,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>

// 包含流操作算子库
#include <iomanip>
using namespace std;

// 定义常量PI，后面可以直接用PI代替后面的数值
#define PI 3.14159265358979323846

int main()
{
    int n;
    // 请在此添加你的代码，输入n，按不同的精度输出PI
    /********** Begin *********/
    // 输入n
    cin >> n;

    // 输出PI
    cout << setiosflags(ios::fixed) << setprecision(n) << PI << endl;
    cout << setprecision(n + 1) << PI << endl;
    cout << setprecision(n + 2) << PI << endl;
    cout << setprecision(n + 3) << PI << endl;
    cout << setprecision(n + 4) << PI;
    /********** End **********/

    return 0;
}
```"
883,49,C++之整数计算基础,c8euogn6bwxj, 编写一个简单的加法计算器,28,"本关任务对应参考代码实现如下：
```cpp
// 求两数和的带值函数
double TwoNumberAdd(float a, float b)
{
    // 请在此添加代码，补全函数TwoNumberAdd
    /********** Begin *********/
    return a+b;
    /********** End **********/
}
```
"
884,49,C++之整数计算基础,v7rqjtwc43p2,求一个数的算术平方根,29,"本关任务对应参考代码实现如下：
```cpp
#include <math.h>

// 求n的算术平方根
double SquareRoot(float n)
{
    // 请在此添加代码，补全函数SquareRoot
    /********** Begin *********/
    return n > 0 ? sqrt(n) : -1;

    /********** End **********/
}
```"
885,49,C++之整数计算基础,gyobkcqifz9v,求一元二次方程ax^2+bx+c=0的实数根,30,"本关任务对应参考代码实现如下：
```cpp
#include <iostream>
#include <math.h>
using namespace std;

int main()
{
    float a, b, c;

    // 从命令行读入三个float型数值
    // 这三个数取自测试集的输入
    cin >> a >> b >> c;

    // 请在下面添加实现代码
    /**********Program**********/
    float det = b * b - 4 * a * c;
    double x1 = (-b + sqrt(det)) / (2 * a);
    double x2 = (-b - sqrt(det)) / (2 * a);

    det > 0 ? ( cout << x1 << "" "" << x2 << endl) : (det == 0 ? (cout << x1 << endl) : (cout << ""方程无实数根"" << endl));
    /**********  End  **********/
}
```"
886,954,离散傅里叶变换,5y493xf6m2lq,二维离散傅里叶变换DFT,1935,"对行数据做一维DFT:
```cpp
/********* Begin *********/
Image_TMP_R[i*Image_In->width + j] = Image_TMP_R_2[j];
Image_TMP_I[i*Image_In->width + j] = Image_TMP_I_2[j];
/********* End *********/
```

对列数据做一维DFT:
```cpp
/********* Begin *********/
Image_OUT_R[j*Image_In->width + i] = Image_TMP_R_2[j];
Image_OUT_I[j*Image_In->width + i] = Image_TMP_I_2[j];
/********* End *********/
```"
887,960,彩色图像增强,bvuzmhslajwg,伪彩色增强,1950,"对B通道处理
```cpp
/********* Begin *********/
Image_PseudoColor_b = 255;
/********* End *********/


/********* Begin *********/
Image_PseudoColor_b = -255/64 * (Image_In_Pixel - 64) + 255 ;
/********* End *********/


/********* Begin *********/
Image_PseudoColor_b = 0;
/********* End *********/
```

对G通道处理
```cpp
/********* Begin *********/
Image_PseudoColor_g = 255/64 * Image_In_Pixel;
/********* End *********/


/********* Begin *********/
Image_PseudoColor_g = 255 ; 
/********* End *********/


/********* Begin *********/
Image_PseudoColor_g = -255/64 * (Image_In_Pixel -192) + 255 ; 
/********* End *********/
```
对R通道处理
```cpp
/********* Begin *********/
Image_PseudoColor_r = 0;
/********* End *********/


/********* Begin *********/
Image_PseudoColor_r = 255/64 * (Image_In_Pixel -128); 
/********* End *********/


/********* Begin *********/
Image_PseudoColor_r = 255 ;
/********* End *********/
```"
888,959,颜色的空间表示及其转换,zes3i5f7nvog,RGB与HSI空间的相互转换,1949,"```cpp
/********* Begin *********/
// 计算Hue分量
if(img_b <= img_g)
	Hue = theta ;
else
	Hue = 360 - theta;
/********* End *********/
```

```cpp
/********* Begin *********/
// 计算Saturation分量
float Saturation = 1 - (float)(3 * min_rgb)/(img_r + img_g + img_b);
/********* End *********/
```

```cpp
/********* Begin *********/
// 计算Intensity分量
int Intensity = (int)((img_b + img_g + img_r)/3); 
/********* End *********/
```"
889,958,频域的锐化,umioz3yfsf98,理想_高通滤波,1946,"```cpp
/********* Begin *********/
Ideal_HighPass->imageData[i*im->width+j] = 255;
/********* End *********/
```"
890,958,频域的锐化,obmf7i9rk6s8,巴特沃斯高通滤波,1947,"```cpp
/********* Begin *********/
ButterWorth_HighPass->imageData[i*im->width+j] = 255/(1+pow(D0/D,2*n));
/********* End *********/
```"
891,958,频域的锐化,c2hwut8x5ksz,高斯高通滤波,1948,"```cpp
/********* Begin *********/
Gauss_HighPass->imageData[i*im->width+j] = 255*(1-exp(-0.5*pow(D,2)/pow(D0,2)));
/********* End *********/
```"
892,957,频域的平滑,x2znb36gkqlt,理想_低通滤波,1943,"```cpp
/********* Begin *********/
Ideal_LowPass->imageData[i*im->width+j] = 255;
/********* End *********/
```"
893,957,频域的平滑,fwoxsybmh5v9,巴特沃斯低通滤波,1944,"```cpp
/********* Begin *********/
ButterWorth_LowPass->imageData[i*im->width+j] = 255/(1+pow(D/D0,2*n));
/********* End *********/
```"
894,957,频域的平滑,j2c3vamln4yo,高斯低通滤波,1945,"```cpp
/********* Begin *********/
Gauss_LowPass->imageData[i*im->width+j] = 255*exp(-0.5*pow(D,2)/pow(D0,2));
/********* End *********/
```"
895,956,空域的锐化,xi7rcf48j9wb,Roberts梯度算子,1939,"```cpp
/********* Begin *********/
index1=i*Image_In->width+j;
index2=(i+1)*Image_In->width+j;

int d1 = Image_In->imageData[index2+1];
int d2 = Image_In->imageData[index1];
int d3 = Image_In->imageData[index2];
int d4 = Image_In->imageData[index1+1];

tmp = abs(Image_In->imageData[index2+1] - Image_In->imageData[index1]) + abs(Image_In->imageData[index2] - Image_In->imageData[index1+1]);
Roberts->imageData[k] = tmp;
k++;
/********* End *********/
```"
896,956,空域的锐化,2sxvqbzjywaf,Sobel梯度算子,1940,"```cpp
/********* Begin *********/
index1=(i-1)*Image_In->width+j;
index2=i*Image_In->width+j;
index3=(i+1)*Image_In->width+j;

int tmp1 = abs(-Image_In->imageData[index1-1] - 2*Image_In->imageData[index1] - Image_In->imageData[index1+1] +
Image_In->imageData[index3-1] +  2*Image_In->imageData[index3] + Image_In->imageData[index3+1]);

int tmp2 = abs(-Image_In->imageData[index1-1] - 2*Image_In->imageData[index2-1] - Image_In->imageData[index2-1] +
Image_In->imageData[index1+1] + 2*Image_In->imageData[index2+1] + Image_In->imageData[index3+1]);

Image_Sobel->imageData[k] = tmp1+tmp2;
k++;
/********* End *********/
```"
897,956,空域的锐化,uks9xb6cze5r,Prewitt梯度算子,1941,"```cpp
/********* Begin *********/
index1=(i-1)*Image_In->width+j;
index2=i*Image_In->width+j;
index3=(i+1)*Image_In->width+j;

int tmp1 = abs(-Image_In->imageData[index1-1] - Image_In->imageData[index1] - Image_In->imageData[index1+1] +
Image_In->imageData[index3-1] + Image_In->imageData[index3] + Image_In->imageData[index3+1]);

int tmp2 = abs(-Image_In->imageData[index1-1] - Image_In->imageData[index2-1] - Image_In->imageData[index2-1] +
Image_In->imageData[index1+1] + Image_In->imageData[index2+1] + Image_In->imageData[index3+1]);

Image_Prewitt->imageData[k] = tmp1+tmp2;
k++;
/********* End *********/
```"
898,956,空域的锐化,wjh3ksfbpyt9,Laplacian梯度算子,1942,"```cpp
/********* Begin *********/
index1=(i-1)*Image_In->width+j;
index2=i*Image_In->width+j;
index3=(i+1)*Image_In->width+j;

tmp =(-Image_In->imageData[index1] - Image_In->imageData[index2-1] + 4*Image_In->imageData[index2] - Image_In->imageData[index2+1] - Image_In->imageData[index3]);
if(tmp<0) tmp = 0;
else if(tmp>=255) tmp = 255;

Image_Laplacian->imageData[k] = tmp ;
k++;
/********* End *********/
```"
899,955,空域的平滑,bg8rnfs9y4jz,邻域平均法,1936,"```cpp
/********* Begin *********/
index1 = (i-1)*Image_In->width+j;
index2 = i*Image_In->width+j;
index3 = (i+1)*Image_In->width+j;
tmp = (Image_In->imageData[index1-1] + Image_In->imageData[index1] + Image_In->imageData[index1+1] + Image_In->imageData[index2-1] + Image_In->imageData[index2]  +  Image_In->imageData[index2+1]  +
Image_In->imageData[index3-1] + Image_In->imageData[index3] + Image_In->imageData[index3+1])/9;
Image_MeanFilter->imageData[k] = tmp;
k++;
/********* End *********/
```"
900,955,空域的平滑,mv9tzqfaiwye,中值滤波法(3*3),1937,"```cpp
/********* Begin *********/
index1=(i-1)*Image_In->width+j;
index2=i*Image_In->width+j;
index3=(i+1)*Image_In->width+j;

int Med1 = Med(Image_In->imageData[index1-1],Image_In->imageData[index1],Image_In->imageData[index1+1]);
int Med2 = Med(Image_In->imageData[index2-1],Image_In->imageData[index2],Image_In->imageData[index2+1]);
int Med3 = Med(Image_In->imageData[index3-1],Image_In->imageData[index3],Image_In->imageData[index3+1]);
int Med4 = Med(Med1,Med2,Med3);
Image_MedFilter->imageData[k] = Med4;
k++;
/********* End *********/
```"
901,955,空域的平滑,of9igu46jnq3,中值滤波法（5*5）,1938,"```cpp
/********* Begin *********/
index1=(i-2)*Image_In->width+j;
index2=(i-1)*Image_In->width+j;
index3=i*Image_In->width+j;
index4=(i+1)*Image_In->width+j;
index5=(i+2)*Image_In->width+j;

int Med1 = ForMed(Image_In->imageData[index1-1],Image_In->imageData[index1],Image_In->imageData[index1+1]);
int Med2 = ForMed(Image_In->imageData[index2-1],Image_In->imageData[index2],Image_In->imageData[index2+1]);
int Med3 = ForMed(Image_In->imageData[index3-1],Image_In->imageData[index3],Image_In->imageData[index3+1]);
int Med4 = ForMed(Image_In->imageData[index4-1],Image_In->imageData[index4],Image_In->imageData[index4+1]);
int Med5 = ForMed(Image_In->imageData[index5-1],Image_In->imageData[index5],Image_In->imageData[index5+1]);
int Med6= ForMed(Med1,Med2,Med3);
int Med7= ForMed(Med4,Med5,Med6);
Image_MedFilter1->imageData[k] = Med7;
k++;
/********* End *********/
```"
902,951,灰度修正,ri4y6hpnq3fe,图像反色,1925,"```cpp
/********* Begin *********/
Image_InvertColor->imageData[i] = 0xffff - Image_In->imageData[i];
/********* End *********/
```"
903,951,灰度修正,f5h6tizuwkj4,线性变换,1926,"```cpp
/********* Begin *********/
Image_LinerTrans->imageData[i] = (int) (255*1.0/(b-a)*Image_In->imageData[i] - 255*a/(b-a));
/********* End *********/
```"
904,951,灰度修正,pf3f8l4bq7zi,直方图均衡化,1927,"```cpp
/********* Begin *********/
NumPixel[Image_In->imageData[i]]++;//完成输入图像像素值统计代码
/********* End *********/

/********* Begin *********/
ProbPixel[i] = (float)NumPixel[i]/(float)size;//完成输入图像像素值概率代码 ，注意整数型转换成浮点型
/********* End *********/

/********* Begin *********/
AccuProbPixel[i] = AccuProbPixel[i-1] + ProbPixel[i];//完成输入图像累积直方图计算
/********* End *********/

/********* Begin *********/
AccuPixel[i] = (int)(AccuProbPixel[i]*255);//完成输入图像累积直方图取整代码编写，注意浮点型转换为整数型
/********* End *********/

/********* Begin *********/
Image_HistNormolize->imageData[i] = AccuPixel[Image_In->imageData[i]];//通过均衡化后对原图像像素值重新映射
/********* End *********/
```"
905,962,图像的阈值分割技术,y3jm2buq8krv,全局阈值分割,1952,"```cpp
/********* Begin *********/
if(Image_In->imageData[i] > Th)    tmp1 = 1; else tmp1 = 0;
if(Image_In->imageData[i+1] > Th)  tmp2 = 1; else tmp2 = 0;
if(Image_In->imageData[i+2] > Th)  tmp3 = 1; else tmp3 = 0;
if(Image_In->imageData[i+3] > Th)  tmp4 = 1; else tmp4 = 0;
if(Image_In->imageData[i+4] > Th)  tmp5 = 1; else tmp5 = 0;
if(Image_In->imageData[i+5] > Th)  tmp6 = 1; else tmp6 = 0;
if(Image_In->imageData[i+6] > Th)  tmp7 = 1; else tmp7 = 0;
if(Image_In->imageData[i+7] > Th)  tmp8 = 1; else tmp8 = 0;
tmp = tmp1*128 + tmp2*64 + tmp3*32 + tmp4*16 + tmp5*8 + tmp6*4  + tmp7*2  + tmp8*1;
Image_GlobalSegmentation->imageData[i/8] = tmp;
/********* End *********/
```"
906,962,图像的阈值分割技术,k4cxln7vj6wy,局部阈值分割,1953,"```cpp
/********* Begin *********/
//对左上角的图片进行处理
if(Image_In->imageData[i*Image_In->width+j] > Th1)    tmp1 = 1; else tmp1 = 0;
if(Image_In->imageData[i*Image_In->width+j+1] > Th1)  tmp2 = 1; else tmp2 = 0;
if(Image_In->imageData[i*Image_In->width+j+2] > Th1)  tmp3 = 1; else tmp3 = 0;
if(Image_In->imageData[i*Image_In->width+j+3] > Th1)  tmp4 = 1; else tmp4 = 0;
if(Image_In->imageData[i*Image_In->width+j+4] > Th1)  tmp5 = 1; else tmp5 = 0;
if(Image_In->imageData[i*Image_In->width+j+5] > Th1)  tmp6 = 1; else tmp6 = 0;
if(Image_In->imageData[i*Image_In->width+j+6] > Th1)  tmp7 = 1; else tmp7 = 0;
if(Image_In->imageData[i*Image_In->width+j+7] > Th1)  tmp8 = 1; else tmp8 = 0;
tmp = tmp1*128 + tmp2*64 + tmp3*32 + tmp4*16 + tmp5*8 + tmp6*4  + tmp7*2  + tmp8*1;
Image_LocalSegmentation->imageData[(i*Image_In->width+j)/8] = tmp;
/********* End *********/

/********* Begin *********/
//对右上角的图片进行处理
if(Image_In->imageData[i*Image_In->width+j] > Th2)    tmp1 = 1; else tmp1 = 0;
if(Image_In->imageData[i*Image_In->width+j+1] > Th2)  tmp2 = 1; else tmp2 = 0;
if(Image_In->imageData[i*Image_In->width+j+2] > Th2)  tmp3 = 1; else tmp3 = 0;
if(Image_In->imageData[i*Image_In->width+j+3] > Th2)  tmp4 = 1; else tmp4 = 0;
if(Image_In->imageData[i*Image_In->width+j+4] > Th2)  tmp5 = 1; else tmp5 = 0;
if(Image_In->imageData[i*Image_In->width+j+5] > Th2)  tmp6 = 1; else tmp6 = 0;
if(Image_In->imageData[i*Image_In->width+j+6] > Th2)  tmp7 = 1; else tmp7 = 0;
if(Image_In->imageData[i*Image_In->width+j+7] > Th2)  tmp8 = 1; else tmp8 = 0;
tmp = tmp1*128 + tmp2*64 + tmp3*32 + tmp4*16 + tmp5*8 + tmp6*4  + tmp7*2  + tmp8*1;
Image_LocalSegmentation->imageData[(i*Image_In->width+j)/8] = tmp;
/********* End *********/

/********* Begin *********/
//对左下角的图片进行处理
if(Image_In->imageData[i*Image_In->width+j] > Th3)    tmp1 = 1; else tmp1 = 0;
if(Image_In->imageData[i*Image_In->width+j+1] > Th3)  tmp2 = 1; else tmp2 = 0;
if(Image_In->imageData[i*Image_In->width+j+2] > Th3)  tmp3 = 1; else tmp3 = 0;
if(Image_In->imageData[i*Image_In->width+j+3] > Th3)  tmp4 = 1; else tmp4 = 0;
if(Image_In->imageData[i*Image_In->width+j+4] > Th3)  tmp5 = 1; else tmp5 = 0;
if(Image_In->imageData[i*Image_In->width+j+5] > Th3)  tmp6 = 1; else tmp6 = 0;
if(Image_In->imageData[i*Image_In->width+j+6] > Th3)  tmp7 = 1; else tmp7 = 0;
if(Image_In->imageData[i*Image_In->width+j+7] > Th3)  tmp8 = 1; else tmp8 = 0;
tmp = tmp1*128 + tmp2*64 + tmp3*32 + tmp4*16 + tmp5*8 + tmp6*4  + tmp7*2  + tmp8*1;
Image_LocalSegmentation->imageData[(i*Image_In->width+j)/8] = tmp;
/********* End *********/

/********* Begin *********/
//对右下角的图片进行处理
if(Image_In->imageData[i*Image_In->width+j] > Th4)    tmp1 = 1; else tmp1 = 0;
if(Image_In->imageData[i*Image_In->width+j+1] > Th4)  tmp2 = 1; else tmp2 = 0;
if(Image_In->imageData[i*Image_In->width+j+2] > Th4)  tmp3 = 1; else tmp3 = 0;
if(Image_In->imageData[i*Image_In->width+j+3] > Th4)  tmp4 = 1; else tmp4 = 0;
if(Image_In->imageData[i*Image_In->width+j+4] > Th4)  tmp5 = 1; else tmp5 = 0;
if(Image_In->imageData[i*Image_In->width+j+5] > Th4)  tmp6 = 1; else tmp6 = 0;
if(Image_In->imageData[i*Image_In->width+j+6] > Th4)  tmp7 = 1; else tmp7 = 0;
if(Image_In->imageData[i*Image_In->width+j+7] > Th4)  tmp8 = 1; else tmp8 = 0;
tmp = tmp1*128 + tmp2*64 + tmp3*32 + tmp4*16 + tmp5*8 + tmp6*4  + tmp7*2  + tmp8*1;
Image_LocalSegmentation->imageData[(i*Image_In->width+j)/8] = tmp;
/********* End *********/
```"
907,961,假彩色处理,5icvgx962l8f,假彩色增强,1951,"```cpp
/********* Begin *********/
Image_FalseColor_b = Image_In_g;       //对B通道处理
Image_FalseColor_g = Image_In_r;       //对G通道处理
Image_FalseColor_r = Image_In_b;       //对R通道处理
/********* End *********/
```"
908,963,图像编解码,3fk42jzlhn6y,频谱图的游程编码,1955,"```cpp
/********* Begin *********/
for(j=i+1;j<InputIm->height*InputIm->width;j++)
{
	if( tmp == InputIm->imageData[j])
	{
		if(num == 255) break;
		else num++;
	}
    else break;
}
i=j;
RLC_Code.push_back(tmp);
RLC_Code.push_back(num);
k=k+2;
/********* End *********/
```"
909,963,图像编解码,aql8v25mkf47,频谱图的游程解码,1956,"```cpp
/********* Begin *********/
code = RLC_Code[i];
len = RLC_Code[i+1];
for(j=0;j<len;j++)
{
	OutputIm->imageData[k] = code;
 k++;
}
/********* End *********/
```"
910,953,BMP图像的写,x9wg2v56usf7,1位黑白BMP图像的写,1932,"```cpp
/********* Begin *********/
pixVal = bmpImg->imageData[i*bmpImg->width/8+j];
/********* End *********/
```"
911,953,BMP图像的写,gwaoxltmrhep,8位灰度BMP图像的写,1933,"```cpp
/********* Begin *********/
pixVal = bmpImg->imageData[i*bmpImg->width+j];
/********* End *********/
```"
912,953,BMP图像的写,i3f6zu8m29fq,24位彩色BMP图像的写,1934,"```cpp
/********* Begin *********/
pixVal = bmpImg->imageData[i*bmpImg->width*3+j*3]; 
/********* End *********/

/********* Begin *********/
pixVal = bmpImg->imageData[i*bmpImg->width*3+j*3+1];
/********* End *********/

/********* Begin *********/
pixVal = bmpImg->imageData[i*bmpImg->width*3+j*3+2];
/********* End *********/
```"
913,952,BMP图像的读,r5tf3iagwh7f,1位黑白BMP图像的读,13658,"```cpp
#include ""BMP.h""


BMP_Image* BMP_LoadImage(char* path)
{

    BMP_BitMapFileHeader bmpFileHeader;
    BMP_BitMapInfoHeader bmpInfoHeader;
    BMP_RgbQuad* quad;
    BMP_Image* bmpImg;

    FILE* pFile;

    int width = 0;
    int height = 0;
	int offset;
    unsigned char pixVal;

    int i, j, k;
    bmpImg = (BMP_Image*)malloc(sizeof(BMP_Image));
    pFile = fopen(path, ""rb"");
    if (!pFile)
    {
        free(bmpImg);
        return NULL;
    }

    fread(&bmpFileHeader, sizeof(BMP_BitMapFileHeader), 1, pFile);


    fread(&bmpInfoHeader, sizeof(BMP_BitMapInfoHeader), 1, pFile);

        if (bmpInfoHeader.biBitCount == 1)
        {
            width = bmpInfoHeader.biWidth;
            height = bmpInfoHeader.biHeight;

            bmpImg->width = width;
            bmpImg->height = height;
            bmpImg->biBitCount = 1;
            bmpImg->imageRgbQuad = (BMP_RgbQuad*)malloc(sizeof(BMP_RgbQuad)*2);//变量分配内存
            bmpImg->imageData = (unsigned char*)malloc(sizeof(unsigned char)*width*height/8);
            quad = (BMP_RgbQuad*)malloc(sizeof(BMP_RgbQuad)*2);//读出bmp原图调色板值
            fread(quad, sizeof(BMP_RgbQuad), 2, pFile);

			for(i=0;i<2;i++)//将原图调色板值赋值给新的变量
			{
 		     bmpImg->imageRgbQuad[i].rgbBlue = quad[i].rgbBlue;
			 bmpImg->imageRgbQuad[i].rgbGreen = quad[i].rgbGreen;
 		     bmpImg->imageRgbQuad[i].rgbRed = quad[i].rgbRed;
 		     bmpImg->imageRgbQuad[i].rgbReserved = quad[i].rgbReserved;
            }

            for (i=0; i<height; i++)//按序读出bmp每个字节按从下往上的顺序读出存储
            {
                for (j=0; j<width/8; j++)
                {
					fread(&pixVal, sizeof(unsigned char), 1, pFile);
					/********* Begin *********/
					bmpImg->imageData[(height-1-i)*width/8+j] = pixVal ;

					/********* End *********/
                }
            }
        }
    return bmpImg;
}

```"
914,952,BMP图像的读,fapqyglfnxem,8位灰度BMP图像的读,1930,"```cpp
/********* Begin *********/
bmpImg->imageData[(height-1-i)*width+j] = pixVal;
/********* End *********/
```"
915,952,BMP图像的读,6ja27lpbfmw3,24位彩色BMP图像的读,1931,"```cpp
/********* Begin *********/
bmpImg->imageData[(height-1-i)*width*3+j*3+k] = pixVal;
/********* End *********/
```"
